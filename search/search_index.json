{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pyAussieBB This is a very simple module for interacting with the Aussie Broadband APIs. I wrote this so I can pull a line test periodically and show the NBN how garbage they are. Usage pip install --user pyaussiebb python >>> from aussiebb import AussieBB >>> account = AussieBB(username, password) >>> account.get_services() [{allyourservicedetails}] For more, check out the docs. AsyncIO version You can replace from aussiebb import AussieBB with from aussiebb.asyncio import AussieBB and you'll get an aiohttp -powered version. The only difference in this case is that you have to explicitly call login() for reasons. If you hit the rate limit it'll raise a RateLimit exception. I haven't put that functionality into the blocking version yet, since ... that tends not to hit it. \ud83e\udd23 Development Example service tests I've seen All the \"endpoints\" below should be tacked onto aussiebb.BASEURL['api'] . Warning: /nbn/{service_id}/connection seems to have both a GET and POST method endpoint - tests on other endpoints may be similar. These can be run by using AussieBB.run_test() with the string after the last forward-slash as the \"test\" - ie, connection or linestate . HFC These are entirely untested so far. Endpoint Method Name Description /nbn/{service_id}/connection Probably GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/loopback Probably POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/ntdstatus Probably POST NTD Status An NTD Status will show you the operational state of the Network Termination Device (NTD). The test will also show if the NTD is detecting the wired connection from your router. FTTC Endpoint Method Name Description /nbn/{service_id}/connection GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/dpuportreset Probably POST DPU Port Reset Reset the Port on the DPU (Distribution Point Unit) along with clearing any errors that maybe causing issues with connectivity. /tests/{service_id}/dpuportstatus POST DPU Port Status A DPU (Distribution Point Unit) port status will show if the NCD (Network Connection Device) is providing power to the DPU. It will also state if the NCD (Network Connection Device) is in sync. /tests/{service_id}/dpustatus POST DPU Status This will provide if the DPU (Distribution Point Unit) is currently being powered. /tests/{service_id}/loopback POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/ncdportreset Probably POST NCD Port Reset Reset the gateway port on your NCD (Network Connection Device). /tests/{service_id}/ncdreset Probably POST NCD Reset This will remotely restart your Network Termination Device. FTTN Endpoint Method Name Description /nbn/{service_id}/connection GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/linestate POST Line State A line state test will determine if you have \u201csync\u201d (connection) to the node. If the service is in sync this test will also return your maximum and current attainable transfer rate. /tests/{service_id}/loopback POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/portreset Probably POST Port Reset This will reset the connection from the Node and also clear errors that may be causing issues with gaining sync. /tests/{service_id}/stabilityprofile Probably POST Stability Profile This will apply changes to your FTTN service including allowing increased noise to occur before making the connection unstable. This will cause your speeds to degrade as a result, but in turn making the service more stable. For NBN to investigate a fault this profile needs to be applied and a minimum of 5 dropouts recorded over a 24hr period on NBN's systems before a dropout fault can be raised FTTP These are as-yet untested. Endpoint Method Name Description /nbn/{service_id}/connection Probably GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/loopback Probably POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/portreset Probably POST Port Reset This will reset the connection from the Node and also clear errors that may be causing issues with gaining sync. /tests/{service_id}/unidstatus Probably POST UNI-D Status UNI-D Status will show if the UNI-D port you are currently using has a router connected to it. This will also provide the Link speed your router and UNI-D port are connected at Eg, 100mbit or 1gbit. You will also see the MAC address of the currently connected router. Changelog 0.0.3 - Added get_service_plans so the gigabit-desperate crowd can check for their new hotness. 0.0.4 - Added asyncio submodule, split constants and exceptions out into their own files/modules. 0.0.5/6 - Fixing rate limiting 0.0.7 Added the following new functions: account_transactions , billing_invoice , service_outages , service_boltons , service_datablocks , support_tickets , account contacts . Renamed get_service_plans to service_plans 0.0.8 renamed serviceid to service_id to match the api added request_get_json to the sync class added telephony_usage added get_appointment which gets service appointments updated get_usage so it checks the service list and will return telephony data if it's a PhoneMobile service abstracted how URLS are generated so I don't have to keep adding them twice added a filter on get_services which allows you to filter by type","title":"Home"},{"location":"#pyaussiebb","text":"This is a very simple module for interacting with the Aussie Broadband APIs. I wrote this so I can pull a line test periodically and show the NBN how garbage they are.","title":"pyAussieBB"},{"location":"#usage","text":"pip install --user pyaussiebb python >>> from aussiebb import AussieBB >>> account = AussieBB(username, password) >>> account.get_services() [{allyourservicedetails}] For more, check out the docs.","title":"Usage"},{"location":"#asyncio-version","text":"You can replace from aussiebb import AussieBB with from aussiebb.asyncio import AussieBB and you'll get an aiohttp -powered version. The only difference in this case is that you have to explicitly call login() for reasons. If you hit the rate limit it'll raise a RateLimit exception. I haven't put that functionality into the blocking version yet, since ... that tends not to hit it. \ud83e\udd23","title":"AsyncIO version"},{"location":"#development","text":"","title":"Development"},{"location":"#example-service-tests-ive-seen","text":"All the \"endpoints\" below should be tacked onto aussiebb.BASEURL['api'] . Warning: /nbn/{service_id}/connection seems to have both a GET and POST method endpoint - tests on other endpoints may be similar. These can be run by using AussieBB.run_test() with the string after the last forward-slash as the \"test\" - ie, connection or linestate .","title":"Example service tests I've seen"},{"location":"#hfc","text":"These are entirely untested so far. Endpoint Method Name Description /nbn/{service_id}/connection Probably GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/loopback Probably POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/ntdstatus Probably POST NTD Status An NTD Status will show you the operational state of the Network Termination Device (NTD). The test will also show if the NTD is detecting the wired connection from your router.","title":"HFC"},{"location":"#fttc","text":"Endpoint Method Name Description /nbn/{service_id}/connection GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/dpuportreset Probably POST DPU Port Reset Reset the Port on the DPU (Distribution Point Unit) along with clearing any errors that maybe causing issues with connectivity. /tests/{service_id}/dpuportstatus POST DPU Port Status A DPU (Distribution Point Unit) port status will show if the NCD (Network Connection Device) is providing power to the DPU. It will also state if the NCD (Network Connection Device) is in sync. /tests/{service_id}/dpustatus POST DPU Status This will provide if the DPU (Distribution Point Unit) is currently being powered. /tests/{service_id}/loopback POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/ncdportreset Probably POST NCD Port Reset Reset the gateway port on your NCD (Network Connection Device). /tests/{service_id}/ncdreset Probably POST NCD Reset This will remotely restart your Network Termination Device.","title":"FTTC"},{"location":"#fttn","text":"Endpoint Method Name Description /nbn/{service_id}/connection GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/linestate POST Line State A line state test will determine if you have \u201csync\u201d (connection) to the node. If the service is in sync this test will also return your maximum and current attainable transfer rate. /tests/{service_id}/loopback POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/portreset Probably POST Port Reset This will reset the connection from the Node and also clear errors that may be causing issues with gaining sync. /tests/{service_id}/stabilityprofile Probably POST Stability Profile This will apply changes to your FTTN service including allowing increased noise to occur before making the connection unstable. This will cause your speeds to degrade as a result, but in turn making the service more stable. For NBN to investigate a fault this profile needs to be applied and a minimum of 5 dropouts recorded over a 24hr period on NBN's systems before a dropout fault can be raised","title":"FTTN"},{"location":"#fttp","text":"These are as-yet untested. Endpoint Method Name Description /nbn/{service_id}/connection Probably GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/loopback Probably POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/portreset Probably POST Port Reset This will reset the connection from the Node and also clear errors that may be causing issues with gaining sync. /tests/{service_id}/unidstatus Probably POST UNI-D Status UNI-D Status will show if the UNI-D port you are currently using has a router connected to it. This will also provide the Link speed your router and UNI-D port are connected at Eg, 100mbit or 1gbit. You will also see the MAC address of the currently connected router.","title":"FTTP"},{"location":"#changelog","text":"0.0.3 - Added get_service_plans so the gigabit-desperate crowd can check for their new hotness. 0.0.4 - Added asyncio submodule, split constants and exceptions out into their own files/modules. 0.0.5/6 - Fixing rate limiting 0.0.7 Added the following new functions: account_transactions , billing_invoice , service_outages , service_boltons , service_datablocks , support_tickets , account contacts . Renamed get_service_plans to service_plans 0.0.8 renamed serviceid to service_id to match the api added request_get_json to the sync class added telephony_usage added get_appointment which gets service appointments updated get_usage so it checks the service list and will return telephony data if it's a PhoneMobile service abstracted how URLS are generated so I don't have to keep adding them twice added a filter on get_services which allows you to filter by type","title":"Changelog"},{"location":"aussiebb/","text":"A class for interacting with Aussie Broadband APIs AussieBB A class for interacting with Aussie Broadband APIs __init__ ( self , username , password , debug = False ) special Setup function. Source code in aussiebb/__init__.py def __init__ ( self , username : str , password : str , debug : bool = False ): \"\"\" Setup function. \"\"\" self . username = username self . password = password self . debug = debug if not ( username and password ): raise AuthenticationException ( \"You need to supply both username and password\" ) self . session = requests . Session () self . myaussie_cookie = \"\" self . token_expires = - 1 account_contacts ( self ) pulls the contacts with the account, returns a list of dicts dict keys: ['id', 'first_name', 'last_name', 'email', 'dog', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact'] Source code in aussiebb/__init__.py def account_contacts ( self ): \"\"\" pulls the contacts with the account, returns a list of dicts dict keys: ['id', 'first_name', 'last_name', 'email', 'dog', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact'] \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) return self . request_get_json ( url = url ) account_paymentplans ( self ) returns a json blob of payment plans for an account Source code in aussiebb/__init__.py def account_paymentplans ( self ): \"\"\" returns a json blob of payment plans for an account \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) return self . request_get_json ( url = url ) account_transactions ( self ) pulls the json for transactions on your account keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] returns a dict where the key is the Month and year of the transaction, eg: ``` \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], Source code in aussiebb/__init__.py def account_transactions ( self ): \"\"\" pulls the json for transactions on your account keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] returns a dict where the key is the Month and year of the transaction, eg: ``` \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) return self . request_get_json ( url = url ) billing_invoice ( self , invoice_id ) downloads an invoice this returns the bare response object, parsing the result is an exercise for the consumer Source code in aussiebb/__init__.py def billing_invoice ( self , invoice_id ): \"\"\" downloads an invoice this returns the bare response object, parsing the result is an exercise for the consumer \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'invoice_id' : invoice_id }) return self . request_get_json ( url = url ) get_appointment ( self , ticketid ) pulls the support tickets associated with the account, returns a list of dicts dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] Source code in aussiebb/__init__.py def get_appointment ( self , ticketid ): \"\"\" pulls the support tickets associated with the account, returns a list of dicts dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'ticketid' : ticketid }) return self . request_get_json ( url = url ) get_customer_details ( self ) grabs the customer details Source code in aussiebb/__init__.py def get_customer_details ( self ): \"\"\" grabs the customer details \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) querystring = { \"v\" : \"2\" } responsedata = self . request_get_json ( url = url , params = querystring , ) return responsedata get_service_tests ( self , service_id ) gets the available tests for a given service ID returns list of dicts [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] this is known to throw 400 errors if you query a VOIP service... Source code in aussiebb/__init__.py def get_service_tests ( self , service_id : int ): \"\"\" gets the available tests for a given service ID returns list of dicts [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] this is known to throw 400 errors if you query a VOIP service... \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) return self . request_get_json ( url = url ) get_services ( self , page = 1 , servicetypes = None ) returns a list of dicts of services associated with the account if you want a specific kind of service, or services, provide a list of matching strings in servicetypes Source code in aussiebb/__init__.py def get_services ( self , page : int = 1 , servicetypes : list = None ): \"\"\" returns a list of dicts of services associated with the account if you want a specific kind of service, or services, provide a list of matching strings in servicetypes \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) querystring = { 'page' : page } responsedata = self . request_get_json ( url = url , params = querystring ) # only filter if we need to if servicetypes and responsedata : logger . debug ( \"Filtering services based on provided list: {} \" , servicetypes ) filtered_responsedata = [] for service in responsedata . get ( 'data' ): if service . get ( 'type' ) in servicetypes : filtered_responsedata . append ( service ) else : logger . debug ( \"Skipping as type== {} - {} \" , service . get ( 'type' ), service ) # return the filtered responses to the source data responsedata [ 'data' ] = filtered_responsedata if responsedata . get ( 'last_page' ) != responsedata . get ( 'current_page' ): logger . debug ( \"You've got a lot of services - please contact the package maintainer to test the multi-page functionality!\" ) #pylint: disable=line-too-long return responsedata . get ( 'data' ) get_test_history ( self , service_id ) gets the available tests for a given service ID returns a list of dicts with tests which have been run Source code in aussiebb/__init__.py def get_test_history ( self , service_id : int ): \"\"\" gets the available tests for a given service ID returns a list of dicts with tests which have been run \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) return self . request_get_json ( url = url ) get_usage ( self , service_id ) returns a json blob of usage for a service Source code in aussiebb/__init__.py def get_usage ( self , service_id : int ): \"\"\" returns a json blob of usage for a service \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) return self . request_get_json ( url = url ) has_token_expired ( self ) returns bool if the token has expired Source code in aussiebb/__init__.py def has_token_expired ( self ): \"\"\" returns bool if the token has expired \"\"\" if time () > self . token_expires : return True return False login ( self ) does the login bit Source code in aussiebb/__init__.py def login ( self ): \"\"\" does the login bit \"\"\" logger . debug ( \"logging in...\" ) url = BASEURL . get ( 'login' ) payload = { 'username' : self . username , 'password' : self . password , } headers = default_headers () response = self . session . post ( url , headers = headers , data = json . dumps ( payload ), ) if response . status_code == 422 : raise AuthenticationException ( response . json ()) if response . status_code == 429 : raise RateLimitException ( response . json ()) response . raise_for_status () jsondata = response . json () self . token_expires = time () + jsondata . get ( 'expiresIn' ) - 50 self . myaussie_cookie = response . cookies . get ( 'myaussie_cookie' ) if self . myaussie_cookie : logger . debug ( f \"Login Cookie: { self . myaussie_cookie } \" ) return True request_get ( self , skip_login_check = False , ** kwargs ) does a GET request and logs in first if need be Source code in aussiebb/__init__.py def request_get ( self , skip_login_check : bool = False , ** kwargs ): \"\"\" does a GET request and logs in first if need be\"\"\" if not skip_login_check : logger . debug ( \"skip_login_check false\" ) if self . has_token_expired (): logger . debug ( \"token has expired, logging in...\" ) self . login () if 'cookies' not in kwargs : kwargs [ 'cookies' ] = { 'myaussie_cookie' : self . myaussie_cookie } response = self . session . get ( ** kwargs ) response . raise_for_status () return response request_get_json ( self , skip_login_check = False , ** kwargs ) does a GET request and logs in first if need be, returns the JSON dict Source code in aussiebb/__init__.py def request_get_json ( self , skip_login_check : bool = False , ** kwargs ): \"\"\" does a GET request and logs in first if need be, returns the JSON dict \"\"\" if not skip_login_check : logger . debug ( \"skip_login_check false\" ) if self . has_token_expired (): logger . debug ( \"token has expired, logging in...\" ) self . login () if 'cookies' not in kwargs : kwargs [ 'cookies' ] = { 'myaussie_cookie' : self . myaussie_cookie } response = self . session . get ( ** kwargs ) response . raise_for_status () return response . json () request_post ( self , skip_login_check = False , ** kwargs ) does a POST request and logs in first if need be Source code in aussiebb/__init__.py def request_post ( self , skip_login_check : bool = False , ** kwargs ): \"\"\" does a POST request and logs in first if need be\"\"\" if not skip_login_check : logger . debug ( \"skip_login_check false\" ) if self . has_token_expired (): logger . debug ( \"token has expired, logging in...\" ) self . login () if 'cookies' not in kwargs : kwargs [ 'cookies' ] = { 'myaussie_cookie' : self . myaussie_cookie } if 'headers' not in kwargs : kwargs [ 'headers' ] = default_headers () response = self . session . post ( ** kwargs ) response . raise_for_status () return response run_test ( self , service_id , test_name , test_method = 'post' ) run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' 'status' of 'Completed' means you've got the full response Source code in aussiebb/__init__.py def run_test ( self , service_id : int , test_name : str , test_method : str = 'post' ): \"\"\" run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis - 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' - 'status' of 'Completed' means you've got the full response \"\"\" test_links = [ test for test in self . get_service_tests ( service_id ) if test . get ( 'link' , '' ) . endswith ( f '/ { test_name } ' )] #pylint: disable=line-too-long if not test_links : return False if len ( test_links ) != 1 : logger . debug ( f \"Too many tests? { test_links } \" ) test_name = test_links [ 0 ] . get ( 'name' ) logger . debug ( f \"Running { test_name } \" ) if test_method == 'get' : return self . request_get_json ( url = test_links [ 0 ] . get ( 'link' )) return self . request_post ( url = test_links [ 0 ] . get ( 'link' )) . json () service_boltons ( self , service_id ) pulls the JSON for addons associated with the service keys: ['id', 'name', 'description', 'costCents', 'additionalNote', 'active'] example data [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] Source code in aussiebb/__init__.py def service_boltons ( self , service_id : int ): \"\"\" pulls the JSON for addons associated with the service keys: ['id', 'name', 'description', 'costCents', 'additionalNote', 'active'] example data ``` [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] ``` \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) return self . request_get_json ( url = url ) service_datablocks ( self , service_id ) pulls the JSON for datablocks associated with the service keys: ['current', 'available'] example data { \"current\": [], \"available\": [] } Source code in aussiebb/__init__.py def service_datablocks ( self , service_id : int ): \"\"\" pulls the JSON for datablocks associated with the service keys: ['current', 'available'] example data ``` { \"current\": [], \"available\": [] } ``` \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) return self . request_get_json ( url = url ) service_outages ( self , service_id ) pulls the JSON for outages keys: ['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages'] Source code in aussiebb/__init__.py def service_outages ( self , service_id : int ): \"\"\" pulls the JSON for outages keys: ['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages'] \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) return self . request_get_json ( url = url ) service_plans ( self , service_id ) pulls the JSON for the plan data keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] Source code in aussiebb/__init__.py def service_plans ( self , service_id : int ): \"\"\" pulls the JSON for the plan data keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) return self . request_get_json ( url = url ) support_tickets ( self ) pulls the support tickets associated with the account, returns a list of dicts dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] Source code in aussiebb/__init__.py def support_tickets ( self ): \"\"\" pulls the support tickets associated with the account, returns a list of dicts dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) return self . request_get_json ( url = url ) telephony_usage ( self , service_id ) pulls the JSON for telephony usage associated with the service keys: ['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical'] example data {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} Source code in aussiebb/__init__.py def telephony_usage ( self , service_id : int ): \"\"\" pulls the JSON for telephony usage associated with the service keys: ['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical'] example data ``` {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} ``` \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) return self . request_get_json ( url = url ) test_line_state ( self , service_id ) tests the line state for a given service ID Source code in aussiebb/__init__.py def test_line_state ( self , service_id : int ): \"\"\" tests the line state for a given service ID \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) logger . debug ( \"Testing line state, can take a few seconds...\" ) response = self . request_post ( url = url ) return response . json () asyncio special aiohttp support for AussieBB AussieBB aiohttp class for interacting with Aussie Broadband APIs __init__ ( self , username , password , session = None , debug = False ) special class for interacting with Aussie Broadband APIs Source code in aussiebb/asyncio/__init__.py def __init__ ( self , username : str , password : str , session : aiohttp . client . ClientSession = None , debug : bool = False ): \"\"\" class for interacting with Aussie Broadband APIs \"\"\" self . username = username self . password = password if not ( username and password ): raise AuthenticationException ( \"You need to supply both username and password\" ) self . made_own_session = False if session is None : self . session = aiohttp . ClientSession () self . made_own_session = True else : self . session = session self . myaussie_cookie = \"\" self . token_expires = - 1 self . debug = debug account_contacts ( self ) async pulls the contacts with the account, returns a list of dicts dict keys: ['id', 'first_name', 'last_name', 'email', 'dog', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact'] Source code in aussiebb/asyncio/__init__.py async def account_contacts ( self ): \"\"\" pulls the contacts with the account, returns a list of dicts dict keys: ['id', 'first_name', 'last_name', 'email', 'dog', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact'] \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata account_paymentplans ( self ) async returns a json blob of payment plans for an account Source code in aussiebb/asyncio/__init__.py async def account_paymentplans ( self ): \"\"\" returns a json blob of payment plans for an account \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) responsedata = await self . request_get_json ( url = url ) return responsedata account_transactions ( self ) async pulls the json for transactions on your account keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] returns a dict where the key is the Month and year of the transaction, eg: ``` \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], Source code in aussiebb/asyncio/__init__.py async def account_transactions ( self ): \"\"\" pulls the json for transactions on your account keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] returns a dict where the key is the Month and year of the transaction, eg: ``` \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) responsedata = await self . request_get_json ( url = url ) return responsedata billing_invoice ( self , invoice_id ) async downloads an invoice this returns the response object Source code in aussiebb/asyncio/__init__.py async def billing_invoice ( self , invoice_id ): \"\"\" downloads an invoice this returns the response object \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'invoice_id' , invoice_id }) responsedata = await self . request_get_json ( url = url ) return responsedata get_customer_details ( self ) async grabs the customer details, returns a dict Source code in aussiebb/asyncio/__init__.py async def get_customer_details ( self ) -> dict : \"\"\" grabs the customer details, returns a dict \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) params = { \"v\" : \"2\" } return await self . request_get_json ( url = url , params = params , ) get_service_tests ( self , service_id ) async gets the available tests for a given service ID returns list of dicts [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] this is known to throw 400 errors if you query a VOIP service... Source code in aussiebb/asyncio/__init__.py async def get_service_tests ( self , service_id : int ): \"\"\" gets the available tests for a given service ID returns list of dicts [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] this is known to throw 400 errors if you query a VOIP service... \"\"\" if self . debug : print ( f \"Getting service tests for { service_id } \" , file = sys . stderr ) frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) responsedata = await self . request_get_json ( url = url ) return responsedata get_services ( self , page = 1 , servicetypes = None ) async returns a list of dicts of services associated with the account if you want a specific kind of service, or services, provide a list of matching strings in servicetypes Source code in aussiebb/asyncio/__init__.py async def get_services ( self , page : int = 1 , servicetypes : list = None ): \"\"\" returns a list of dicts of services associated with the account if you want a specific kind of service, or services, provide a list of matching strings in servicetypes \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) params = { 'page' : page } responsedata = await self . request_get_json ( url = url , params = params ) # only filter if we need to if servicetypes and responsedata : if self . debug : print ( f \"Filtering services based on provided list: { servicetypes } \" , file = sys . stderr ) filtered_responsedata = [] for service in responsedata . get ( 'data' ): if service . get ( 'type' ) in servicetypes : filtered_responsedata . append ( service ) else : if self . debug : print ( f \"Skipping as type== { service . get ( 'type' ) } - { service } \" , file = sys . stderr ) # return the filtered responses to the source data responsedata [ 'data' ] = filtered_responsedata if responsedata . get ( 'last_page' ) != responsedata . get ( 'current_page' ): if self . debug : print ( \"You've got a lot of services - please contact the package maintainer to test the multi-page functionality!\" , file = sys . stderr ) #pylint: disable=line-too-long return responsedata . get ( 'data' ) get_test_history ( self , service_id ) async gets the available tests for a given service ID returns a list of dicts with tests which have been run Source code in aussiebb/asyncio/__init__.py async def get_test_history ( self , service_id : int ): \"\"\" gets the available tests for a given service ID returns a list of dicts with tests which have been run \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) responsedata = await self . request_get_json ( url = url ) return responsedata get_usage ( self , service_id ) async returns a json blob of usage for a service will double-check it's not a telephony service and pull the data for that if it is Source code in aussiebb/asyncio/__init__.py async def get_usage ( self , service_id : int ): \"\"\" returns a json blob of usage for a service will double-check it's not a telephony service and pull the data for that if it is \"\"\" services = await self . get_services () for service in services : if service_id == service . get ( 'service_id' ): if service . get ( 'type' ) in [ 'PhoneMobile' ]: return await self . telephony_usage ( service_id ) frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) responsedata = await self . request_get_json ( url = url ) return responsedata handle_response_fail ( self , response , wait_on_rate_limit = True ) async handles response status codes Source code in aussiebb/asyncio/__init__.py async def handle_response_fail ( self , response , wait_on_rate_limit : bool = True ): \"\"\" handles response status codes \"\"\" ratelimit_remaining = int ( response . headers . get ( 'x-ratelimit-remaining' , - 1 )) if self . debug : print ( f \"Rate limit header: { response . headers . get ( 'x-ratelimit-remaining' , - 1 ) } \" , file = sys . stderr ) if ratelimit_remaining < 5 and wait_on_rate_limit : print ( \"Rate limit below 5, sleeping for 1 second.\" , file = sys . stderr ) await asyncio . sleep ( 1 ) if response . status == 422 : raise AuthenticationException ( await response . json ()) if response . status == 429 : jsondata = await response . json () if self . debug : print ( f \"Dumping headers: { response . headers } \" , file = sys . stderr ) print ( f \"Dumping response: { jsondata } \" , file = sys . stderr ) delay = DEFAULT_BACKOFF_DELAY if 'Please try again in ' in str ( jsondata . get ( 'errors' )): fallback_value = [ f \"default { DEFAULT_BACKOFF_DELAY } seconds\" ] delay = jsondata . get ( 'errors' , {}) . get ( 'username' , fallback_value )[ 0 ] . split ()[ - 2 ] # give it some extra time to cool off delay = int ( delay ) + 5 if 0 < delay < 1000 : if self . debug : print ( f \"Found delay: { delay } \" , file = sys . stderr ) delay = int ( delay ) elif self . debug : print ( f \"Couldn't parse delay, using default: { delay } \" , file = sys . stderr ) else : delay = DEFAULT_BACKOFF_DELAY if self . debug : print ( f \"Couldn't parse delay, using default: { delay } \" , file = sys . stderr ) if wait_on_rate_limit : print ( f \"Rate limit on Aussie API calls raised, sleeping for { delay } seconds.\" , file = sys . stderr ) await asyncio . sleep ( delay ) raise RateLimitException ( jsondata ) response . raise_for_status () has_token_expired ( self ) returns bool if the token has expired Source code in aussiebb/asyncio/__init__.py def has_token_expired ( self ): \"\"\" returns bool if the token has expired \"\"\" if time () > self . token_expires : return True return False login ( self , depth = 0 ) async does the login bit Source code in aussiebb/asyncio/__init__.py async def login ( self , depth = 0 ): \"\"\" does the login bit \"\"\" if depth > 2 : raise RecursiveDepth ( \"Login recursion depth > 2\" ) print ( \"logging in...\" ) url = BASEURL . get ( 'login' ) if not self . has_token_expired (): return True payload = { 'username' : self . username , 'password' : self . password , } headers = default_headers () async with self . session . post ( url = url , headers = headers , json = payload ) as response : try : await self . handle_response_fail ( response ) jsondata = await response . json () except RateLimitException : return await self . login ( depth + 1 ) if self . debug : print ( f \"Login response status: { response . status } \" , file = sys . stderr ) if self . debug : print ( f \"Dumping login response: { json . dumps ( jsondata ) } \" , file = sys . stderr ) self . token_expires = time () + jsondata . get ( 'expiresIn' ) - 50 self . myaussie_cookie = response . cookies . get ( 'myaussie_cookie' ) if self . myaussie_cookie : if self . debug : print ( f \"Login Cookie: { self . myaussie_cookie } \" , file = sys . stderr ) return True request_get ( self , skip_login_check = False , ** kwargs ) async does a GET request and logs in first if need be, returns the body bytes Source code in aussiebb/asyncio/__init__.py async def request_get ( self , skip_login_check : bool = False , ** kwargs ) -> dict : \"\"\" does a GET request and logs in first if need be, returns the body bytes \"\"\" depth = kwargs . get ( 'depth' , 0 ) if depth > 2 : raise RecursiveDepth ( f \"depth: { depth } \" ) if self . session is None : self . session = aiohttp . ClientSession () if not skip_login_check : if self . has_token_expired (): if self . debug : print ( \"token has expired, logging in...\" , file = sys . stderr ) await self . login () if 'cookies' not in kwargs : kwargs [ 'cookies' ] = { 'myaussie_cookie' : self . myaussie_cookie } async with self . session . get ( ** kwargs ) as response : try : await self . handle_response_fail ( response ) await response . read () except RateLimitException : response = await self . request_get_json ( skip_login_check , ** kwargs ) return response request_get_json ( self , skip_login_check = False , ** kwargs ) async does a GET request and logs in first if need be, returns a dict of json Source code in aussiebb/asyncio/__init__.py async def request_get_json ( self , skip_login_check : bool = False , ** kwargs ) -> dict : \"\"\" does a GET request and logs in first if need be, returns a dict of json \"\"\" depth = kwargs . get ( 'depth' , 0 ) if depth > 2 : raise RecursiveDepth ( f \"depth: { depth } \" ) if self . session is None : self . session = aiohttp . ClientSession () if not skip_login_check : if self . debug : print ( \"skip_login_check false\" , file = sys . stderr ) if self . has_token_expired (): if self . debug : print ( \"token has expired, logging in...\" , file = sys . stderr ) await self . login () if 'cookies' not in kwargs : kwargs [ 'cookies' ] = { 'myaussie_cookie' : self . myaussie_cookie } async with self . session . get ( ** kwargs ) as response : try : await self . handle_response_fail ( response ) jsondata = await response . json () except RateLimitException : jsondata = await self . request_get_json ( skip_login_check , ** kwargs ) return jsondata request_post_json ( self , url , ** kwargs ) async does a POST request and logs in first if need be Source code in aussiebb/asyncio/__init__.py async def request_post_json ( self , url , ** kwargs ): \"\"\" does a POST request and logs in first if need be\"\"\" depth = kwargs . get ( 'depth' , 0 ) if depth > 2 : raise RecursiveDepth ( f \"depth: { depth } \" ) if self . session is None : self . session = aiohttp . ClientSession () if not kwargs . get ( 'skip_login_check' , False ): if self . debug : print ( \"skip_login_check false\" , file = sys . stderr ) if self . has_token_expired (): if self . debug : print ( \"token has expired, logging in...\" , file = sys . stderr ) await self . login () #if 'cookies' not in kwargs: # kwargs['cookies'] = {'myaussie_cookie' : self.myaussie_cookie} cookies = kwargs . get ( 'cookies' , { 'myaussie_cookie' : self . myaussie_cookie }) headers = kwargs . get ( 'headers' , default_headers ()) async with self . session . post ( url = url , cookies = cookies , headers = headers ) as response : try : await self . handle_response_fail ( response ) jsondata = await response . json () except RateLimitException : jsondata = await self . request_post_json ( url = url , depth = depth + 1 , ** kwargs ) return jsondata run_test ( self , service_id , test_name , test_method = 'post' ) async run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' 'status' of 'Completed' means you've got the full response Source code in aussiebb/asyncio/__init__.py async def run_test ( self , service_id : int , test_name : str , test_method : str = 'post' ): \"\"\" run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis - 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' - 'status' of 'Completed' means you've got the full response \"\"\" service_tests = await self . get_service_tests ( service_id ) test_links = [ test for test in service_tests if test . get ( 'link' , '' ) . endswith ( f '/ { test_name } ' )] #pylint: disable=line-too-long if not test_links : return False if len ( test_links ) != 1 : if self . debug : print ( f \"Too many tests? { test_links } \" , file = sys . stderr ) test_name = test_links [ 0 ] . get ( 'name' ) if self . debug : print ( f \"Running { test_name } \" , file = sys . stderr ) if test_method == 'get' : result = await self . request_get_json ( url = test_links [ 0 ] . get ( 'link' )) else : result = await self . request_post_json ( url = test_links [ 0 ] . get ( 'link' )) return result service_boltons ( self , service_id ) async pulls the JSON for addons associated with the service keys: ['id', 'name', 'description', 'costCents', 'additionalNote', 'active'] example data [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] Source code in aussiebb/asyncio/__init__.py async def service_boltons ( self , service_id : int ): \"\"\" pulls the JSON for addons associated with the service keys: ['id', 'name', 'description', 'costCents', 'additionalNote', 'active'] example data ``` [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] ``` \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata service_datablocks ( self , service_id ) async pulls the JSON for datablocks associated with the service keys: ['current', 'available'] example data { \"current\": [], \"available\": [] } Source code in aussiebb/asyncio/__init__.py async def service_datablocks ( self , service_id : int ): \"\"\" pulls the JSON for datablocks associated with the service keys: ['current', 'available'] example data ``` { \"current\": [], \"available\": [] } ``` \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata service_outages ( self , service_id ) async pulls the JSON for outages keys: ['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages'] example data { \"networkEvents\": [], \"aussieOutages\": [], \"currentNbnOutages\": [], \"scheduledNbnOutages\": [], \"resolvedScheduledNbnOutages\": [ { \"start_date\": \"2021-08-17T14:00:00Z\", \"end_date\": \"2021-08-17T20:00:00Z\", \"duration\": \"6.0\" } ], \"resolvedNbnOutages\": [] } Source code in aussiebb/asyncio/__init__.py async def service_outages ( self , service_id : int ): \"\"\" pulls the JSON for outages keys: ['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages'] example data ``` { \"networkEvents\": [], \"aussieOutages\": [], \"currentNbnOutages\": [], \"scheduledNbnOutages\": [], \"resolvedScheduledNbnOutages\": [ { \"start_date\": \"2021-08-17T14:00:00Z\", \"end_date\": \"2021-08-17T20:00:00Z\", \"duration\": \"6.0\" } ], \"resolvedNbnOutages\": [] } ``` \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata service_plans ( self , service_id ) async pulls the JSON for the plan data keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] Source code in aussiebb/asyncio/__init__.py async def service_plans ( self , service_id : int ): \"\"\" pulls the JSON for the plan data keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata support_tickets ( self ) async pulls the support tickets associated with the account, returns a list of dicts dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] Source code in aussiebb/asyncio/__init__.py async def support_tickets ( self ): \"\"\" pulls the support tickets associated with the account, returns a list of dicts dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata telephony_usage ( self , service_id ) async pulls the JSON for telephony usage associated with the service keys: ['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical'] example data {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} Source code in aussiebb/asyncio/__init__.py async def telephony_usage ( self , service_id : int ): \"\"\" pulls the JSON for telephony usage associated with the service keys: ['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical'] example data ``` {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} ``` \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata test_line_state ( self , service_id ) async tests the line state for a given service ID Source code in aussiebb/asyncio/__init__.py async def test_line_state ( self , service_id : int ): \"\"\" tests the line state for a given service ID \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) if self . debug : print ( \"Testing line state, can take a few seconds...\" ) response = await self . request_post_json ( url = url ) if self . debug : print ( f \"Response: { response } \" , file = sys . stderr ) return response const constants and utilities default_headers () returns a default set of headers Source code in aussiebb/const.py def default_headers (): \"\"\" returns a default set of headers \"\"\" return { 'Accept' : \"application/json\" , 'Content-Type' : \"application/json\" , 'Origin' : \"https://my.aussiebroadband.com.au\" , 'Referer' : \"https://my.aussiebroadband.com.au/\" , 'cache-control' : \"no-cache\" , } exceptions exceptions for the AussieBB module AuthenticationException authentication error for AussieBB InvalidTestForService user specified an invalid test RateLimitException rate limit error for AussieBB RecursiveDepth you've gone too far down the rabbit hole utils shared utility functions get_url ( function , data = None ) gets the URL based on the data/function Source code in aussiebb/utils.py def get_url ( function : str , data : dict = None ): \"\"\" gets the URL based on the data/function \"\"\" if data : api_endpoint = API_ENDPOINTS . get ( function ) . format ( ** data ) else : api_endpoint = API_ENDPOINTS . get ( function ) return f \" { BASEURL . get ( 'api' ) }{ api_endpoint } \"","title":"aussiebb"},{"location":"aussiebb/#aussiebb.AussieBB","text":"A class for interacting with Aussie Broadband APIs","title":"AussieBB"},{"location":"aussiebb/#aussiebb.AussieBB.__init__","text":"Setup function. Source code in aussiebb/__init__.py def __init__ ( self , username : str , password : str , debug : bool = False ): \"\"\" Setup function. \"\"\" self . username = username self . password = password self . debug = debug if not ( username and password ): raise AuthenticationException ( \"You need to supply both username and password\" ) self . session = requests . Session () self . myaussie_cookie = \"\" self . token_expires = - 1","title":"__init__()"},{"location":"aussiebb/#aussiebb.AussieBB.account_contacts","text":"pulls the contacts with the account, returns a list of dicts dict keys: ['id', 'first_name', 'last_name', 'email', 'dog', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact'] Source code in aussiebb/__init__.py def account_contacts ( self ): \"\"\" pulls the contacts with the account, returns a list of dicts dict keys: ['id', 'first_name', 'last_name', 'email', 'dog', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact'] \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) return self . request_get_json ( url = url )","title":"account_contacts()"},{"location":"aussiebb/#aussiebb.AussieBB.account_paymentplans","text":"returns a json blob of payment plans for an account Source code in aussiebb/__init__.py def account_paymentplans ( self ): \"\"\" returns a json blob of payment plans for an account \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) return self . request_get_json ( url = url )","title":"account_paymentplans()"},{"location":"aussiebb/#aussiebb.AussieBB.account_transactions","text":"pulls the json for transactions on your account keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] returns a dict where the key is the Month and year of the transaction, eg: ``` \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], Source code in aussiebb/__init__.py def account_transactions ( self ): \"\"\" pulls the json for transactions on your account keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] returns a dict where the key is the Month and year of the transaction, eg: ``` \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) return self . request_get_json ( url = url )","title":"account_transactions()"},{"location":"aussiebb/#aussiebb.AussieBB.billing_invoice","text":"downloads an invoice this returns the bare response object, parsing the result is an exercise for the consumer Source code in aussiebb/__init__.py def billing_invoice ( self , invoice_id ): \"\"\" downloads an invoice this returns the bare response object, parsing the result is an exercise for the consumer \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'invoice_id' : invoice_id }) return self . request_get_json ( url = url )","title":"billing_invoice()"},{"location":"aussiebb/#aussiebb.AussieBB.get_appointment","text":"pulls the support tickets associated with the account, returns a list of dicts dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] Source code in aussiebb/__init__.py def get_appointment ( self , ticketid ): \"\"\" pulls the support tickets associated with the account, returns a list of dicts dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'ticketid' : ticketid }) return self . request_get_json ( url = url )","title":"get_appointment()"},{"location":"aussiebb/#aussiebb.AussieBB.get_customer_details","text":"grabs the customer details Source code in aussiebb/__init__.py def get_customer_details ( self ): \"\"\" grabs the customer details \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) querystring = { \"v\" : \"2\" } responsedata = self . request_get_json ( url = url , params = querystring , ) return responsedata","title":"get_customer_details()"},{"location":"aussiebb/#aussiebb.AussieBB.get_service_tests","text":"gets the available tests for a given service ID returns list of dicts [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] this is known to throw 400 errors if you query a VOIP service... Source code in aussiebb/__init__.py def get_service_tests ( self , service_id : int ): \"\"\" gets the available tests for a given service ID returns list of dicts [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] this is known to throw 400 errors if you query a VOIP service... \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) return self . request_get_json ( url = url )","title":"get_service_tests()"},{"location":"aussiebb/#aussiebb.AussieBB.get_services","text":"returns a list of dicts of services associated with the account if you want a specific kind of service, or services, provide a list of matching strings in servicetypes Source code in aussiebb/__init__.py def get_services ( self , page : int = 1 , servicetypes : list = None ): \"\"\" returns a list of dicts of services associated with the account if you want a specific kind of service, or services, provide a list of matching strings in servicetypes \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) querystring = { 'page' : page } responsedata = self . request_get_json ( url = url , params = querystring ) # only filter if we need to if servicetypes and responsedata : logger . debug ( \"Filtering services based on provided list: {} \" , servicetypes ) filtered_responsedata = [] for service in responsedata . get ( 'data' ): if service . get ( 'type' ) in servicetypes : filtered_responsedata . append ( service ) else : logger . debug ( \"Skipping as type== {} - {} \" , service . get ( 'type' ), service ) # return the filtered responses to the source data responsedata [ 'data' ] = filtered_responsedata if responsedata . get ( 'last_page' ) != responsedata . get ( 'current_page' ): logger . debug ( \"You've got a lot of services - please contact the package maintainer to test the multi-page functionality!\" ) #pylint: disable=line-too-long return responsedata . get ( 'data' )","title":"get_services()"},{"location":"aussiebb/#aussiebb.AussieBB.get_test_history","text":"gets the available tests for a given service ID returns a list of dicts with tests which have been run Source code in aussiebb/__init__.py def get_test_history ( self , service_id : int ): \"\"\" gets the available tests for a given service ID returns a list of dicts with tests which have been run \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) return self . request_get_json ( url = url )","title":"get_test_history()"},{"location":"aussiebb/#aussiebb.AussieBB.get_usage","text":"returns a json blob of usage for a service Source code in aussiebb/__init__.py def get_usage ( self , service_id : int ): \"\"\" returns a json blob of usage for a service \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) return self . request_get_json ( url = url )","title":"get_usage()"},{"location":"aussiebb/#aussiebb.AussieBB.has_token_expired","text":"returns bool if the token has expired Source code in aussiebb/__init__.py def has_token_expired ( self ): \"\"\" returns bool if the token has expired \"\"\" if time () > self . token_expires : return True return False","title":"has_token_expired()"},{"location":"aussiebb/#aussiebb.AussieBB.login","text":"does the login bit Source code in aussiebb/__init__.py def login ( self ): \"\"\" does the login bit \"\"\" logger . debug ( \"logging in...\" ) url = BASEURL . get ( 'login' ) payload = { 'username' : self . username , 'password' : self . password , } headers = default_headers () response = self . session . post ( url , headers = headers , data = json . dumps ( payload ), ) if response . status_code == 422 : raise AuthenticationException ( response . json ()) if response . status_code == 429 : raise RateLimitException ( response . json ()) response . raise_for_status () jsondata = response . json () self . token_expires = time () + jsondata . get ( 'expiresIn' ) - 50 self . myaussie_cookie = response . cookies . get ( 'myaussie_cookie' ) if self . myaussie_cookie : logger . debug ( f \"Login Cookie: { self . myaussie_cookie } \" ) return True","title":"login()"},{"location":"aussiebb/#aussiebb.AussieBB.request_get","text":"does a GET request and logs in first if need be Source code in aussiebb/__init__.py def request_get ( self , skip_login_check : bool = False , ** kwargs ): \"\"\" does a GET request and logs in first if need be\"\"\" if not skip_login_check : logger . debug ( \"skip_login_check false\" ) if self . has_token_expired (): logger . debug ( \"token has expired, logging in...\" ) self . login () if 'cookies' not in kwargs : kwargs [ 'cookies' ] = { 'myaussie_cookie' : self . myaussie_cookie } response = self . session . get ( ** kwargs ) response . raise_for_status () return response","title":"request_get()"},{"location":"aussiebb/#aussiebb.AussieBB.request_get_json","text":"does a GET request and logs in first if need be, returns the JSON dict Source code in aussiebb/__init__.py def request_get_json ( self , skip_login_check : bool = False , ** kwargs ): \"\"\" does a GET request and logs in first if need be, returns the JSON dict \"\"\" if not skip_login_check : logger . debug ( \"skip_login_check false\" ) if self . has_token_expired (): logger . debug ( \"token has expired, logging in...\" ) self . login () if 'cookies' not in kwargs : kwargs [ 'cookies' ] = { 'myaussie_cookie' : self . myaussie_cookie } response = self . session . get ( ** kwargs ) response . raise_for_status () return response . json ()","title":"request_get_json()"},{"location":"aussiebb/#aussiebb.AussieBB.request_post","text":"does a POST request and logs in first if need be Source code in aussiebb/__init__.py def request_post ( self , skip_login_check : bool = False , ** kwargs ): \"\"\" does a POST request and logs in first if need be\"\"\" if not skip_login_check : logger . debug ( \"skip_login_check false\" ) if self . has_token_expired (): logger . debug ( \"token has expired, logging in...\" ) self . login () if 'cookies' not in kwargs : kwargs [ 'cookies' ] = { 'myaussie_cookie' : self . myaussie_cookie } if 'headers' not in kwargs : kwargs [ 'headers' ] = default_headers () response = self . session . post ( ** kwargs ) response . raise_for_status () return response","title":"request_post()"},{"location":"aussiebb/#aussiebb.AussieBB.run_test","text":"run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' 'status' of 'Completed' means you've got the full response Source code in aussiebb/__init__.py def run_test ( self , service_id : int , test_name : str , test_method : str = 'post' ): \"\"\" run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis - 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' - 'status' of 'Completed' means you've got the full response \"\"\" test_links = [ test for test in self . get_service_tests ( service_id ) if test . get ( 'link' , '' ) . endswith ( f '/ { test_name } ' )] #pylint: disable=line-too-long if not test_links : return False if len ( test_links ) != 1 : logger . debug ( f \"Too many tests? { test_links } \" ) test_name = test_links [ 0 ] . get ( 'name' ) logger . debug ( f \"Running { test_name } \" ) if test_method == 'get' : return self . request_get_json ( url = test_links [ 0 ] . get ( 'link' )) return self . request_post ( url = test_links [ 0 ] . get ( 'link' )) . json ()","title":"run_test()"},{"location":"aussiebb/#aussiebb.AussieBB.service_boltons","text":"pulls the JSON for addons associated with the service keys: ['id', 'name', 'description', 'costCents', 'additionalNote', 'active'] example data [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] Source code in aussiebb/__init__.py def service_boltons ( self , service_id : int ): \"\"\" pulls the JSON for addons associated with the service keys: ['id', 'name', 'description', 'costCents', 'additionalNote', 'active'] example data ``` [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] ``` \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) return self . request_get_json ( url = url )","title":"service_boltons()"},{"location":"aussiebb/#aussiebb.AussieBB.service_datablocks","text":"pulls the JSON for datablocks associated with the service keys: ['current', 'available'] example data { \"current\": [], \"available\": [] } Source code in aussiebb/__init__.py def service_datablocks ( self , service_id : int ): \"\"\" pulls the JSON for datablocks associated with the service keys: ['current', 'available'] example data ``` { \"current\": [], \"available\": [] } ``` \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) return self . request_get_json ( url = url )","title":"service_datablocks()"},{"location":"aussiebb/#aussiebb.AussieBB.service_outages","text":"pulls the JSON for outages keys: ['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages'] Source code in aussiebb/__init__.py def service_outages ( self , service_id : int ): \"\"\" pulls the JSON for outages keys: ['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages'] \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) return self . request_get_json ( url = url )","title":"service_outages()"},{"location":"aussiebb/#aussiebb.AussieBB.service_plans","text":"pulls the JSON for the plan data keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] Source code in aussiebb/__init__.py def service_plans ( self , service_id : int ): \"\"\" pulls the JSON for the plan data keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) return self . request_get_json ( url = url )","title":"service_plans()"},{"location":"aussiebb/#aussiebb.AussieBB.support_tickets","text":"pulls the support tickets associated with the account, returns a list of dicts dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] Source code in aussiebb/__init__.py def support_tickets ( self ): \"\"\" pulls the support tickets associated with the account, returns a list of dicts dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) return self . request_get_json ( url = url )","title":"support_tickets()"},{"location":"aussiebb/#aussiebb.AussieBB.telephony_usage","text":"pulls the JSON for telephony usage associated with the service keys: ['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical'] example data {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} Source code in aussiebb/__init__.py def telephony_usage ( self , service_id : int ): \"\"\" pulls the JSON for telephony usage associated with the service keys: ['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical'] example data ``` {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} ``` \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) return self . request_get_json ( url = url )","title":"telephony_usage()"},{"location":"aussiebb/#aussiebb.AussieBB.test_line_state","text":"tests the line state for a given service ID Source code in aussiebb/__init__.py def test_line_state ( self , service_id : int ): \"\"\" tests the line state for a given service ID \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) logger . debug ( \"Testing line state, can take a few seconds...\" ) response = self . request_post ( url = url ) return response . json ()","title":"test_line_state()"},{"location":"aussiebb/#aussiebb.asyncio","text":"aiohttp support for AussieBB","title":"asyncio"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB","text":"aiohttp class for interacting with Aussie Broadband APIs","title":"AussieBB"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.__init__","text":"class for interacting with Aussie Broadband APIs Source code in aussiebb/asyncio/__init__.py def __init__ ( self , username : str , password : str , session : aiohttp . client . ClientSession = None , debug : bool = False ): \"\"\" class for interacting with Aussie Broadband APIs \"\"\" self . username = username self . password = password if not ( username and password ): raise AuthenticationException ( \"You need to supply both username and password\" ) self . made_own_session = False if session is None : self . session = aiohttp . ClientSession () self . made_own_session = True else : self . session = session self . myaussie_cookie = \"\" self . token_expires = - 1 self . debug = debug","title":"__init__()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.account_contacts","text":"pulls the contacts with the account, returns a list of dicts dict keys: ['id', 'first_name', 'last_name', 'email', 'dog', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact'] Source code in aussiebb/asyncio/__init__.py async def account_contacts ( self ): \"\"\" pulls the contacts with the account, returns a list of dicts dict keys: ['id', 'first_name', 'last_name', 'email', 'dog', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact'] \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata","title":"account_contacts()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.account_paymentplans","text":"returns a json blob of payment plans for an account Source code in aussiebb/asyncio/__init__.py async def account_paymentplans ( self ): \"\"\" returns a json blob of payment plans for an account \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) responsedata = await self . request_get_json ( url = url ) return responsedata","title":"account_paymentplans()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.account_transactions","text":"pulls the json for transactions on your account keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] returns a dict where the key is the Month and year of the transaction, eg: ``` \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], Source code in aussiebb/asyncio/__init__.py async def account_transactions ( self ): \"\"\" pulls the json for transactions on your account keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] returns a dict where the key is the Month and year of the transaction, eg: ``` \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) responsedata = await self . request_get_json ( url = url ) return responsedata","title":"account_transactions()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.billing_invoice","text":"downloads an invoice this returns the response object Source code in aussiebb/asyncio/__init__.py async def billing_invoice ( self , invoice_id ): \"\"\" downloads an invoice this returns the response object \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'invoice_id' , invoice_id }) responsedata = await self . request_get_json ( url = url ) return responsedata","title":"billing_invoice()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.get_customer_details","text":"grabs the customer details, returns a dict Source code in aussiebb/asyncio/__init__.py async def get_customer_details ( self ) -> dict : \"\"\" grabs the customer details, returns a dict \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) params = { \"v\" : \"2\" } return await self . request_get_json ( url = url , params = params , )","title":"get_customer_details()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.get_service_tests","text":"gets the available tests for a given service ID returns list of dicts [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] this is known to throw 400 errors if you query a VOIP service... Source code in aussiebb/asyncio/__init__.py async def get_service_tests ( self , service_id : int ): \"\"\" gets the available tests for a given service ID returns list of dicts [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] this is known to throw 400 errors if you query a VOIP service... \"\"\" if self . debug : print ( f \"Getting service tests for { service_id } \" , file = sys . stderr ) frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) responsedata = await self . request_get_json ( url = url ) return responsedata","title":"get_service_tests()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.get_services","text":"returns a list of dicts of services associated with the account if you want a specific kind of service, or services, provide a list of matching strings in servicetypes Source code in aussiebb/asyncio/__init__.py async def get_services ( self , page : int = 1 , servicetypes : list = None ): \"\"\" returns a list of dicts of services associated with the account if you want a specific kind of service, or services, provide a list of matching strings in servicetypes \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) params = { 'page' : page } responsedata = await self . request_get_json ( url = url , params = params ) # only filter if we need to if servicetypes and responsedata : if self . debug : print ( f \"Filtering services based on provided list: { servicetypes } \" , file = sys . stderr ) filtered_responsedata = [] for service in responsedata . get ( 'data' ): if service . get ( 'type' ) in servicetypes : filtered_responsedata . append ( service ) else : if self . debug : print ( f \"Skipping as type== { service . get ( 'type' ) } - { service } \" , file = sys . stderr ) # return the filtered responses to the source data responsedata [ 'data' ] = filtered_responsedata if responsedata . get ( 'last_page' ) != responsedata . get ( 'current_page' ): if self . debug : print ( \"You've got a lot of services - please contact the package maintainer to test the multi-page functionality!\" , file = sys . stderr ) #pylint: disable=line-too-long return responsedata . get ( 'data' )","title":"get_services()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.get_test_history","text":"gets the available tests for a given service ID returns a list of dicts with tests which have been run Source code in aussiebb/asyncio/__init__.py async def get_test_history ( self , service_id : int ): \"\"\" gets the available tests for a given service ID returns a list of dicts with tests which have been run \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) responsedata = await self . request_get_json ( url = url ) return responsedata","title":"get_test_history()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.get_usage","text":"returns a json blob of usage for a service will double-check it's not a telephony service and pull the data for that if it is Source code in aussiebb/asyncio/__init__.py async def get_usage ( self , service_id : int ): \"\"\" returns a json blob of usage for a service will double-check it's not a telephony service and pull the data for that if it is \"\"\" services = await self . get_services () for service in services : if service_id == service . get ( 'service_id' ): if service . get ( 'type' ) in [ 'PhoneMobile' ]: return await self . telephony_usage ( service_id ) frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) responsedata = await self . request_get_json ( url = url ) return responsedata","title":"get_usage()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.handle_response_fail","text":"handles response status codes Source code in aussiebb/asyncio/__init__.py async def handle_response_fail ( self , response , wait_on_rate_limit : bool = True ): \"\"\" handles response status codes \"\"\" ratelimit_remaining = int ( response . headers . get ( 'x-ratelimit-remaining' , - 1 )) if self . debug : print ( f \"Rate limit header: { response . headers . get ( 'x-ratelimit-remaining' , - 1 ) } \" , file = sys . stderr ) if ratelimit_remaining < 5 and wait_on_rate_limit : print ( \"Rate limit below 5, sleeping for 1 second.\" , file = sys . stderr ) await asyncio . sleep ( 1 ) if response . status == 422 : raise AuthenticationException ( await response . json ()) if response . status == 429 : jsondata = await response . json () if self . debug : print ( f \"Dumping headers: { response . headers } \" , file = sys . stderr ) print ( f \"Dumping response: { jsondata } \" , file = sys . stderr ) delay = DEFAULT_BACKOFF_DELAY if 'Please try again in ' in str ( jsondata . get ( 'errors' )): fallback_value = [ f \"default { DEFAULT_BACKOFF_DELAY } seconds\" ] delay = jsondata . get ( 'errors' , {}) . get ( 'username' , fallback_value )[ 0 ] . split ()[ - 2 ] # give it some extra time to cool off delay = int ( delay ) + 5 if 0 < delay < 1000 : if self . debug : print ( f \"Found delay: { delay } \" , file = sys . stderr ) delay = int ( delay ) elif self . debug : print ( f \"Couldn't parse delay, using default: { delay } \" , file = sys . stderr ) else : delay = DEFAULT_BACKOFF_DELAY if self . debug : print ( f \"Couldn't parse delay, using default: { delay } \" , file = sys . stderr ) if wait_on_rate_limit : print ( f \"Rate limit on Aussie API calls raised, sleeping for { delay } seconds.\" , file = sys . stderr ) await asyncio . sleep ( delay ) raise RateLimitException ( jsondata ) response . raise_for_status ()","title":"handle_response_fail()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.has_token_expired","text":"returns bool if the token has expired Source code in aussiebb/asyncio/__init__.py def has_token_expired ( self ): \"\"\" returns bool if the token has expired \"\"\" if time () > self . token_expires : return True return False","title":"has_token_expired()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.login","text":"does the login bit Source code in aussiebb/asyncio/__init__.py async def login ( self , depth = 0 ): \"\"\" does the login bit \"\"\" if depth > 2 : raise RecursiveDepth ( \"Login recursion depth > 2\" ) print ( \"logging in...\" ) url = BASEURL . get ( 'login' ) if not self . has_token_expired (): return True payload = { 'username' : self . username , 'password' : self . password , } headers = default_headers () async with self . session . post ( url = url , headers = headers , json = payload ) as response : try : await self . handle_response_fail ( response ) jsondata = await response . json () except RateLimitException : return await self . login ( depth + 1 ) if self . debug : print ( f \"Login response status: { response . status } \" , file = sys . stderr ) if self . debug : print ( f \"Dumping login response: { json . dumps ( jsondata ) } \" , file = sys . stderr ) self . token_expires = time () + jsondata . get ( 'expiresIn' ) - 50 self . myaussie_cookie = response . cookies . get ( 'myaussie_cookie' ) if self . myaussie_cookie : if self . debug : print ( f \"Login Cookie: { self . myaussie_cookie } \" , file = sys . stderr ) return True","title":"login()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.request_get","text":"does a GET request and logs in first if need be, returns the body bytes Source code in aussiebb/asyncio/__init__.py async def request_get ( self , skip_login_check : bool = False , ** kwargs ) -> dict : \"\"\" does a GET request and logs in first if need be, returns the body bytes \"\"\" depth = kwargs . get ( 'depth' , 0 ) if depth > 2 : raise RecursiveDepth ( f \"depth: { depth } \" ) if self . session is None : self . session = aiohttp . ClientSession () if not skip_login_check : if self . has_token_expired (): if self . debug : print ( \"token has expired, logging in...\" , file = sys . stderr ) await self . login () if 'cookies' not in kwargs : kwargs [ 'cookies' ] = { 'myaussie_cookie' : self . myaussie_cookie } async with self . session . get ( ** kwargs ) as response : try : await self . handle_response_fail ( response ) await response . read () except RateLimitException : response = await self . request_get_json ( skip_login_check , ** kwargs ) return response","title":"request_get()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.request_get_json","text":"does a GET request and logs in first if need be, returns a dict of json Source code in aussiebb/asyncio/__init__.py async def request_get_json ( self , skip_login_check : bool = False , ** kwargs ) -> dict : \"\"\" does a GET request and logs in first if need be, returns a dict of json \"\"\" depth = kwargs . get ( 'depth' , 0 ) if depth > 2 : raise RecursiveDepth ( f \"depth: { depth } \" ) if self . session is None : self . session = aiohttp . ClientSession () if not skip_login_check : if self . debug : print ( \"skip_login_check false\" , file = sys . stderr ) if self . has_token_expired (): if self . debug : print ( \"token has expired, logging in...\" , file = sys . stderr ) await self . login () if 'cookies' not in kwargs : kwargs [ 'cookies' ] = { 'myaussie_cookie' : self . myaussie_cookie } async with self . session . get ( ** kwargs ) as response : try : await self . handle_response_fail ( response ) jsondata = await response . json () except RateLimitException : jsondata = await self . request_get_json ( skip_login_check , ** kwargs ) return jsondata","title":"request_get_json()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.request_post_json","text":"does a POST request and logs in first if need be Source code in aussiebb/asyncio/__init__.py async def request_post_json ( self , url , ** kwargs ): \"\"\" does a POST request and logs in first if need be\"\"\" depth = kwargs . get ( 'depth' , 0 ) if depth > 2 : raise RecursiveDepth ( f \"depth: { depth } \" ) if self . session is None : self . session = aiohttp . ClientSession () if not kwargs . get ( 'skip_login_check' , False ): if self . debug : print ( \"skip_login_check false\" , file = sys . stderr ) if self . has_token_expired (): if self . debug : print ( \"token has expired, logging in...\" , file = sys . stderr ) await self . login () #if 'cookies' not in kwargs: # kwargs['cookies'] = {'myaussie_cookie' : self.myaussie_cookie} cookies = kwargs . get ( 'cookies' , { 'myaussie_cookie' : self . myaussie_cookie }) headers = kwargs . get ( 'headers' , default_headers ()) async with self . session . post ( url = url , cookies = cookies , headers = headers ) as response : try : await self . handle_response_fail ( response ) jsondata = await response . json () except RateLimitException : jsondata = await self . request_post_json ( url = url , depth = depth + 1 , ** kwargs ) return jsondata","title":"request_post_json()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.run_test","text":"run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' 'status' of 'Completed' means you've got the full response Source code in aussiebb/asyncio/__init__.py async def run_test ( self , service_id : int , test_name : str , test_method : str = 'post' ): \"\"\" run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis - 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' - 'status' of 'Completed' means you've got the full response \"\"\" service_tests = await self . get_service_tests ( service_id ) test_links = [ test for test in service_tests if test . get ( 'link' , '' ) . endswith ( f '/ { test_name } ' )] #pylint: disable=line-too-long if not test_links : return False if len ( test_links ) != 1 : if self . debug : print ( f \"Too many tests? { test_links } \" , file = sys . stderr ) test_name = test_links [ 0 ] . get ( 'name' ) if self . debug : print ( f \"Running { test_name } \" , file = sys . stderr ) if test_method == 'get' : result = await self . request_get_json ( url = test_links [ 0 ] . get ( 'link' )) else : result = await self . request_post_json ( url = test_links [ 0 ] . get ( 'link' )) return result","title":"run_test()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.service_boltons","text":"pulls the JSON for addons associated with the service keys: ['id', 'name', 'description', 'costCents', 'additionalNote', 'active'] example data [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] Source code in aussiebb/asyncio/__init__.py async def service_boltons ( self , service_id : int ): \"\"\" pulls the JSON for addons associated with the service keys: ['id', 'name', 'description', 'costCents', 'additionalNote', 'active'] example data ``` [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] ``` \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata","title":"service_boltons()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.service_datablocks","text":"pulls the JSON for datablocks associated with the service keys: ['current', 'available'] example data { \"current\": [], \"available\": [] } Source code in aussiebb/asyncio/__init__.py async def service_datablocks ( self , service_id : int ): \"\"\" pulls the JSON for datablocks associated with the service keys: ['current', 'available'] example data ``` { \"current\": [], \"available\": [] } ``` \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata","title":"service_datablocks()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.service_outages","text":"pulls the JSON for outages keys: ['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages'] example data { \"networkEvents\": [], \"aussieOutages\": [], \"currentNbnOutages\": [], \"scheduledNbnOutages\": [], \"resolvedScheduledNbnOutages\": [ { \"start_date\": \"2021-08-17T14:00:00Z\", \"end_date\": \"2021-08-17T20:00:00Z\", \"duration\": \"6.0\" } ], \"resolvedNbnOutages\": [] } Source code in aussiebb/asyncio/__init__.py async def service_outages ( self , service_id : int ): \"\"\" pulls the JSON for outages keys: ['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages'] example data ``` { \"networkEvents\": [], \"aussieOutages\": [], \"currentNbnOutages\": [], \"scheduledNbnOutages\": [], \"resolvedScheduledNbnOutages\": [ { \"start_date\": \"2021-08-17T14:00:00Z\", \"end_date\": \"2021-08-17T20:00:00Z\", \"duration\": \"6.0\" } ], \"resolvedNbnOutages\": [] } ``` \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata","title":"service_outages()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.service_plans","text":"pulls the JSON for the plan data keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] Source code in aussiebb/asyncio/__init__.py async def service_plans ( self , service_id : int ): \"\"\" pulls the JSON for the plan data keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata","title":"service_plans()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.support_tickets","text":"pulls the support tickets associated with the account, returns a list of dicts dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] Source code in aussiebb/asyncio/__init__.py async def support_tickets ( self ): \"\"\" pulls the support tickets associated with the account, returns a list of dicts dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function ) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata","title":"support_tickets()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.telephony_usage","text":"pulls the JSON for telephony usage associated with the service keys: ['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical'] example data {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} Source code in aussiebb/asyncio/__init__.py async def telephony_usage ( self , service_id : int ): \"\"\" pulls the JSON for telephony usage associated with the service keys: ['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical'] example data ``` {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} ``` \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata","title":"telephony_usage()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.test_line_state","text":"tests the line state for a given service ID Source code in aussiebb/asyncio/__init__.py async def test_line_state ( self , service_id : int ): \"\"\" tests the line state for a given service ID \"\"\" frame = inspect . currentframe () url = get_url ( inspect . getframeinfo ( frame ) . function , { 'service_id' : service_id }) if self . debug : print ( \"Testing line state, can take a few seconds...\" ) response = await self . request_post_json ( url = url ) if self . debug : print ( f \"Response: { response } \" , file = sys . stderr ) return response","title":"test_line_state()"},{"location":"aussiebb/#aussiebb.const","text":"constants and utilities","title":"const"},{"location":"aussiebb/#aussiebb.const.default_headers","text":"returns a default set of headers Source code in aussiebb/const.py def default_headers (): \"\"\" returns a default set of headers \"\"\" return { 'Accept' : \"application/json\" , 'Content-Type' : \"application/json\" , 'Origin' : \"https://my.aussiebroadband.com.au\" , 'Referer' : \"https://my.aussiebroadband.com.au/\" , 'cache-control' : \"no-cache\" , }","title":"default_headers()"},{"location":"aussiebb/#aussiebb.exceptions","text":"exceptions for the AussieBB module","title":"exceptions"},{"location":"aussiebb/#aussiebb.exceptions.AuthenticationException","text":"authentication error for AussieBB","title":"AuthenticationException"},{"location":"aussiebb/#aussiebb.exceptions.InvalidTestForService","text":"user specified an invalid test","title":"InvalidTestForService"},{"location":"aussiebb/#aussiebb.exceptions.RateLimitException","text":"rate limit error for AussieBB","title":"RateLimitException"},{"location":"aussiebb/#aussiebb.exceptions.RecursiveDepth","text":"you've gone too far down the rabbit hole","title":"RecursiveDepth"},{"location":"aussiebb/#aussiebb.utils","text":"shared utility functions","title":"utils"},{"location":"aussiebb/#aussiebb.utils.get_url","text":"gets the URL based on the data/function Source code in aussiebb/utils.py def get_url ( function : str , data : dict = None ): \"\"\" gets the URL based on the data/function \"\"\" if data : api_endpoint = API_ENDPOINTS . get ( function ) . format ( ** data ) else : api_endpoint = API_ENDPOINTS . get ( function ) return f \" { BASEURL . get ( 'api' ) }{ api_endpoint } \"","title":"get_url()"}]}
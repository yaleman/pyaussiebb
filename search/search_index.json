{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pyAussieBB This is a very simple module for interacting with the Aussie Broadband APIs. Usage pip install --user pyaussiebb python >>> from aussiebb import AussieBB >>> account = AussieBB(username, password) >>> account.get_services() [{allyourservicedetails}] For more, check out the docs. AsyncIO version You can replace from aussiebb import AussieBB with from aussiebb.asyncio import AussieBB and you'll get an aiohttp -powered version. The only difference in this case is that you have to explicitly call login() for reasons. If you hit the rate limit it'll raise a RateLimit exception. I haven't put that functionality into the blocking version yet, since ... that tends not to hit it. \ud83e\udd23 Development Example service tests I've seen All the \"endpoints\" below should be tacked onto aussiebb.const.BASEURL['api'] . Warning: /nbn/{service_id}/connection seems to have both a GET and POST method endpoint - tests on other endpoints may be similar. These can be run by using AussieBB.run_test() with the string after the last forward-slash as the \"test\" - ie, connection or linestate . HFC These are entirely untested so far. Endpoint Method Name Description /nbn/{service_id}/connection Probably GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/loopback Probably POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/ntdstatus Probably POST NTD Status An NTD Status will show you the operational state of the Network Termination Device (NTD). The test will also show if the NTD is detecting the wired connection from your router. FTTC Endpoint Method Name Description /nbn/{service_id}/connection GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/dpuportreset Probably POST DPU Port Reset Reset the Port on the DPU (Distribution Point Unit) along with clearing any errors that maybe causing issues with connectivity. /tests/{service_id}/dpuportstatus POST DPU Port Status A DPU (Distribution Point Unit) port status will show if the NCD (Network Connection Device) is providing power to the DPU. It will also state if the NCD (Network Connection Device) is in sync. /tests/{service_id}/dpustatus POST DPU Status This will provide if the DPU (Distribution Point Unit) is currently being powered. /tests/{service_id}/loopback POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/ncdportreset Probably POST NCD Port Reset Reset the gateway port on your NCD (Network Connection Device). /tests/{service_id}/ncdreset Probably POST NCD Reset This will remotely restart your Network Termination Device. FTTN Endpoint Method Name Description /nbn/{service_id}/connection GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/linestate POST Line State A line state test will determine if you have \u201csync\u201d (connection) to the node. If the service is in sync this test will also return your maximum and current attainable transfer rate. /tests/{service_id}/loopback POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/portreset Probably POST Port Reset This will reset the connection from the Node and also clear errors that may be causing issues with gaining sync. /tests/{service_id}/stabilityprofile Probably POST Stability Profile This will apply changes to your FTTN service including allowing increased noise to occur before making the connection unstable. This will cause your speeds to degrade as a result, but in turn making the service more stable. For NBN to investigate a fault this profile needs to be applied and a minimum of 5 dropouts recorded over a 24hr period on NBN's systems before a dropout fault can be raised FTTP These are as-yet untested. Endpoint Method Name Description /nbn/{service_id}/connection Probably GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/loopback Probably POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/portreset Probably POST Port Reset This will reset the connection from the Node and also clear errors that may be causing issues with gaining sync. /tests/{service_id}/unidstatus Probably POST UNI-D Status UNI-D Status will show if the UNI-D port you are currently using has a router connected to it. This will also provide the Link speed your router and UNI-D port are connected at Eg, 100mbit or 1gbit. You will also see the MAC address of the currently connected router. Changelog See CHANGELOG.md","title":"Home"},{"location":"#pyaussiebb","text":"This is a very simple module for interacting with the Aussie Broadband APIs.","title":"pyAussieBB"},{"location":"#usage","text":"pip install --user pyaussiebb python >>> from aussiebb import AussieBB >>> account = AussieBB(username, password) >>> account.get_services() [{allyourservicedetails}] For more, check out the docs.","title":"Usage"},{"location":"#asyncio-version","text":"You can replace from aussiebb import AussieBB with from aussiebb.asyncio import AussieBB and you'll get an aiohttp -powered version. The only difference in this case is that you have to explicitly call login() for reasons. If you hit the rate limit it'll raise a RateLimit exception. I haven't put that functionality into the blocking version yet, since ... that tends not to hit it. \ud83e\udd23","title":"AsyncIO version"},{"location":"#development","text":"","title":"Development"},{"location":"#example-service-tests-ive-seen","text":"All the \"endpoints\" below should be tacked onto aussiebb.const.BASEURL['api'] . Warning: /nbn/{service_id}/connection seems to have both a GET and POST method endpoint - tests on other endpoints may be similar. These can be run by using AussieBB.run_test() with the string after the last forward-slash as the \"test\" - ie, connection or linestate .","title":"Example service tests I've seen"},{"location":"#hfc","text":"These are entirely untested so far. Endpoint Method Name Description /nbn/{service_id}/connection Probably GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/loopback Probably POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/ntdstatus Probably POST NTD Status An NTD Status will show you the operational state of the Network Termination Device (NTD). The test will also show if the NTD is detecting the wired connection from your router.","title":"HFC"},{"location":"#fttc","text":"Endpoint Method Name Description /nbn/{service_id}/connection GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/dpuportreset Probably POST DPU Port Reset Reset the Port on the DPU (Distribution Point Unit) along with clearing any errors that maybe causing issues with connectivity. /tests/{service_id}/dpuportstatus POST DPU Port Status A DPU (Distribution Point Unit) port status will show if the NCD (Network Connection Device) is providing power to the DPU. It will also state if the NCD (Network Connection Device) is in sync. /tests/{service_id}/dpustatus POST DPU Status This will provide if the DPU (Distribution Point Unit) is currently being powered. /tests/{service_id}/loopback POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/ncdportreset Probably POST NCD Port Reset Reset the gateway port on your NCD (Network Connection Device). /tests/{service_id}/ncdreset Probably POST NCD Reset This will remotely restart your Network Termination Device.","title":"FTTC"},{"location":"#fttn","text":"Endpoint Method Name Description /nbn/{service_id}/connection GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/linestate POST Line State A line state test will determine if you have \u201csync\u201d (connection) to the node. If the service is in sync this test will also return your maximum and current attainable transfer rate. /tests/{service_id}/loopback POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/portreset Probably POST Port Reset This will reset the connection from the Node and also clear errors that may be causing issues with gaining sync. /tests/{service_id}/stabilityprofile Probably POST Stability Profile This will apply changes to your FTTN service including allowing increased noise to occur before making the connection unstable. This will cause your speeds to degrade as a result, but in turn making the service more stable. For NBN to investigate a fault this profile needs to be applied and a minimum of 5 dropouts recorded over a 24hr period on NBN's systems before a dropout fault can be raised","title":"FTTN"},{"location":"#fttp","text":"These are as-yet untested. Endpoint Method Name Description /nbn/{service_id}/connection Probably GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/loopback Probably POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/portreset Probably POST Port Reset This will reset the connection from the Node and also clear errors that may be causing issues with gaining sync. /tests/{service_id}/unidstatus Probably POST UNI-D Status UNI-D Status will show if the UNI-D port you are currently using has a router connected to it. This will also provide the Link speed your router and UNI-D port are connected at Eg, 100mbit or 1gbit. You will also see the MAC address of the currently connected router.","title":"FTTP"},{"location":"#changelog","text":"See CHANGELOG.md","title":"Changelog"},{"location":"CHANGELOG/","text":"CHANGELOG v0.0.15 Moved the pydantic dependency from dev to main, which shouldn't ever have been in dev... v0.0.14 Moved the filtering by servicetypes in get_services() to its own function Added a new service type \"Fetchtv\" Added a way to drop types of services in get_services() so Home Assistant can ignore FETCH_TYPES Added some handling for FETCHTV types. v0.0.13 Added service type of FETCHTV to NBN_TYPES Fixed test for this handler. Updated logging for error when it happens. Turns out this was the wrong way to handle it, so this version got yanked. v0.0.12 Added pydantic as a dependency, which allows for better type checking. Rewrote a bunch of the tests because the bike shed needed to be green and driven by JSON. Added first run of handling for folks with more than 10 services - paginated calls Some things will return nicer pydantic-ish objects, typing is starting to be enforced on output account_contacts is one, for example Added service type of Opticomm to NBN_TYPES v0.0.11 Added aussiebb.exceptions.UnrecognisedServiceType and some quick validation when you run get_usage so it doesn't break. Added some more testing around this. Fixed it so you can pass a session object to the non-asyncio AussieBB Added \"use_cached\" to get_services calls Added some mock data in aussiebb.const.TEST_MOCKDATA v0.0.10 Major change: Minimum supported Python is now 3.9 re-defined the API Classes as children of a base class (aussiebb.baseclass.BaseClass). added significantly better typing to inputs/responses. removed all the usage of inspect . moved from setup.py to Poetry for build/packaging. removed loguru dependency, class init now takes a logger as an option or uses python default logging if not. Also removed _debug_print from async version. added NBN_TYPES and PHONE_TYPES to aussiebb.const, to allow one to check if the service matches a known identifier for \"phone\" (mobile/VOIP) or \"NBN\" (internet) types - this matters when parsing the resulting service info. added test and fixed result of the asyncio get_service_tests function v0.0.8 renamed serviceid to service_id to match the api added request_get_json to the sync class added telephony_usage added get_appointment which gets service appointments updated get_usage so it checks the service list and will return telephony data if it's a PhoneMobile service abstracted how URLS are generated so I don't have to keep adding them twice added a filter on get_services which allows you to filter by type 0.0.7 Added the following new functions: account_transactions , billing_invoice , service_outages , service_boltons , service_datablocks , support_tickets , account contacts . Renamed get_service_plans to service_plans v0.0.6 Fixed rate limiting v0.0.5 Fixing rate limiting Didn't actually fix it... 0.0.4 Added asyncio submodule, split constants and exceptions out into their own files/modules. 0.0.3 Added get_service_plans so the gigabit-desperate crowd can check for their new hotness.","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"CHANGELOG"},{"location":"CHANGELOG/#v0015","text":"Moved the pydantic dependency from dev to main, which shouldn't ever have been in dev...","title":"v0.0.15"},{"location":"CHANGELOG/#v0014","text":"Moved the filtering by servicetypes in get_services() to its own function Added a new service type \"Fetchtv\" Added a way to drop types of services in get_services() so Home Assistant can ignore FETCH_TYPES Added some handling for FETCHTV types.","title":"v0.0.14"},{"location":"CHANGELOG/#v0013","text":"Added service type of FETCHTV to NBN_TYPES Fixed test for this handler. Updated logging for error when it happens. Turns out this was the wrong way to handle it, so this version got yanked.","title":"v0.0.13"},{"location":"CHANGELOG/#v0012","text":"Added pydantic as a dependency, which allows for better type checking. Rewrote a bunch of the tests because the bike shed needed to be green and driven by JSON. Added first run of handling for folks with more than 10 services - paginated calls Some things will return nicer pydantic-ish objects, typing is starting to be enforced on output account_contacts is one, for example Added service type of Opticomm to NBN_TYPES","title":"v0.0.12"},{"location":"CHANGELOG/#v0011","text":"Added aussiebb.exceptions.UnrecognisedServiceType and some quick validation when you run get_usage so it doesn't break. Added some more testing around this. Fixed it so you can pass a session object to the non-asyncio AussieBB Added \"use_cached\" to get_services calls Added some mock data in aussiebb.const.TEST_MOCKDATA","title":"v0.0.11"},{"location":"CHANGELOG/#v0010","text":"","title":"v0.0.10"},{"location":"CHANGELOG/#major-change-minimum-supported-python-is-now-39","text":"re-defined the API Classes as children of a base class (aussiebb.baseclass.BaseClass). added significantly better typing to inputs/responses. removed all the usage of inspect . moved from setup.py to Poetry for build/packaging. removed loguru dependency, class init now takes a logger as an option or uses python default logging if not. Also removed _debug_print from async version. added NBN_TYPES and PHONE_TYPES to aussiebb.const, to allow one to check if the service matches a known identifier for \"phone\" (mobile/VOIP) or \"NBN\" (internet) types - this matters when parsing the resulting service info. added test and fixed result of the asyncio get_service_tests function","title":"Major change: Minimum supported Python is now 3.9"},{"location":"CHANGELOG/#v008","text":"renamed serviceid to service_id to match the api added request_get_json to the sync class added telephony_usage added get_appointment which gets service appointments updated get_usage so it checks the service list and will return telephony data if it's a PhoneMobile service abstracted how URLS are generated so I don't have to keep adding them twice added a filter on get_services which allows you to filter by type","title":"v0.0.8"},{"location":"CHANGELOG/#007","text":"Added the following new functions: account_transactions , billing_invoice , service_outages , service_boltons , service_datablocks , support_tickets , account contacts . Renamed get_service_plans to service_plans","title":"0.0.7"},{"location":"CHANGELOG/#v006","text":"Fixed rate limiting","title":"v0.0.6"},{"location":"CHANGELOG/#v005","text":"Fixing rate limiting Didn't actually fix it...","title":"v0.0.5"},{"location":"CHANGELOG/#004","text":"Added asyncio submodule, split constants and exceptions out into their own files/modules.","title":"0.0.4"},{"location":"CHANGELOG/#003","text":"Added get_service_plans so the gigabit-desperate crowd can check for their new hotness.","title":"0.0.3"},{"location":"aussiebb/","text":"A class for interacting with Aussie Broadband APIs AussieBB Bases: BaseClass A class for interacting with Aussie Broadband APIs Source code in aussiebb/__init__.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 class AussieBB ( BaseClass ): \"\"\"A class for interacting with Aussie Broadband APIs\"\"\" def __init__ ( self , username : str , password : str , debug : bool = False , services_cache_time : int = 28800 , session : Optional [ requests . sessions . Session ] = None , ): \"\"\"Setup function ``` @param username: str - username for Aussie Broadband account @param password: str - password for Aussie Broadband account @param debug: bool - debug mode @param services_cache_time: int - seconds between caching get_services() - defaults to 8 hours @param session : requests.session - session object ``` \"\"\" super () . __init__ ( username , password , debug , services_cache_time ) if session is None : self . session = requests . Session () else : self . session = session def login ( self , depth : int = 0 ) -> bool : \"\"\"Logs into the account and caches the cookie.\"\"\" if depth > 2 : raise RecursiveDepth ( \"Login recursion depth > 2\" ) self . logger . debug ( \"Logging in...\" ) url = BASEURL [ \"login\" ] payload = { \"username\" : self . username , \"password\" : self . password , } headers : Dict [ str , Any ] = dict ( default_headers ()) response = self . session . post ( url , headers = headers , json = payload , ) response . raise_for_status () jsondata = response . json () return self . _handle_login_response ( response . status_code , jsondata , response . cookies ) def do_login_check ( self , skip_login_check : bool ) -> None : \"\"\"checks if we're skipping the login check and logs in if necessary\"\"\" if not skip_login_check : self . logger . debug ( \"skip_login_check false\" ) if self . _has_token_expired (): self . logger . debug ( \"token has expired, logging in...\" ) self . login () def request_get ( # type: ignore self , url : str , skip_login_check : bool = False , cookies : Optional [ Dict [ str , Any ]] = None , params : Optional [ Dict [ str , Any ]] = None , ): \"\"\"Performs a GET request and logs in first if needed. Returns the `requests.Response` object.\"\"\" self . do_login_check ( skip_login_check ) if cookies is None : cookies = { \"myaussie_cookie\" : self . myaussie_cookie } response = self . session . get ( url = url , cookies = cookies , params = params ) response . raise_for_status () return response def request_get_list ( self , url : str , skip_login_check : bool = False , cookies : Optional [ Dict [ str , Any ]] = None , params : Optional [ Dict [ str , Any ]] = None , ) -> List [ Any ]: \"\"\"Performs a GET request and logs in first if needed. Returns a list from the response. \"\"\" self . do_login_check ( skip_login_check ) response = self . session . get ( url = url , cookies = cookies , params = params ) response . raise_for_status () result : List [ Any ] = response . json () return result def request_get_json ( self , url : str , skip_login_check : bool = False , cookies : Optional [ Dict [ str , Any ]] = None , params : Optional [ Dict [ str , Any ]] = None , ) -> Dict [ str , Any ]: \"\"\"Performs a GET request and logs in first if needed. Returns a dict of the JSON response. \"\"\" self . do_login_check ( skip_login_check ) response = self . session . get ( url = url , cookies = cookies , params = params ) response . raise_for_status () result : Dict [ str , Any ] = response . json () return result def request_post ( self , url : str , skip_login_check : bool = False , ** kwargs : Dict [ str , Any ] ) -> requests . Response : \"\"\"Performs a POST request and logs in first if needed.\"\"\" self . do_login_check ( skip_login_check ) if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } if \"headers\" in kwargs : headers : Dict [ str , Any ] = kwargs [ \"headers\" ] else : headers = dict ( default_headers ()) response = self . session . post ( url = url , headers = headers , ** kwargs , # type: ignore ) response . raise_for_status () return response def get_customer_details ( self ) -> Dict [ str , Any ]: \"\"\"Grabs the customer details. Returns a dict\"\"\" url = self . get_url ( \"get_customer_details\" ) querystring = { \"v\" : \"2\" } responsedata = self . request_get_json ( url = url , params = querystring , ) return responsedata @property def referral_code ( self ) -> int : \"\"\"returns the referral code, which is just the customer number\"\"\" response = self . get_customer_details () if \"customer_number\" not in response : raise ValueError ( \"Couldn't get customer_number from customer_details call.\" ) return int ( response [ \"customer_number\" ]) def _check_reload_cached_services ( self ) -> bool : \"\"\"If the age of the service data caching is too old, clear it and re-poll. Returns bool - if it reloaded the cache. \"\"\" if not self . services : self . get_services ( use_cached = False ) return True cache_expiry = self . services_last_update + self . services_cache_time if time () >= cache_expiry : self . get_services ( use_cached = False ) return True return False def get_services ( self , page : int = 1 , use_cached : bool = False , servicetypes : Optional [ List [ str ]] = None , drop_types : Optional [ List [ str ]] = None ) -> Optional [ List [ Dict [ str , Any ]]]: \"\"\"Returns a `list` of `dicts` of services associated with the account. If you want a specific kind of service, or services, provide a list of matching strings in servicetypes. If you want to use cached data, call it with `use_cached=True` \"\"\" if use_cached : self . logger . debug ( \"Using cached data for get_services.\" ) self . _check_reload_cached_services () else : url = self . get_url ( \"get_services\" ) services_list : List [ Dict [ str , Any ]] = [] while True : params = { \"page\" : page } responsedata = self . request_get_json ( url = url , params = params ) servicedata = GetServicesResponse . parse_obj ( responsedata ) for service in servicedata . data : services_list . append ( service ) if servicedata . links . next is None : break url = servicedata . links . next page = servicedata . meta [ \"current_page\" ] self . services = services_list self . services_last_update = int ( time ()) self . services = self . filter_services ( service_types = servicetypes , drop_types = drop_types , ) return self . services def account_transactions ( self ) -> Dict [ str , AccountTransaction ]: \"\"\"Pulls the data for transactions on your account. Returns a dict where the key is the month and year of the transaction. Keys: `['id', 'type', 'time', 'description', 'amountCents', 'runningBalanceCents']` Example output: ``` json \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], ``` \"\"\" url = self . get_url ( \"account_transactions\" ) responsedata = self . request_get_json ( url = url ) result : Dict [ str , AccountTransaction ] = responsedata return result def billing_invoice ( self , invoice_id : int ) -> Dict [ str , Any ]: \"\"\"Downloads an invoice This returns the bare response object, parsing the result is an exercise for the consumer. It's a PDF file. \"\"\" url = self . get_url ( \"billing_invoice\" , { \"invoice_id\" : invoice_id }) result = self . request_get_json ( url = url ) return result def account_paymentplans ( self ) -> Dict [ str , Any ]: \"\"\"Returns a dict of payment plans for an account\"\"\" url = self . get_url ( \"account_paymentplans\" ) return self . request_get_json ( url = url ) def get_usage ( self , service_id : int , use_cached : bool = True ) -> Dict [ str , Any ]: \"\"\" Returns a dict of usage for a service. If it's a telephony service (`type=PhoneMobile`) it'll pull from the telephony endpoint. \"\"\" if self . services is None : self . get_services ( use_cached = use_cached ) if self . services is not None : for service in self . services : if service_id == service [ \"service_id\" ]: # throw an error if we're trying to parse something we can't self . validate_service_type ( service ) if service [ \"type\" ] in PHONE_TYPES : return self . telephony_usage ( service_id ) url = self . get_url ( \"get_usage\" , { \"service_id\" : service_id }) result = self . request_get_json ( url = url ) return result return {} def get_service_tests ( self , service_id : int ) -> List [ ServiceTest ]: \"\"\"Gets the available tests for a given service ID Returns list of dicts Example data: ``` [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] ``` This has a habit of throwing 400 errors if you query a VOIP service... \"\"\" url = self . get_url ( \"get_service_tests\" , { \"service_id\" : service_id }) results : List [ ServiceTest ] = [ ServiceTest . parse_obj ( test ) for test in self . request_get_list ( url = url ) ] return results def get_test_history ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Gets the available tests for a given service ID Returns a list of dicts with tests which have been run \"\"\" url = self . get_url ( \"get_test_history\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) def test_line_state ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Tests the line state for a given service ID\"\"\" tests = self . get_service_tests ( service_id ) url = self . get_url ( \"test_line_state\" , { \"service_id\" : service_id }) self . is_valid_test ( url , tests ) self . logger . debug ( \"Testing line state, can take a few seconds...\" ) response = self . request_post ( url = url ) result : Dict [ str , Any ] = response . json () return result def run_test ( self , service_id : int , test_name : str , test_method : str = \"post\" ) -> Optional [ Dict [ str , Any ]]: \"\"\"Run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis - 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' - 'status' of 'Completed' means you've got the full response \"\"\" test_links = [ test for test in self . get_service_tests ( service_id ) if test . link . endswith ( f \"/ { test_name } \" ) ] # pylint: disable=line-too-long if not test_links : return None if len ( test_links ) != 1 : self . logger . debug ( \"Too many tests? %s \" , test_links ) test_name = test_links [ 0 ] . name self . logger . debug ( \"Running %s \" , test_name ) if test_method == \"get\" : return self . request_get_json ( url = test_links [ 0 ] . link ) result : Dict [ str , Any ] = self . request_post ( url = test_links [ 0 ] . link ) . json () return result def service_plans ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls the plan data for a given service. Keys: `['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds']` \"\"\" url = self . get_url ( \"service_plans\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) def service_outages ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls outages associated with a service. Keys: `['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages']` ``` \"\"\" url = self . get_url ( \"service_outages\" , { \"service_id\" : service_id }) result = AussieBBOutage . parse_obj ( self . request_get_json ( url = url )) return result . dict () def service_boltons ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls addons associated with the service. Keys: `['id', 'name', 'description', 'costCents', 'additionalNote', 'active']` Example data: ``` [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] ``` \"\"\" url = self . get_url ( \"service_boltons\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) def service_datablocks ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls datablocks associated with the service. Keys: `['current', 'available']` Example data: ``` { \"current\": [], \"available\": [] } ``` \"\"\" url = self . get_url ( \"service_datablocks\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) def telephony_usage ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls the telephony usage associated with the service. Keys: `['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical']` Example data: ``` {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} ``` \"\"\" url = self . get_url ( \"telephony_usage\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) def support_tickets ( self ) -> Dict [ str , Any ]: \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"support_tickets\" ) return self . request_get_json ( url = url ) def get_appointment ( self , ticketid : int ) -> Dict [ str , Any ]: \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"get_appointment\" , { \"ticketid\" : ticketid }) return self . request_get_json ( url = url ) def account_contacts ( self ) -> List [ AccountContact ]: \"\"\"Pulls the contacts with the account, returns a list of dicts Dict keys: `['id', 'first_name', 'last_name', 'email', 'dob', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact']` \"\"\" url = self . get_url ( \"account_contacts\" ) response = self . request_get_json ( url = url ) return [ AccountContact . parse_obj ( contact ) for contact in response ] # TODO: type get_orders def get_orders ( self ) -> Dict [ str , Any ]: \"\"\"pulls the outstanding orders for an account\"\"\" url = self . get_url ( \"get_orders\" ) responsedata = self . request_get_json ( url = url ) result = OrderResponse ( ** responsedata ) return result . dict () def get_order ( self , order_id : int ) -> OrderDetailResponse : \"\"\"gets a specific order\"\"\" url = self . get_url ( \"get_order\" , { \"order_id\" : order_id }) responsedata = self . request_get_json ( url = url ) result = cast ( OrderDetailResponse , OrderDetailResponseModel . parse_obj ( responsedata ) . dict (), ) return result def get_voip_devices ( self , service_id : int ) -> List [ VOIPDevice ]: \"\"\"gets the devices associatd with a VOIP service\"\"\" url = self . get_url ( \"voip_devices\" , { \"service_id\" : service_id }) service_list : List [ VOIPDevice ] = [] for service in self . request_get_json ( url = url ): service_list . append ( VOIPDevice . parse_obj ( service )) return service_list def get_voip_service ( self , service_id : int ) -> VOIPDetails : \"\"\"gets the details of a VOIP service\"\"\" url = self . get_url ( \"voip_service\" , { \"service_id\" : service_id }) return VOIPDetails . parse_obj ( self . request_get_json ( url = url )) def get_fetch_service ( self , service_id : int ) -> FetchService : \"\"\" gets the details of a Fetch service \"\"\" url = self . get_url ( \"fetch_service\" , { \"service_id\" : service_id }) return FetchService . parse_obj ( self . request_get_json ( url = url )) __init__ ( username , password , debug = False , services_cache_time = 28800 , session = None ) Setup function @param username: str - username for Aussie Broadband account @param password: str - password for Aussie Broadband account @param debug: bool - debug mode @param services_cache_time: int - seconds between caching get_services() - defaults to 8 hours @param session : requests.session - session object Source code in aussiebb/__init__.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , username : str , password : str , debug : bool = False , services_cache_time : int = 28800 , session : Optional [ requests . sessions . Session ] = None , ): \"\"\"Setup function ``` @param username: str - username for Aussie Broadband account @param password: str - password for Aussie Broadband account @param debug: bool - debug mode @param services_cache_time: int - seconds between caching get_services() - defaults to 8 hours @param session : requests.session - session object ``` \"\"\" super () . __init__ ( username , password , debug , services_cache_time ) if session is None : self . session = requests . Session () else : self . session = session account_contacts () Pulls the contacts with the account, returns a list of dicts Dict keys: ['id', 'first_name', 'last_name', 'email', 'dob', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact'] Source code in aussiebb/__init__.py 470 471 472 473 474 475 476 477 def account_contacts ( self ) -> List [ AccountContact ]: \"\"\"Pulls the contacts with the account, returns a list of dicts Dict keys: `['id', 'first_name', 'last_name', 'email', 'dob', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact']` \"\"\" url = self . get_url ( \"account_contacts\" ) response = self . request_get_json ( url = url ) return [ AccountContact . parse_obj ( contact ) for contact in response ] account_paymentplans () Returns a dict of payment plans for an account Source code in aussiebb/__init__.py 284 285 286 287 def account_paymentplans ( self ) -> Dict [ str , Any ]: \"\"\"Returns a dict of payment plans for an account\"\"\" url = self . get_url ( \"account_paymentplans\" ) return self . request_get_json ( url = url ) account_transactions () Pulls the data for transactions on your account. Returns a dict where the key is the month and year of the transaction. Keys: ['id', 'type', 'time', 'description', 'amountCents', 'runningBalanceCents'] Example output: \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], Source code in aussiebb/__init__.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 def account_transactions ( self ) -> Dict [ str , AccountTransaction ]: \"\"\"Pulls the data for transactions on your account. Returns a dict where the key is the month and year of the transaction. Keys: `['id', 'type', 'time', 'description', 'amountCents', 'runningBalanceCents']` Example output: ``` json \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], ``` \"\"\" url = self . get_url ( \"account_transactions\" ) responsedata = self . request_get_json ( url = url ) result : Dict [ str , AccountTransaction ] = responsedata return result billing_invoice ( invoice_id ) Downloads an invoice This returns the bare response object, parsing the result is an exercise for the consumer. It's a PDF file. Source code in aussiebb/__init__.py 274 275 276 277 278 279 280 281 282 def billing_invoice ( self , invoice_id : int ) -> Dict [ str , Any ]: \"\"\"Downloads an invoice This returns the bare response object, parsing the result is an exercise for the consumer. It's a PDF file. \"\"\" url = self . get_url ( \"billing_invoice\" , { \"invoice_id\" : invoice_id }) result = self . request_get_json ( url = url ) return result do_login_check ( skip_login_check ) checks if we're skipping the login check and logs in if necessary Source code in aussiebb/__init__.py 87 88 89 90 91 92 93 def do_login_check ( self , skip_login_check : bool ) -> None : \"\"\"checks if we're skipping the login check and logs in if necessary\"\"\" if not skip_login_check : self . logger . debug ( \"skip_login_check false\" ) if self . _has_token_expired (): self . logger . debug ( \"token has expired, logging in...\" ) self . login () get_appointment ( ticketid ) Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] Source code in aussiebb/__init__.py 462 463 464 465 466 467 468 def get_appointment ( self , ticketid : int ) -> Dict [ str , Any ]: \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"get_appointment\" , { \"ticketid\" : ticketid }) return self . request_get_json ( url = url ) get_customer_details () Grabs the customer details. Returns a dict Source code in aussiebb/__init__.py 168 169 170 171 172 173 174 175 176 177 178 def get_customer_details ( self ) -> Dict [ str , Any ]: \"\"\"Grabs the customer details. Returns a dict\"\"\" url = self . get_url ( \"get_customer_details\" ) querystring = { \"v\" : \"2\" } responsedata = self . request_get_json ( url = url , params = querystring , ) return responsedata get_fetch_service ( service_id ) gets the details of a Fetch service Source code in aussiebb/__init__.py 511 512 513 514 def get_fetch_service ( self , service_id : int ) -> FetchService : \"\"\" gets the details of a Fetch service \"\"\" url = self . get_url ( \"fetch_service\" , { \"service_id\" : service_id }) return FetchService . parse_obj ( self . request_get_json ( url = url )) get_order ( order_id ) gets a specific order Source code in aussiebb/__init__.py 488 489 490 491 492 493 494 495 496 def get_order ( self , order_id : int ) -> OrderDetailResponse : \"\"\"gets a specific order\"\"\" url = self . get_url ( \"get_order\" , { \"order_id\" : order_id }) responsedata = self . request_get_json ( url = url ) result = cast ( OrderDetailResponse , OrderDetailResponseModel . parse_obj ( responsedata ) . dict (), ) return result get_orders () pulls the outstanding orders for an account Source code in aussiebb/__init__.py 480 481 482 483 484 485 486 def get_orders ( self ) -> Dict [ str , Any ]: \"\"\"pulls the outstanding orders for an account\"\"\" url = self . get_url ( \"get_orders\" ) responsedata = self . request_get_json ( url = url ) result = OrderResponse ( ** responsedata ) return result . dict () get_service_tests ( service_id ) Gets the available tests for a given service ID Returns list of dicts Example data: [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] This has a habit of throwing 400 errors if you query a VOIP service... Source code in aussiebb/__init__.py 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 def get_service_tests ( self , service_id : int ) -> List [ ServiceTest ]: \"\"\"Gets the available tests for a given service ID Returns list of dicts Example data: ``` [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] ``` This has a habit of throwing 400 errors if you query a VOIP service... \"\"\" url = self . get_url ( \"get_service_tests\" , { \"service_id\" : service_id }) results : List [ ServiceTest ] = [ ServiceTest . parse_obj ( test ) for test in self . request_get_list ( url = url ) ] return results get_services ( page = 1 , use_cached = False , servicetypes = None , drop_types = None ) Returns a list of dicts of services associated with the account. If you want a specific kind of service, or services, provide a list of matching strings in servicetypes. If you want to use cached data, call it with use_cached=True Source code in aussiebb/__init__.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def get_services ( self , page : int = 1 , use_cached : bool = False , servicetypes : Optional [ List [ str ]] = None , drop_types : Optional [ List [ str ]] = None ) -> Optional [ List [ Dict [ str , Any ]]]: \"\"\"Returns a `list` of `dicts` of services associated with the account. If you want a specific kind of service, or services, provide a list of matching strings in servicetypes. If you want to use cached data, call it with `use_cached=True` \"\"\" if use_cached : self . logger . debug ( \"Using cached data for get_services.\" ) self . _check_reload_cached_services () else : url = self . get_url ( \"get_services\" ) services_list : List [ Dict [ str , Any ]] = [] while True : params = { \"page\" : page } responsedata = self . request_get_json ( url = url , params = params ) servicedata = GetServicesResponse . parse_obj ( responsedata ) for service in servicedata . data : services_list . append ( service ) if servicedata . links . next is None : break url = servicedata . links . next page = servicedata . meta [ \"current_page\" ] self . services = services_list self . services_last_update = int ( time ()) self . services = self . filter_services ( service_types = servicetypes , drop_types = drop_types , ) return self . services get_test_history ( service_id ) Gets the available tests for a given service ID Returns a list of dicts with tests which have been run Source code in aussiebb/__init__.py 332 333 334 335 336 337 338 def get_test_history ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Gets the available tests for a given service ID Returns a list of dicts with tests which have been run \"\"\" url = self . get_url ( \"get_test_history\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) get_usage ( service_id , use_cached = True ) Returns a dict of usage for a service. If it's a telephony service ( type=PhoneMobile ) it'll pull from the telephony endpoint. Source code in aussiebb/__init__.py 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 def get_usage ( self , service_id : int , use_cached : bool = True ) -> Dict [ str , Any ]: \"\"\" Returns a dict of usage for a service. If it's a telephony service (`type=PhoneMobile`) it'll pull from the telephony endpoint. \"\"\" if self . services is None : self . get_services ( use_cached = use_cached ) if self . services is not None : for service in self . services : if service_id == service [ \"service_id\" ]: # throw an error if we're trying to parse something we can't self . validate_service_type ( service ) if service [ \"type\" ] in PHONE_TYPES : return self . telephony_usage ( service_id ) url = self . get_url ( \"get_usage\" , { \"service_id\" : service_id }) result = self . request_get_json ( url = url ) return result return {} get_voip_devices ( service_id ) gets the devices associatd with a VOIP service Source code in aussiebb/__init__.py 498 499 500 501 502 503 504 def get_voip_devices ( self , service_id : int ) -> List [ VOIPDevice ]: \"\"\"gets the devices associatd with a VOIP service\"\"\" url = self . get_url ( \"voip_devices\" , { \"service_id\" : service_id }) service_list : List [ VOIPDevice ] = [] for service in self . request_get_json ( url = url ): service_list . append ( VOIPDevice . parse_obj ( service )) return service_list get_voip_service ( service_id ) gets the details of a VOIP service Source code in aussiebb/__init__.py 506 507 508 509 def get_voip_service ( self , service_id : int ) -> VOIPDetails : \"\"\"gets the details of a VOIP service\"\"\" url = self . get_url ( \"voip_service\" , { \"service_id\" : service_id }) return VOIPDetails . parse_obj ( self . request_get_json ( url = url )) login ( depth = 0 ) Logs into the account and caches the cookie. Source code in aussiebb/__init__.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def login ( self , depth : int = 0 ) -> bool : \"\"\"Logs into the account and caches the cookie.\"\"\" if depth > 2 : raise RecursiveDepth ( \"Login recursion depth > 2\" ) self . logger . debug ( \"Logging in...\" ) url = BASEURL [ \"login\" ] payload = { \"username\" : self . username , \"password\" : self . password , } headers : Dict [ str , Any ] = dict ( default_headers ()) response = self . session . post ( url , headers = headers , json = payload , ) response . raise_for_status () jsondata = response . json () return self . _handle_login_response ( response . status_code , jsondata , response . cookies ) referral_code () property returns the referral code, which is just the customer number Source code in aussiebb/__init__.py 180 181 182 183 184 185 186 @property def referral_code ( self ) -> int : \"\"\"returns the referral code, which is just the customer number\"\"\" response = self . get_customer_details () if \"customer_number\" not in response : raise ValueError ( \"Couldn't get customer_number from customer_details call.\" ) return int ( response [ \"customer_number\" ]) request_get ( url , skip_login_check = False , cookies = None , params = None ) Performs a GET request and logs in first if needed. Returns the requests.Response object. Source code in aussiebb/__init__.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def request_get ( # type: ignore self , url : str , skip_login_check : bool = False , cookies : Optional [ Dict [ str , Any ]] = None , params : Optional [ Dict [ str , Any ]] = None , ): \"\"\"Performs a GET request and logs in first if needed. Returns the `requests.Response` object.\"\"\" self . do_login_check ( skip_login_check ) if cookies is None : cookies = { \"myaussie_cookie\" : self . myaussie_cookie } response = self . session . get ( url = url , cookies = cookies , params = params ) response . raise_for_status () return response request_get_json ( url , skip_login_check = False , cookies = None , params = None ) Performs a GET request and logs in first if needed. Returns a dict of the JSON response. Source code in aussiebb/__init__.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def request_get_json ( self , url : str , skip_login_check : bool = False , cookies : Optional [ Dict [ str , Any ]] = None , params : Optional [ Dict [ str , Any ]] = None , ) -> Dict [ str , Any ]: \"\"\"Performs a GET request and logs in first if needed. Returns a dict of the JSON response. \"\"\" self . do_login_check ( skip_login_check ) response = self . session . get ( url = url , cookies = cookies , params = params ) response . raise_for_status () result : Dict [ str , Any ] = response . json () return result request_get_list ( url , skip_login_check = False , cookies = None , params = None ) Performs a GET request and logs in first if needed. Returns a list from the response. Source code in aussiebb/__init__.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def request_get_list ( self , url : str , skip_login_check : bool = False , cookies : Optional [ Dict [ str , Any ]] = None , params : Optional [ Dict [ str , Any ]] = None , ) -> List [ Any ]: \"\"\"Performs a GET request and logs in first if needed. Returns a list from the response. \"\"\" self . do_login_check ( skip_login_check ) response = self . session . get ( url = url , cookies = cookies , params = params ) response . raise_for_status () result : List [ Any ] = response . json () return result request_post ( url , skip_login_check = False , ** kwargs ) Performs a POST request and logs in first if needed. Source code in aussiebb/__init__.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def request_post ( self , url : str , skip_login_check : bool = False , ** kwargs : Dict [ str , Any ] ) -> requests . Response : \"\"\"Performs a POST request and logs in first if needed.\"\"\" self . do_login_check ( skip_login_check ) if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } if \"headers\" in kwargs : headers : Dict [ str , Any ] = kwargs [ \"headers\" ] else : headers = dict ( default_headers ()) response = self . session . post ( url = url , headers = headers , ** kwargs , # type: ignore ) response . raise_for_status () return response run_test ( service_id , test_name , test_method = 'post' ) Run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' 'status' of 'Completed' means you've got the full response Source code in aussiebb/__init__.py 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 def run_test ( self , service_id : int , test_name : str , test_method : str = \"post\" ) -> Optional [ Dict [ str , Any ]]: \"\"\"Run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis - 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' - 'status' of 'Completed' means you've got the full response \"\"\" test_links = [ test for test in self . get_service_tests ( service_id ) if test . link . endswith ( f \"/ { test_name } \" ) ] # pylint: disable=line-too-long if not test_links : return None if len ( test_links ) != 1 : self . logger . debug ( \"Too many tests? %s \" , test_links ) test_name = test_links [ 0 ] . name self . logger . debug ( \"Running %s \" , test_name ) if test_method == \"get\" : return self . request_get_json ( url = test_links [ 0 ] . link ) result : Dict [ str , Any ] = self . request_post ( url = test_links [ 0 ] . link ) . json () return result service_boltons ( service_id ) Pulls addons associated with the service. Keys: ['id', 'name', 'description', 'costCents', 'additionalNote', 'active'] Example data: [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] Source code in aussiebb/__init__.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 def service_boltons ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls addons associated with the service. Keys: `['id', 'name', 'description', 'costCents', 'additionalNote', 'active']` Example data: ``` [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] ``` \"\"\" url = self . get_url ( \"service_boltons\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) service_datablocks ( service_id ) Pulls datablocks associated with the service. Keys: ['current', 'available'] Example data: { \"current\": [], \"available\": [] } Source code in aussiebb/__init__.py 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 def service_datablocks ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls datablocks associated with the service. Keys: `['current', 'available']` Example data: ``` { \"current\": [], \"available\": [] } ``` \"\"\" url = self . get_url ( \"service_datablocks\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) service_outages ( service_id ) Pulls outages associated with a service. Keys: ['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages'] ``` Source code in aussiebb/__init__.py 390 391 392 393 394 395 396 397 398 399 def service_outages ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls outages associated with a service. Keys: `['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages']` ``` \"\"\" url = self . get_url ( \"service_outages\" , { \"service_id\" : service_id }) result = AussieBBOutage . parse_obj ( self . request_get_json ( url = url )) return result . dict () service_plans ( service_id ) Pulls the plan data for a given service. Keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] Source code in aussiebb/__init__.py 381 382 383 384 385 386 387 388 def service_plans ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls the plan data for a given service. Keys: `['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds']` \"\"\" url = self . get_url ( \"service_plans\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) support_tickets () Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] Source code in aussiebb/__init__.py 453 454 455 456 457 458 459 460 def support_tickets ( self ) -> Dict [ str , Any ]: \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"support_tickets\" ) return self . request_get_json ( url = url ) telephony_usage ( service_id ) Pulls the telephony usage associated with the service. Keys: ['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical'] Example data: {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} Source code in aussiebb/__init__.py 439 440 441 442 443 444 445 446 447 448 449 450 451 def telephony_usage ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls the telephony usage associated with the service. Keys: `['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical']` Example data: ``` {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} ``` \"\"\" url = self . get_url ( \"telephony_usage\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) test_line_state ( service_id ) Tests the line state for a given service ID Source code in aussiebb/__init__.py 340 341 342 343 344 345 346 347 348 349 350 def test_line_state ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Tests the line state for a given service ID\"\"\" tests = self . get_service_tests ( service_id ) url = self . get_url ( \"test_line_state\" , { \"service_id\" : service_id }) self . is_valid_test ( url , tests ) self . logger . debug ( \"Testing line state, can take a few seconds...\" ) response = self . request_post ( url = url ) result : Dict [ str , Any ] = response . json () return result","title":"API Documentation"},{"location":"aussiebb/#aussiebb.AussieBB","text":"Bases: BaseClass A class for interacting with Aussie Broadband APIs Source code in aussiebb/__init__.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 class AussieBB ( BaseClass ): \"\"\"A class for interacting with Aussie Broadband APIs\"\"\" def __init__ ( self , username : str , password : str , debug : bool = False , services_cache_time : int = 28800 , session : Optional [ requests . sessions . Session ] = None , ): \"\"\"Setup function ``` @param username: str - username for Aussie Broadband account @param password: str - password for Aussie Broadband account @param debug: bool - debug mode @param services_cache_time: int - seconds between caching get_services() - defaults to 8 hours @param session : requests.session - session object ``` \"\"\" super () . __init__ ( username , password , debug , services_cache_time ) if session is None : self . session = requests . Session () else : self . session = session def login ( self , depth : int = 0 ) -> bool : \"\"\"Logs into the account and caches the cookie.\"\"\" if depth > 2 : raise RecursiveDepth ( \"Login recursion depth > 2\" ) self . logger . debug ( \"Logging in...\" ) url = BASEURL [ \"login\" ] payload = { \"username\" : self . username , \"password\" : self . password , } headers : Dict [ str , Any ] = dict ( default_headers ()) response = self . session . post ( url , headers = headers , json = payload , ) response . raise_for_status () jsondata = response . json () return self . _handle_login_response ( response . status_code , jsondata , response . cookies ) def do_login_check ( self , skip_login_check : bool ) -> None : \"\"\"checks if we're skipping the login check and logs in if necessary\"\"\" if not skip_login_check : self . logger . debug ( \"skip_login_check false\" ) if self . _has_token_expired (): self . logger . debug ( \"token has expired, logging in...\" ) self . login () def request_get ( # type: ignore self , url : str , skip_login_check : bool = False , cookies : Optional [ Dict [ str , Any ]] = None , params : Optional [ Dict [ str , Any ]] = None , ): \"\"\"Performs a GET request and logs in first if needed. Returns the `requests.Response` object.\"\"\" self . do_login_check ( skip_login_check ) if cookies is None : cookies = { \"myaussie_cookie\" : self . myaussie_cookie } response = self . session . get ( url = url , cookies = cookies , params = params ) response . raise_for_status () return response def request_get_list ( self , url : str , skip_login_check : bool = False , cookies : Optional [ Dict [ str , Any ]] = None , params : Optional [ Dict [ str , Any ]] = None , ) -> List [ Any ]: \"\"\"Performs a GET request and logs in first if needed. Returns a list from the response. \"\"\" self . do_login_check ( skip_login_check ) response = self . session . get ( url = url , cookies = cookies , params = params ) response . raise_for_status () result : List [ Any ] = response . json () return result def request_get_json ( self , url : str , skip_login_check : bool = False , cookies : Optional [ Dict [ str , Any ]] = None , params : Optional [ Dict [ str , Any ]] = None , ) -> Dict [ str , Any ]: \"\"\"Performs a GET request and logs in first if needed. Returns a dict of the JSON response. \"\"\" self . do_login_check ( skip_login_check ) response = self . session . get ( url = url , cookies = cookies , params = params ) response . raise_for_status () result : Dict [ str , Any ] = response . json () return result def request_post ( self , url : str , skip_login_check : bool = False , ** kwargs : Dict [ str , Any ] ) -> requests . Response : \"\"\"Performs a POST request and logs in first if needed.\"\"\" self . do_login_check ( skip_login_check ) if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } if \"headers\" in kwargs : headers : Dict [ str , Any ] = kwargs [ \"headers\" ] else : headers = dict ( default_headers ()) response = self . session . post ( url = url , headers = headers , ** kwargs , # type: ignore ) response . raise_for_status () return response def get_customer_details ( self ) -> Dict [ str , Any ]: \"\"\"Grabs the customer details. Returns a dict\"\"\" url = self . get_url ( \"get_customer_details\" ) querystring = { \"v\" : \"2\" } responsedata = self . request_get_json ( url = url , params = querystring , ) return responsedata @property def referral_code ( self ) -> int : \"\"\"returns the referral code, which is just the customer number\"\"\" response = self . get_customer_details () if \"customer_number\" not in response : raise ValueError ( \"Couldn't get customer_number from customer_details call.\" ) return int ( response [ \"customer_number\" ]) def _check_reload_cached_services ( self ) -> bool : \"\"\"If the age of the service data caching is too old, clear it and re-poll. Returns bool - if it reloaded the cache. \"\"\" if not self . services : self . get_services ( use_cached = False ) return True cache_expiry = self . services_last_update + self . services_cache_time if time () >= cache_expiry : self . get_services ( use_cached = False ) return True return False def get_services ( self , page : int = 1 , use_cached : bool = False , servicetypes : Optional [ List [ str ]] = None , drop_types : Optional [ List [ str ]] = None ) -> Optional [ List [ Dict [ str , Any ]]]: \"\"\"Returns a `list` of `dicts` of services associated with the account. If you want a specific kind of service, or services, provide a list of matching strings in servicetypes. If you want to use cached data, call it with `use_cached=True` \"\"\" if use_cached : self . logger . debug ( \"Using cached data for get_services.\" ) self . _check_reload_cached_services () else : url = self . get_url ( \"get_services\" ) services_list : List [ Dict [ str , Any ]] = [] while True : params = { \"page\" : page } responsedata = self . request_get_json ( url = url , params = params ) servicedata = GetServicesResponse . parse_obj ( responsedata ) for service in servicedata . data : services_list . append ( service ) if servicedata . links . next is None : break url = servicedata . links . next page = servicedata . meta [ \"current_page\" ] self . services = services_list self . services_last_update = int ( time ()) self . services = self . filter_services ( service_types = servicetypes , drop_types = drop_types , ) return self . services def account_transactions ( self ) -> Dict [ str , AccountTransaction ]: \"\"\"Pulls the data for transactions on your account. Returns a dict where the key is the month and year of the transaction. Keys: `['id', 'type', 'time', 'description', 'amountCents', 'runningBalanceCents']` Example output: ``` json \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], ``` \"\"\" url = self . get_url ( \"account_transactions\" ) responsedata = self . request_get_json ( url = url ) result : Dict [ str , AccountTransaction ] = responsedata return result def billing_invoice ( self , invoice_id : int ) -> Dict [ str , Any ]: \"\"\"Downloads an invoice This returns the bare response object, parsing the result is an exercise for the consumer. It's a PDF file. \"\"\" url = self . get_url ( \"billing_invoice\" , { \"invoice_id\" : invoice_id }) result = self . request_get_json ( url = url ) return result def account_paymentplans ( self ) -> Dict [ str , Any ]: \"\"\"Returns a dict of payment plans for an account\"\"\" url = self . get_url ( \"account_paymentplans\" ) return self . request_get_json ( url = url ) def get_usage ( self , service_id : int , use_cached : bool = True ) -> Dict [ str , Any ]: \"\"\" Returns a dict of usage for a service. If it's a telephony service (`type=PhoneMobile`) it'll pull from the telephony endpoint. \"\"\" if self . services is None : self . get_services ( use_cached = use_cached ) if self . services is not None : for service in self . services : if service_id == service [ \"service_id\" ]: # throw an error if we're trying to parse something we can't self . validate_service_type ( service ) if service [ \"type\" ] in PHONE_TYPES : return self . telephony_usage ( service_id ) url = self . get_url ( \"get_usage\" , { \"service_id\" : service_id }) result = self . request_get_json ( url = url ) return result return {} def get_service_tests ( self , service_id : int ) -> List [ ServiceTest ]: \"\"\"Gets the available tests for a given service ID Returns list of dicts Example data: ``` [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] ``` This has a habit of throwing 400 errors if you query a VOIP service... \"\"\" url = self . get_url ( \"get_service_tests\" , { \"service_id\" : service_id }) results : List [ ServiceTest ] = [ ServiceTest . parse_obj ( test ) for test in self . request_get_list ( url = url ) ] return results def get_test_history ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Gets the available tests for a given service ID Returns a list of dicts with tests which have been run \"\"\" url = self . get_url ( \"get_test_history\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) def test_line_state ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Tests the line state for a given service ID\"\"\" tests = self . get_service_tests ( service_id ) url = self . get_url ( \"test_line_state\" , { \"service_id\" : service_id }) self . is_valid_test ( url , tests ) self . logger . debug ( \"Testing line state, can take a few seconds...\" ) response = self . request_post ( url = url ) result : Dict [ str , Any ] = response . json () return result def run_test ( self , service_id : int , test_name : str , test_method : str = \"post\" ) -> Optional [ Dict [ str , Any ]]: \"\"\"Run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis - 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' - 'status' of 'Completed' means you've got the full response \"\"\" test_links = [ test for test in self . get_service_tests ( service_id ) if test . link . endswith ( f \"/ { test_name } \" ) ] # pylint: disable=line-too-long if not test_links : return None if len ( test_links ) != 1 : self . logger . debug ( \"Too many tests? %s \" , test_links ) test_name = test_links [ 0 ] . name self . logger . debug ( \"Running %s \" , test_name ) if test_method == \"get\" : return self . request_get_json ( url = test_links [ 0 ] . link ) result : Dict [ str , Any ] = self . request_post ( url = test_links [ 0 ] . link ) . json () return result def service_plans ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls the plan data for a given service. Keys: `['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds']` \"\"\" url = self . get_url ( \"service_plans\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) def service_outages ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls outages associated with a service. Keys: `['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages']` ``` \"\"\" url = self . get_url ( \"service_outages\" , { \"service_id\" : service_id }) result = AussieBBOutage . parse_obj ( self . request_get_json ( url = url )) return result . dict () def service_boltons ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls addons associated with the service. Keys: `['id', 'name', 'description', 'costCents', 'additionalNote', 'active']` Example data: ``` [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] ``` \"\"\" url = self . get_url ( \"service_boltons\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) def service_datablocks ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls datablocks associated with the service. Keys: `['current', 'available']` Example data: ``` { \"current\": [], \"available\": [] } ``` \"\"\" url = self . get_url ( \"service_datablocks\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) def telephony_usage ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls the telephony usage associated with the service. Keys: `['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical']` Example data: ``` {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} ``` \"\"\" url = self . get_url ( \"telephony_usage\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) def support_tickets ( self ) -> Dict [ str , Any ]: \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"support_tickets\" ) return self . request_get_json ( url = url ) def get_appointment ( self , ticketid : int ) -> Dict [ str , Any ]: \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"get_appointment\" , { \"ticketid\" : ticketid }) return self . request_get_json ( url = url ) def account_contacts ( self ) -> List [ AccountContact ]: \"\"\"Pulls the contacts with the account, returns a list of dicts Dict keys: `['id', 'first_name', 'last_name', 'email', 'dob', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact']` \"\"\" url = self . get_url ( \"account_contacts\" ) response = self . request_get_json ( url = url ) return [ AccountContact . parse_obj ( contact ) for contact in response ] # TODO: type get_orders def get_orders ( self ) -> Dict [ str , Any ]: \"\"\"pulls the outstanding orders for an account\"\"\" url = self . get_url ( \"get_orders\" ) responsedata = self . request_get_json ( url = url ) result = OrderResponse ( ** responsedata ) return result . dict () def get_order ( self , order_id : int ) -> OrderDetailResponse : \"\"\"gets a specific order\"\"\" url = self . get_url ( \"get_order\" , { \"order_id\" : order_id }) responsedata = self . request_get_json ( url = url ) result = cast ( OrderDetailResponse , OrderDetailResponseModel . parse_obj ( responsedata ) . dict (), ) return result def get_voip_devices ( self , service_id : int ) -> List [ VOIPDevice ]: \"\"\"gets the devices associatd with a VOIP service\"\"\" url = self . get_url ( \"voip_devices\" , { \"service_id\" : service_id }) service_list : List [ VOIPDevice ] = [] for service in self . request_get_json ( url = url ): service_list . append ( VOIPDevice . parse_obj ( service )) return service_list def get_voip_service ( self , service_id : int ) -> VOIPDetails : \"\"\"gets the details of a VOIP service\"\"\" url = self . get_url ( \"voip_service\" , { \"service_id\" : service_id }) return VOIPDetails . parse_obj ( self . request_get_json ( url = url )) def get_fetch_service ( self , service_id : int ) -> FetchService : \"\"\" gets the details of a Fetch service \"\"\" url = self . get_url ( \"fetch_service\" , { \"service_id\" : service_id }) return FetchService . parse_obj ( self . request_get_json ( url = url ))","title":"AussieBB"},{"location":"aussiebb/#aussiebb.AussieBB.__init__","text":"Setup function @param username: str - username for Aussie Broadband account @param password: str - password for Aussie Broadband account @param debug: bool - debug mode @param services_cache_time: int - seconds between caching get_services() - defaults to 8 hours @param session : requests.session - session object Source code in aussiebb/__init__.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , username : str , password : str , debug : bool = False , services_cache_time : int = 28800 , session : Optional [ requests . sessions . Session ] = None , ): \"\"\"Setup function ``` @param username: str - username for Aussie Broadband account @param password: str - password for Aussie Broadband account @param debug: bool - debug mode @param services_cache_time: int - seconds between caching get_services() - defaults to 8 hours @param session : requests.session - session object ``` \"\"\" super () . __init__ ( username , password , debug , services_cache_time ) if session is None : self . session = requests . Session () else : self . session = session","title":"__init__()"},{"location":"aussiebb/#aussiebb.AussieBB.account_contacts","text":"Pulls the contacts with the account, returns a list of dicts Dict keys: ['id', 'first_name', 'last_name', 'email', 'dob', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact'] Source code in aussiebb/__init__.py 470 471 472 473 474 475 476 477 def account_contacts ( self ) -> List [ AccountContact ]: \"\"\"Pulls the contacts with the account, returns a list of dicts Dict keys: `['id', 'first_name', 'last_name', 'email', 'dob', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact']` \"\"\" url = self . get_url ( \"account_contacts\" ) response = self . request_get_json ( url = url ) return [ AccountContact . parse_obj ( contact ) for contact in response ]","title":"account_contacts()"},{"location":"aussiebb/#aussiebb.AussieBB.account_paymentplans","text":"Returns a dict of payment plans for an account Source code in aussiebb/__init__.py 284 285 286 287 def account_paymentplans ( self ) -> Dict [ str , Any ]: \"\"\"Returns a dict of payment plans for an account\"\"\" url = self . get_url ( \"account_paymentplans\" ) return self . request_get_json ( url = url )","title":"account_paymentplans()"},{"location":"aussiebb/#aussiebb.AussieBB.account_transactions","text":"Pulls the data for transactions on your account. Returns a dict where the key is the month and year of the transaction. Keys: ['id', 'type', 'time', 'description', 'amountCents', 'runningBalanceCents'] Example output: \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], Source code in aussiebb/__init__.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 def account_transactions ( self ) -> Dict [ str , AccountTransaction ]: \"\"\"Pulls the data for transactions on your account. Returns a dict where the key is the month and year of the transaction. Keys: `['id', 'type', 'time', 'description', 'amountCents', 'runningBalanceCents']` Example output: ``` json \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], ``` \"\"\" url = self . get_url ( \"account_transactions\" ) responsedata = self . request_get_json ( url = url ) result : Dict [ str , AccountTransaction ] = responsedata return result","title":"account_transactions()"},{"location":"aussiebb/#aussiebb.AussieBB.billing_invoice","text":"Downloads an invoice This returns the bare response object, parsing the result is an exercise for the consumer. It's a PDF file. Source code in aussiebb/__init__.py 274 275 276 277 278 279 280 281 282 def billing_invoice ( self , invoice_id : int ) -> Dict [ str , Any ]: \"\"\"Downloads an invoice This returns the bare response object, parsing the result is an exercise for the consumer. It's a PDF file. \"\"\" url = self . get_url ( \"billing_invoice\" , { \"invoice_id\" : invoice_id }) result = self . request_get_json ( url = url ) return result","title":"billing_invoice()"},{"location":"aussiebb/#aussiebb.AussieBB.do_login_check","text":"checks if we're skipping the login check and logs in if necessary Source code in aussiebb/__init__.py 87 88 89 90 91 92 93 def do_login_check ( self , skip_login_check : bool ) -> None : \"\"\"checks if we're skipping the login check and logs in if necessary\"\"\" if not skip_login_check : self . logger . debug ( \"skip_login_check false\" ) if self . _has_token_expired (): self . logger . debug ( \"token has expired, logging in...\" ) self . login ()","title":"do_login_check()"},{"location":"aussiebb/#aussiebb.AussieBB.get_appointment","text":"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] Source code in aussiebb/__init__.py 462 463 464 465 466 467 468 def get_appointment ( self , ticketid : int ) -> Dict [ str , Any ]: \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"get_appointment\" , { \"ticketid\" : ticketid }) return self . request_get_json ( url = url )","title":"get_appointment()"},{"location":"aussiebb/#aussiebb.AussieBB.get_customer_details","text":"Grabs the customer details. Returns a dict Source code in aussiebb/__init__.py 168 169 170 171 172 173 174 175 176 177 178 def get_customer_details ( self ) -> Dict [ str , Any ]: \"\"\"Grabs the customer details. Returns a dict\"\"\" url = self . get_url ( \"get_customer_details\" ) querystring = { \"v\" : \"2\" } responsedata = self . request_get_json ( url = url , params = querystring , ) return responsedata","title":"get_customer_details()"},{"location":"aussiebb/#aussiebb.AussieBB.get_fetch_service","text":"gets the details of a Fetch service Source code in aussiebb/__init__.py 511 512 513 514 def get_fetch_service ( self , service_id : int ) -> FetchService : \"\"\" gets the details of a Fetch service \"\"\" url = self . get_url ( \"fetch_service\" , { \"service_id\" : service_id }) return FetchService . parse_obj ( self . request_get_json ( url = url ))","title":"get_fetch_service()"},{"location":"aussiebb/#aussiebb.AussieBB.get_order","text":"gets a specific order Source code in aussiebb/__init__.py 488 489 490 491 492 493 494 495 496 def get_order ( self , order_id : int ) -> OrderDetailResponse : \"\"\"gets a specific order\"\"\" url = self . get_url ( \"get_order\" , { \"order_id\" : order_id }) responsedata = self . request_get_json ( url = url ) result = cast ( OrderDetailResponse , OrderDetailResponseModel . parse_obj ( responsedata ) . dict (), ) return result","title":"get_order()"},{"location":"aussiebb/#aussiebb.AussieBB.get_orders","text":"pulls the outstanding orders for an account Source code in aussiebb/__init__.py 480 481 482 483 484 485 486 def get_orders ( self ) -> Dict [ str , Any ]: \"\"\"pulls the outstanding orders for an account\"\"\" url = self . get_url ( \"get_orders\" ) responsedata = self . request_get_json ( url = url ) result = OrderResponse ( ** responsedata ) return result . dict ()","title":"get_orders()"},{"location":"aussiebb/#aussiebb.AussieBB.get_service_tests","text":"Gets the available tests for a given service ID Returns list of dicts Example data: [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] This has a habit of throwing 400 errors if you query a VOIP service... Source code in aussiebb/__init__.py 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 def get_service_tests ( self , service_id : int ) -> List [ ServiceTest ]: \"\"\"Gets the available tests for a given service ID Returns list of dicts Example data: ``` [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] ``` This has a habit of throwing 400 errors if you query a VOIP service... \"\"\" url = self . get_url ( \"get_service_tests\" , { \"service_id\" : service_id }) results : List [ ServiceTest ] = [ ServiceTest . parse_obj ( test ) for test in self . request_get_list ( url = url ) ] return results","title":"get_service_tests()"},{"location":"aussiebb/#aussiebb.AussieBB.get_services","text":"Returns a list of dicts of services associated with the account. If you want a specific kind of service, or services, provide a list of matching strings in servicetypes. If you want to use cached data, call it with use_cached=True Source code in aussiebb/__init__.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def get_services ( self , page : int = 1 , use_cached : bool = False , servicetypes : Optional [ List [ str ]] = None , drop_types : Optional [ List [ str ]] = None ) -> Optional [ List [ Dict [ str , Any ]]]: \"\"\"Returns a `list` of `dicts` of services associated with the account. If you want a specific kind of service, or services, provide a list of matching strings in servicetypes. If you want to use cached data, call it with `use_cached=True` \"\"\" if use_cached : self . logger . debug ( \"Using cached data for get_services.\" ) self . _check_reload_cached_services () else : url = self . get_url ( \"get_services\" ) services_list : List [ Dict [ str , Any ]] = [] while True : params = { \"page\" : page } responsedata = self . request_get_json ( url = url , params = params ) servicedata = GetServicesResponse . parse_obj ( responsedata ) for service in servicedata . data : services_list . append ( service ) if servicedata . links . next is None : break url = servicedata . links . next page = servicedata . meta [ \"current_page\" ] self . services = services_list self . services_last_update = int ( time ()) self . services = self . filter_services ( service_types = servicetypes , drop_types = drop_types , ) return self . services","title":"get_services()"},{"location":"aussiebb/#aussiebb.AussieBB.get_test_history","text":"Gets the available tests for a given service ID Returns a list of dicts with tests which have been run Source code in aussiebb/__init__.py 332 333 334 335 336 337 338 def get_test_history ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Gets the available tests for a given service ID Returns a list of dicts with tests which have been run \"\"\" url = self . get_url ( \"get_test_history\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url )","title":"get_test_history()"},{"location":"aussiebb/#aussiebb.AussieBB.get_usage","text":"Returns a dict of usage for a service. If it's a telephony service ( type=PhoneMobile ) it'll pull from the telephony endpoint. Source code in aussiebb/__init__.py 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 def get_usage ( self , service_id : int , use_cached : bool = True ) -> Dict [ str , Any ]: \"\"\" Returns a dict of usage for a service. If it's a telephony service (`type=PhoneMobile`) it'll pull from the telephony endpoint. \"\"\" if self . services is None : self . get_services ( use_cached = use_cached ) if self . services is not None : for service in self . services : if service_id == service [ \"service_id\" ]: # throw an error if we're trying to parse something we can't self . validate_service_type ( service ) if service [ \"type\" ] in PHONE_TYPES : return self . telephony_usage ( service_id ) url = self . get_url ( \"get_usage\" , { \"service_id\" : service_id }) result = self . request_get_json ( url = url ) return result return {}","title":"get_usage()"},{"location":"aussiebb/#aussiebb.AussieBB.get_voip_devices","text":"gets the devices associatd with a VOIP service Source code in aussiebb/__init__.py 498 499 500 501 502 503 504 def get_voip_devices ( self , service_id : int ) -> List [ VOIPDevice ]: \"\"\"gets the devices associatd with a VOIP service\"\"\" url = self . get_url ( \"voip_devices\" , { \"service_id\" : service_id }) service_list : List [ VOIPDevice ] = [] for service in self . request_get_json ( url = url ): service_list . append ( VOIPDevice . parse_obj ( service )) return service_list","title":"get_voip_devices()"},{"location":"aussiebb/#aussiebb.AussieBB.get_voip_service","text":"gets the details of a VOIP service Source code in aussiebb/__init__.py 506 507 508 509 def get_voip_service ( self , service_id : int ) -> VOIPDetails : \"\"\"gets the details of a VOIP service\"\"\" url = self . get_url ( \"voip_service\" , { \"service_id\" : service_id }) return VOIPDetails . parse_obj ( self . request_get_json ( url = url ))","title":"get_voip_service()"},{"location":"aussiebb/#aussiebb.AussieBB.login","text":"Logs into the account and caches the cookie. Source code in aussiebb/__init__.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def login ( self , depth : int = 0 ) -> bool : \"\"\"Logs into the account and caches the cookie.\"\"\" if depth > 2 : raise RecursiveDepth ( \"Login recursion depth > 2\" ) self . logger . debug ( \"Logging in...\" ) url = BASEURL [ \"login\" ] payload = { \"username\" : self . username , \"password\" : self . password , } headers : Dict [ str , Any ] = dict ( default_headers ()) response = self . session . post ( url , headers = headers , json = payload , ) response . raise_for_status () jsondata = response . json () return self . _handle_login_response ( response . status_code , jsondata , response . cookies )","title":"login()"},{"location":"aussiebb/#aussiebb.AussieBB.referral_code","text":"returns the referral code, which is just the customer number Source code in aussiebb/__init__.py 180 181 182 183 184 185 186 @property def referral_code ( self ) -> int : \"\"\"returns the referral code, which is just the customer number\"\"\" response = self . get_customer_details () if \"customer_number\" not in response : raise ValueError ( \"Couldn't get customer_number from customer_details call.\" ) return int ( response [ \"customer_number\" ])","title":"referral_code()"},{"location":"aussiebb/#aussiebb.AussieBB.request_get","text":"Performs a GET request and logs in first if needed. Returns the requests.Response object. Source code in aussiebb/__init__.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def request_get ( # type: ignore self , url : str , skip_login_check : bool = False , cookies : Optional [ Dict [ str , Any ]] = None , params : Optional [ Dict [ str , Any ]] = None , ): \"\"\"Performs a GET request and logs in first if needed. Returns the `requests.Response` object.\"\"\" self . do_login_check ( skip_login_check ) if cookies is None : cookies = { \"myaussie_cookie\" : self . myaussie_cookie } response = self . session . get ( url = url , cookies = cookies , params = params ) response . raise_for_status () return response","title":"request_get()"},{"location":"aussiebb/#aussiebb.AussieBB.request_get_json","text":"Performs a GET request and logs in first if needed. Returns a dict of the JSON response. Source code in aussiebb/__init__.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def request_get_json ( self , url : str , skip_login_check : bool = False , cookies : Optional [ Dict [ str , Any ]] = None , params : Optional [ Dict [ str , Any ]] = None , ) -> Dict [ str , Any ]: \"\"\"Performs a GET request and logs in first if needed. Returns a dict of the JSON response. \"\"\" self . do_login_check ( skip_login_check ) response = self . session . get ( url = url , cookies = cookies , params = params ) response . raise_for_status () result : Dict [ str , Any ] = response . json () return result","title":"request_get_json()"},{"location":"aussiebb/#aussiebb.AussieBB.request_get_list","text":"Performs a GET request and logs in first if needed. Returns a list from the response. Source code in aussiebb/__init__.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def request_get_list ( self , url : str , skip_login_check : bool = False , cookies : Optional [ Dict [ str , Any ]] = None , params : Optional [ Dict [ str , Any ]] = None , ) -> List [ Any ]: \"\"\"Performs a GET request and logs in first if needed. Returns a list from the response. \"\"\" self . do_login_check ( skip_login_check ) response = self . session . get ( url = url , cookies = cookies , params = params ) response . raise_for_status () result : List [ Any ] = response . json () return result","title":"request_get_list()"},{"location":"aussiebb/#aussiebb.AussieBB.request_post","text":"Performs a POST request and logs in first if needed. Source code in aussiebb/__init__.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def request_post ( self , url : str , skip_login_check : bool = False , ** kwargs : Dict [ str , Any ] ) -> requests . Response : \"\"\"Performs a POST request and logs in first if needed.\"\"\" self . do_login_check ( skip_login_check ) if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } if \"headers\" in kwargs : headers : Dict [ str , Any ] = kwargs [ \"headers\" ] else : headers = dict ( default_headers ()) response = self . session . post ( url = url , headers = headers , ** kwargs , # type: ignore ) response . raise_for_status () return response","title":"request_post()"},{"location":"aussiebb/#aussiebb.AussieBB.run_test","text":"Run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' 'status' of 'Completed' means you've got the full response Source code in aussiebb/__init__.py 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 def run_test ( self , service_id : int , test_name : str , test_method : str = \"post\" ) -> Optional [ Dict [ str , Any ]]: \"\"\"Run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis - 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' - 'status' of 'Completed' means you've got the full response \"\"\" test_links = [ test for test in self . get_service_tests ( service_id ) if test . link . endswith ( f \"/ { test_name } \" ) ] # pylint: disable=line-too-long if not test_links : return None if len ( test_links ) != 1 : self . logger . debug ( \"Too many tests? %s \" , test_links ) test_name = test_links [ 0 ] . name self . logger . debug ( \"Running %s \" , test_name ) if test_method == \"get\" : return self . request_get_json ( url = test_links [ 0 ] . link ) result : Dict [ str , Any ] = self . request_post ( url = test_links [ 0 ] . link ) . json () return result","title":"run_test()"},{"location":"aussiebb/#aussiebb.AussieBB.service_boltons","text":"Pulls addons associated with the service. Keys: ['id', 'name', 'description', 'costCents', 'additionalNote', 'active'] Example data: [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] Source code in aussiebb/__init__.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 def service_boltons ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls addons associated with the service. Keys: `['id', 'name', 'description', 'costCents', 'additionalNote', 'active']` Example data: ``` [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] ``` \"\"\" url = self . get_url ( \"service_boltons\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url )","title":"service_boltons()"},{"location":"aussiebb/#aussiebb.AussieBB.service_datablocks","text":"Pulls datablocks associated with the service. Keys: ['current', 'available'] Example data: { \"current\": [], \"available\": [] } Source code in aussiebb/__init__.py 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 def service_datablocks ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls datablocks associated with the service. Keys: `['current', 'available']` Example data: ``` { \"current\": [], \"available\": [] } ``` \"\"\" url = self . get_url ( \"service_datablocks\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url )","title":"service_datablocks()"},{"location":"aussiebb/#aussiebb.AussieBB.service_outages","text":"Pulls outages associated with a service. Keys: ['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages'] ``` Source code in aussiebb/__init__.py 390 391 392 393 394 395 396 397 398 399 def service_outages ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls outages associated with a service. Keys: `['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages']` ``` \"\"\" url = self . get_url ( \"service_outages\" , { \"service_id\" : service_id }) result = AussieBBOutage . parse_obj ( self . request_get_json ( url = url )) return result . dict ()","title":"service_outages()"},{"location":"aussiebb/#aussiebb.AussieBB.service_plans","text":"Pulls the plan data for a given service. Keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] Source code in aussiebb/__init__.py 381 382 383 384 385 386 387 388 def service_plans ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls the plan data for a given service. Keys: `['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds']` \"\"\" url = self . get_url ( \"service_plans\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url )","title":"service_plans()"},{"location":"aussiebb/#aussiebb.AussieBB.support_tickets","text":"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] Source code in aussiebb/__init__.py 453 454 455 456 457 458 459 460 def support_tickets ( self ) -> Dict [ str , Any ]: \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"support_tickets\" ) return self . request_get_json ( url = url )","title":"support_tickets()"},{"location":"aussiebb/#aussiebb.AussieBB.telephony_usage","text":"Pulls the telephony usage associated with the service. Keys: ['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical'] Example data: {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} Source code in aussiebb/__init__.py 439 440 441 442 443 444 445 446 447 448 449 450 451 def telephony_usage ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls the telephony usage associated with the service. Keys: `['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical']` Example data: ``` {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} ``` \"\"\" url = self . get_url ( \"telephony_usage\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url )","title":"telephony_usage()"},{"location":"aussiebb/#aussiebb.AussieBB.test_line_state","text":"Tests the line state for a given service ID Source code in aussiebb/__init__.py 340 341 342 343 344 345 346 347 348 349 350 def test_line_state ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Tests the line state for a given service ID\"\"\" tests = self . get_service_tests ( service_id ) url = self . get_url ( \"test_line_state\" , { \"service_id\" : service_id }) self . is_valid_test ( url , tests ) self . logger . debug ( \"Testing line state, can take a few seconds...\" ) response = self . request_post ( url = url ) result : Dict [ str , Any ] = response . json () return result","title":"test_line_state()"},{"location":"release/","text":"Doing a release Commit things Ensure the version's bumped in pyproject.toml Do the tag: git tag -a v0.0.10 -m 'Lint all the things' Check the tag showed up: git tag Check the tag: git show v0.0.10 Push the tag: git push origin v0.0.10 Draft a release on Github Publish to pypi: poetry publish","title":"Releasing"},{"location":"release/#doing-a-release","text":"Commit things Ensure the version's bumped in pyproject.toml Do the tag: git tag -a v0.0.10 -m 'Lint all the things' Check the tag showed up: git tag Check the tag: git show v0.0.10 Push the tag: git push origin v0.0.10 Draft a release on Github Publish to pypi: poetry publish","title":"Doing a release"}]}
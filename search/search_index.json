{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pyAussieBB This is a very simple module for interacting with the Aussie Broadband APIs. Usage pip install --user pyaussiebb python >>> from aussiebb import AussieBB >>> account = AussieBB(username, password) >>> account.get_services() [{allyourservicedetails}] For more, check out the docs. AsyncIO version You can replace from aussiebb import AussieBB with from aussiebb.asyncio import AussieBB and you'll get an aiohttp -powered version. The only difference in this case is that you have to explicitly call login() for reasons. If you hit the rate limit it'll raise a RateLimit exception. I haven't put that functionality into the blocking version yet, since ... that tends not to hit it. \ud83e\udd23 Development Example service tests I've seen All the \"endpoints\" below should be tacked onto aussiebb.const.BASEURL['api'] . Warning: /nbn/{service_id}/connection seems to have both a GET and POST method endpoint - tests on other endpoints may be similar. These can be run by using AussieBB.run_test() with the string after the last forward-slash as the \"test\" - ie, connection or linestate . HFC These are entirely untested so far. Endpoint Method Name Description /nbn/{service_id}/connection Probably GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/loopback Probably POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/ntdstatus Probably POST NTD Status An NTD Status will show you the operational state of the Network Termination Device (NTD). The test will also show if the NTD is detecting the wired connection from your router. FTTC Endpoint Method Name Description /nbn/{service_id}/connection GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/dpuportreset Probably POST DPU Port Reset Reset the Port on the DPU (Distribution Point Unit) along with clearing any errors that maybe causing issues with connectivity. /tests/{service_id}/dpuportstatus POST DPU Port Status A DPU (Distribution Point Unit) port status will show if the NCD (Network Connection Device) is providing power to the DPU. It will also state if the NCD (Network Connection Device) is in sync. /tests/{service_id}/dpustatus POST DPU Status This will provide if the DPU (Distribution Point Unit) is currently being powered. /tests/{service_id}/loopback POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/ncdportreset Probably POST NCD Port Reset Reset the gateway port on your NCD (Network Connection Device). /tests/{service_id}/ncdreset Probably POST NCD Reset This will remotely restart your Network Termination Device. FTTN Endpoint Method Name Description /nbn/{service_id}/connection GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/linestate POST Line State A line state test will determine if you have \u201csync\u201d (connection) to the node. If the service is in sync this test will also return your maximum and current attainable transfer rate. /tests/{service_id}/loopback POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/portreset Probably POST Port Reset This will reset the connection from the Node and also clear errors that may be causing issues with gaining sync. /tests/{service_id}/stabilityprofile Probably POST Stability Profile This will apply changes to your FTTN service including allowing increased noise to occur before making the connection unstable. This will cause your speeds to degrade as a result, but in turn making the service more stable. For NBN to investigate a fault this profile needs to be applied and a minimum of 5 dropouts recorded over a 24hr period on NBN's systems before a dropout fault can be raised FTTP These are as-yet untested. Endpoint Method Name Description /nbn/{service_id}/connection Probably GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/loopback Probably POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/portreset Probably POST Port Reset This will reset the connection from the Node and also clear errors that may be causing issues with gaining sync. /tests/{service_id}/unidstatus Probably POST UNI-D Status UNI-D Status will show if the UNI-D port you are currently using has a router connected to it. This will also provide the Link speed your router and UNI-D port are connected at Eg, 100mbit or 1gbit. You will also see the MAC address of the currently connected router. Changelog See CHANGELOG.md","title":"Home"},{"location":"#pyaussiebb","text":"This is a very simple module for interacting with the Aussie Broadband APIs.","title":"pyAussieBB"},{"location":"#usage","text":"pip install --user pyaussiebb python >>> from aussiebb import AussieBB >>> account = AussieBB(username, password) >>> account.get_services() [{allyourservicedetails}] For more, check out the docs.","title":"Usage"},{"location":"#asyncio-version","text":"You can replace from aussiebb import AussieBB with from aussiebb.asyncio import AussieBB and you'll get an aiohttp -powered version. The only difference in this case is that you have to explicitly call login() for reasons. If you hit the rate limit it'll raise a RateLimit exception. I haven't put that functionality into the blocking version yet, since ... that tends not to hit it. \ud83e\udd23","title":"AsyncIO version"},{"location":"#development","text":"","title":"Development"},{"location":"#example-service-tests-ive-seen","text":"All the \"endpoints\" below should be tacked onto aussiebb.const.BASEURL['api'] . Warning: /nbn/{service_id}/connection seems to have both a GET and POST method endpoint - tests on other endpoints may be similar. These can be run by using AussieBB.run_test() with the string after the last forward-slash as the \"test\" - ie, connection or linestate .","title":"Example service tests I've seen"},{"location":"#hfc","text":"These are entirely untested so far. Endpoint Method Name Description /nbn/{service_id}/connection Probably GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/loopback Probably POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/ntdstatus Probably POST NTD Status An NTD Status will show you the operational state of the Network Termination Device (NTD). The test will also show if the NTD is detecting the wired connection from your router.","title":"HFC"},{"location":"#fttc","text":"Endpoint Method Name Description /nbn/{service_id}/connection GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/dpuportreset Probably POST DPU Port Reset Reset the Port on the DPU (Distribution Point Unit) along with clearing any errors that maybe causing issues with connectivity. /tests/{service_id}/dpuportstatus POST DPU Port Status A DPU (Distribution Point Unit) port status will show if the NCD (Network Connection Device) is providing power to the DPU. It will also state if the NCD (Network Connection Device) is in sync. /tests/{service_id}/dpustatus POST DPU Status This will provide if the DPU (Distribution Point Unit) is currently being powered. /tests/{service_id}/loopback POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/ncdportreset Probably POST NCD Port Reset Reset the gateway port on your NCD (Network Connection Device). /tests/{service_id}/ncdreset Probably POST NCD Reset This will remotely restart your Network Termination Device.","title":"FTTC"},{"location":"#fttn","text":"Endpoint Method Name Description /nbn/{service_id}/connection GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/linestate POST Line State A line state test will determine if you have \u201csync\u201d (connection) to the node. If the service is in sync this test will also return your maximum and current attainable transfer rate. /tests/{service_id}/loopback POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/portreset Probably POST Port Reset This will reset the connection from the Node and also clear errors that may be causing issues with gaining sync. /tests/{service_id}/stabilityprofile Probably POST Stability Profile This will apply changes to your FTTN service including allowing increased noise to occur before making the connection unstable. This will cause your speeds to degrade as a result, but in turn making the service more stable. For NBN to investigate a fault this profile needs to be applied and a minimum of 5 dropouts recorded over a 24hr period on NBN's systems before a dropout fault can be raised","title":"FTTN"},{"location":"#fttp","text":"These are as-yet untested. Endpoint Method Name Description /nbn/{service_id}/connection Probably GET Check Connection Check to see if your service is currently connected /nbn/{service_id}/connection Probably POST Kick Connection Kick your current session and force your device to reauthenticate /tests/{service_id}/loopback Probably POST Loopback Test This will test the connectivity between the point NBN\u2019s network transitions to ours and to the closest point to your property. Usually either the Network Termination Device or Node. /tests/{service_id}/portreset Probably POST Port Reset This will reset the connection from the Node and also clear errors that may be causing issues with gaining sync. /tests/{service_id}/unidstatus Probably POST UNI-D Status UNI-D Status will show if the UNI-D port you are currently using has a router connected to it. This will also provide the Link speed your router and UNI-D port are connected at Eg, 100mbit or 1gbit. You will also see the MAC address of the currently connected router.","title":"FTTP"},{"location":"#changelog","text":"See CHANGELOG.md","title":"Changelog"},{"location":"CHANGELOG/","text":"CHANGELOG v0.0.12 (in development) Added pydantic as a dependency, which allows for better type checking. Rewrote a bunch of the tests because the bike shed needed to be green and driven by JSON. v0.0.11 Added aussiebb.exceptions.UnrecognisedServiceType and some quick validation when you run get_usage so it doesn't break. Added some more testing around this. Fixed it so you can pass a session object to the non-asyncio AussieBB Added \"use_cached\" to get_services calls Added some mock data in aussiebb.const.TEST_MOCKDATA v0.0.10 Major change: Minimum supported Python is now 3.9 re-defined the API Classes as children of a base class (aussiebb.baseclass.BaseClass). added significantly better typing to inputs/responses. removed all the usage of inspect . moved from setup.py to Poetry for build/packaging. removed loguru dependency, class init now takes a logger as an option or uses python default logging if not. Also removed _debug_print from async version. added NBN_TYPES and PHONE_TYPES to aussiebb.const, to allow one to check if the service matches a known identifier for \"phone\" (mobile/VOIP) or \"NBN\" (internet) types - this matters when parsing the resulting service info. added test and fixed result of the asyncio get_service_tests function v0.0.8 renamed serviceid to service_id to match the api added request_get_json to the sync class added telephony_usage added get_appointment which gets service appointments updated get_usage so it checks the service list and will return telephony data if it's a PhoneMobile service abstracted how URLS are generated so I don't have to keep adding them twice added a filter on get_services which allows you to filter by type 0.0.7 Added the following new functions: account_transactions , billing_invoice , service_outages , service_boltons , service_datablocks , support_tickets , account contacts . Renamed get_service_plans to service_plans v0.0.6 Fixed rate limiting v0.0.5 Fixing rate limiting Didn't actually fix it... 0.0.4 Added asyncio submodule, split constants and exceptions out into their own files/modules. 0.0.3 Added get_service_plans so the gigabit-desperate crowd can check for their new hotness.","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"CHANGELOG"},{"location":"CHANGELOG/#v0012-in-development","text":"Added pydantic as a dependency, which allows for better type checking. Rewrote a bunch of the tests because the bike shed needed to be green and driven by JSON.","title":"v0.0.12 (in development)"},{"location":"CHANGELOG/#v0011","text":"Added aussiebb.exceptions.UnrecognisedServiceType and some quick validation when you run get_usage so it doesn't break. Added some more testing around this. Fixed it so you can pass a session object to the non-asyncio AussieBB Added \"use_cached\" to get_services calls Added some mock data in aussiebb.const.TEST_MOCKDATA","title":"v0.0.11"},{"location":"CHANGELOG/#v0010","text":"","title":"v0.0.10"},{"location":"CHANGELOG/#major-change-minimum-supported-python-is-now-39","text":"re-defined the API Classes as children of a base class (aussiebb.baseclass.BaseClass). added significantly better typing to inputs/responses. removed all the usage of inspect . moved from setup.py to Poetry for build/packaging. removed loguru dependency, class init now takes a logger as an option or uses python default logging if not. Also removed _debug_print from async version. added NBN_TYPES and PHONE_TYPES to aussiebb.const, to allow one to check if the service matches a known identifier for \"phone\" (mobile/VOIP) or \"NBN\" (internet) types - this matters when parsing the resulting service info. added test and fixed result of the asyncio get_service_tests function","title":"Major change: Minimum supported Python is now 3.9"},{"location":"CHANGELOG/#v008","text":"renamed serviceid to service_id to match the api added request_get_json to the sync class added telephony_usage added get_appointment which gets service appointments updated get_usage so it checks the service list and will return telephony data if it's a PhoneMobile service abstracted how URLS are generated so I don't have to keep adding them twice added a filter on get_services which allows you to filter by type","title":"v0.0.8"},{"location":"CHANGELOG/#007","text":"Added the following new functions: account_transactions , billing_invoice , service_outages , service_boltons , service_datablocks , support_tickets , account contacts . Renamed get_service_plans to service_plans","title":"0.0.7"},{"location":"CHANGELOG/#v006","text":"Fixed rate limiting","title":"v0.0.6"},{"location":"CHANGELOG/#v005","text":"Fixing rate limiting Didn't actually fix it...","title":"v0.0.5"},{"location":"CHANGELOG/#004","text":"Added asyncio submodule, split constants and exceptions out into their own files/modules.","title":"0.0.4"},{"location":"CHANGELOG/#003","text":"Added get_service_plans so the gigabit-desperate crowd can check for their new hotness.","title":"0.0.3"},{"location":"aussiebb/","text":"A class for interacting with Aussie Broadband APIs AussieBB ( BaseClass ) A class for interacting with Aussie Broadband APIs Source code in aussiebb/__init__.py class AussieBB ( BaseClass ): \"\"\"A class for interacting with Aussie Broadband APIs\"\"\" def __init__ ( self , username : str , password : str , debug : bool = False , services_cache_time : int = 28800 , session : Optional [ requests . sessions . Session ] = None , ): \"\"\"Setup function ``` @param username: str - username for Aussie Broadband account @param password: str - password for Aussie Broadband account @param debug: bool - debug mode @param services_cache_time: int - seconds between caching get_services() - defaults to 8 hours @param session : requests.session - session object ``` \"\"\" super () . __init__ ( username , password , debug , services_cache_time ) if session is None : self . session = requests . Session () else : self . session = session def login ( self , depth : int = 0 ) -> bool : \"\"\"Logs into the account and caches the cookie.\"\"\" if depth > 2 : raise RecursiveDepth ( \"Login recursion depth > 2\" ) self . logger . debug ( \"Logging in...\" ) url = BASEURL [ \"login\" ] payload = { \"username\" : self . username , \"password\" : self . password , } headers = default_headers () response = self . session . post ( url , headers = headers , json = payload , ) response . raise_for_status () jsondata = response . json () return self . _handle_login_response ( response . status_code , jsondata , response . cookies ) def do_login_check ( self , skip_login_check : bool ) -> None : \"\"\"checks if we're skipping the login check and logs in if necessary\"\"\" if not skip_login_check : self . logger . debug ( \"skip_login_check false\" ) if self . _has_token_expired (): self . logger . debug ( \"token has expired, logging in...\" ) self . login () def request_get ( # type: ignore self , url : str , skip_login_check : bool = False , cookies : Optional [ Any ] = None , ** kwargs , ): \"\"\"Performs a GET request and logs in first if needed. Returns the `requests.Response` object.\"\"\" self . do_login_check ( skip_login_check ) if cookies is None : cookies = { \"myaussie_cookie\" : self . myaussie_cookie } response = self . session . get ( url = url , cookies = cookies , ** kwargs ) response . raise_for_status () return response def request_get_list ( self , skip_login_check : bool = False , ** kwargs : Any ) -> List [ Any ]: \"\"\"Performs a GET request and logs in first if needed. Returns a list from the response. \"\"\" if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } self . do_login_check ( skip_login_check ) response = self . session . get ( ** kwargs ) response . raise_for_status () result : List [ Any ] = response . json () return result def request_get_json ( self , url : str , skip_login_check : bool = False , ** kwargs : Dict [ str , Any ], ): \"\"\"Performs a GET request and logs in first if needed. Returns a dict of the JSON response. \"\"\" if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } self . do_login_check ( skip_login_check ) response = self . session . get ( url , ** kwargs ) # type: ignore response . raise_for_status () return response . json () def request_post ( self , url : str , skip_login_check : bool = False , ** kwargs : Dict [ str , Any ] ): \"\"\"Performs a POST request and logs in first if needed.\"\"\" self . do_login_check ( skip_login_check ) if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } response = self . session . post ( url = url , headers = kwargs . get ( \"headers\" , default_headers ()), ** kwargs , # type: ignore ) response . raise_for_status () return response def get_customer_details ( self ) -> Dict [ str , Any ]: \"\"\"Grabs the customer details. Returns a dict\"\"\" url = self . get_url ( \"get_customer_details\" ) querystring = { \"v\" : \"2\" } responsedata : Dict [ str , Any ] = self . request_get_json ( url = url , params = querystring , ) return responsedata @property def referral_code ( self ): \"\"\"returns the referral code, which is just the customer number\"\"\" response = self . get_customer_details () if \"customer_number\" not in response : raise ValueError ( \"Couldn't get customer_number from customer_details call.\" ) return int ( response [ \"customer_number\" ]) def _check_reload_cached_services ( self ) -> bool : \"\"\"If the age of the service data caching is too old, clear it and re-poll. Returns bool - if it reloaded the cache. \"\"\" if not self . services : self . get_services ( use_cached = False ) return True cache_expiry = self . services_last_update + self . services_cache_time if time () >= cache_expiry : self . get_services ( use_cached = False ) return True return False def get_services ( self , page : int = 1 , servicetypes : Optional [ List [ str ]] = None , use_cached : bool = False , ) -> Optional [ List [ Dict [ str , Any ]]]: \"\"\"Returns a `list` of `dicts` of services associated with the account. If you want a specific kind of service, or services, provide a list of matching strings in servicetypes. If you want to use cached data, call it with `use_cached=True` \"\"\" if use_cached : self . logger . debug ( \"Using cached data for get_services.\" ) self . _check_reload_cached_services () else : url = self . get_url ( \"get_services\" ) services_list : List [ Dict [ str , Any ]] = [] while True : params = { \"page\" : page } responsedata = self . request_get_json ( url = url , params = params ) servicedata = GetServicesResponse . parse_obj ( responsedata ) for link in servicedata . data : services_list . append ( link ) if servicedata . links . next is None : break url = servicedata . links . next page = servicedata . meta [ \"current_page\" ] self . services = services_list self . services_last_update = int ( time ()) # only filter if we need to if servicetypes is not None : self . logger . debug ( \"Filtering services based on provided list: %s \" , servicetypes ) filtered_responsedata : List [ Dict [ str , Any ]] = [] if self . services is not None : for service in self . services : if \"type\" not in service : raise ValueError ( f \"No type field in service info: { service } \" ) if service [ \"type\" ] in servicetypes : filtered_responsedata . append ( service ) else : self . logger . debug ( \"Skipping as type== %s - %s \" , service [ \"type\" ], service ) return filtered_responsedata return self . services def account_transactions ( self ) -> Dict [ str , AccountTransaction ]: \"\"\"Pulls the data for transactions on your account. Returns a dict where the key is the month and year of the transaction. Keys: `['id', 'type', 'time', 'description', 'amountCents', 'runningBalanceCents']` Example output: ``` json \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], ``` \"\"\" url = self . get_url ( \"account_transactions\" ) result : Dict [ str , AccountTransaction ] = self . request_get_json ( url = url ) return result def billing_invoice ( self , invoice_id : int ) -> Dict [ str , Any ]: \"\"\"Downloads an invoice This returns the bare response object, parsing the result is an exercise for the consumer. It's a PDF file. \"\"\" url = self . get_url ( \"billing_invoice\" , { \"invoice_id\" : invoice_id }) result : Dict [ str , Any ] = self . request_get_json ( url = url ) return result def account_paymentplans ( self ): \"\"\"Returns a dict of payment plans for an account\"\"\" url = self . get_url ( \"account_paymentplans\" ) return self . request_get_json ( url = url ) def get_usage ( self , service_id : int , use_cached : bool = True ) -> Dict [ str , Any ]: \"\"\" Returns a dict of usage for a service. If it's a telephony service (`type=PhoneMobile`) it'll pull from the telephony endpoint. \"\"\" if self . services is None : self . get_services ( use_cached = use_cached ) if self . services is not None : for service in self . services : if service_id == service [ \"service_id\" ]: # throw an error if we're trying to parse something we can't self . validate_service_type ( service ) if service [ \"type\" ] in PHONE_TYPES : return self . telephony_usage ( service_id ) url = self . get_url ( \"get_usage\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) return {} def get_service_tests ( self , service_id : int ) -> List [ ServiceTest ]: \"\"\"Gets the available tests for a given service ID Returns list of dicts Example data: ``` [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] ``` This has a habit of throwing 400 errors if you query a VOIP service... \"\"\" url = self . get_url ( \"get_service_tests\" , { \"service_id\" : service_id }) results : List [ ServiceTest ] = self . request_get_json ( url = url ) return results def get_test_history ( self , service_id : int ): \"\"\"Gets the available tests for a given service ID Returns a list of dicts with tests which have been run \"\"\" url = self . get_url ( \"get_test_history\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) def test_line_state ( self , service_id : int ): \"\"\"Tests the line state for a given service ID\"\"\" # TODO: check if this is valid for the service id url = self . get_url ( \"test_line_state\" , { \"service_id\" : service_id }) self . logger . debug ( \"Testing line state, can take a few seconds...\" ) response = self . request_post ( url = url ) return response . json () def run_test ( self , service_id : int , test_name : str , test_method : str = \"post\" ): \"\"\"Run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis - 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' - 'status' of 'Completed' means you've got the full response \"\"\" test_links = [ test for test in self . get_service_tests ( service_id ) if test . get ( \"link\" , \"\" ) . endswith ( f \"/ { test_name } \" ) ] # pylint: disable=line-too-long if not test_links : return False if len ( test_links ) != 1 : self . logger . debug ( \"Too many tests? %s \" , test_links ) test_name = test_links [ 0 ][ \"name\" ] self . logger . debug ( \"Running %s \" , test_name ) if test_method == \"get\" : return self . request_get_json ( url = test_links [ 0 ][ \"link\" ]) return self . request_post ( url = test_links [ 0 ][ \"link\" ]) . json () def service_plans ( self , service_id : int ): \"\"\"Pulls the plan data for a given service. Keys: `['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds']` \"\"\" url = self . get_url ( \"service_plans\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) def service_outages ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls outages associated with a service. Keys: `['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages']` ``` \"\"\" url = self . get_url ( \"service_outages\" , { \"service_id\" : service_id }) result = AussieBBOutage . parse_obj ( self . request_get_json ( url = url )) return result . dict () def service_boltons ( self , service_id : int ): \"\"\"Pulls addons associated with the service. Keys: `['id', 'name', 'description', 'costCents', 'additionalNote', 'active']` Example data: ``` [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] ``` \"\"\" url = self . get_url ( \"service_boltons\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) def service_datablocks ( self , service_id : int ): \"\"\"Pulls datablocks associated with the service. Keys: `['current', 'available']` Example data: ``` { \"current\": [], \"available\": [] } ``` \"\"\" url = self . get_url ( \"service_datablocks\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) def telephony_usage ( self , service_id : int ): \"\"\"Pulls the telephony usage associated with the service. Keys: `['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical']` Example data: ``` {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} ``` \"\"\" url = self . get_url ( \"telephony_usage\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) def support_tickets ( self ): \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"support_tickets\" ) return self . request_get_json ( url = url ) def get_appointment ( self , ticketid : int ): \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"get_appointment\" , { \"ticketid\" : ticketid }) return self . request_get_json ( url = url ) def account_contacts ( self ) -> List [ AccountContact ]: \"\"\"Pulls the contacts with the account, returns a list of dicts Dict keys: `['id', 'first_name', 'last_name', 'email', 'dob', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact']` \"\"\" url = self . get_url ( \"account_contacts\" ) response = self . request_get_json ( url = url ) return [ AccountContact . parse_obj ( contact ) for contact in response ] def get_orders ( self ): \"\"\"pulls the outstanding orders for an account\"\"\" url = self . get_url ( \"get_orders\" ) result = OrderResponse ( ** self . request_get_json ( url = url )) return result . dict () def get_order ( self , order_id : int ) -> OrderDetailResponse : \"\"\"gets a specific order\"\"\" url = self . get_url ( \"get_order\" , { \"order_id\" : order_id }) result = cast ( OrderDetailResponse , OrderDetailResponseModel ( ** self . request_get_json ( url = url )) . dict (), ) return result def get_voip_devices ( self , service_id : int ) -> List [ VOIPDevice ]: \"\"\"gets the devices associatd with a VOIP service\"\"\" url = self . get_url ( \"voip_devices\" , { \"service_id\" : service_id }) service_list : List [ VOIPDevice ] = [] for service in self . request_get_json ( url = url ): service_list . append ( VOIPDevice . parse_obj ( service )) return service_list def get_voip_service ( self , service_id : int ) -> VOIPService : \"\"\"gets the details of a VOIP service\"\"\" url = self . get_url ( \"voip_service\" , { \"service_id\" : service_id }) return VOIPService . parse_obj ( self . request_get_json ( url = url )) referral_code property readonly returns the referral code, which is just the customer number __init__ ( self , username , password , debug = False , services_cache_time = 28800 , session = None ) special Setup function @param username: str - username for Aussie Broadband account @param password: str - password for Aussie Broadband account @param debug: bool - debug mode @param services_cache_time: int - seconds between caching get_services() - defaults to 8 hours @param session : requests.session - session object Source code in aussiebb/__init__.py def __init__ ( self , username : str , password : str , debug : bool = False , services_cache_time : int = 28800 , session : Optional [ requests . sessions . Session ] = None , ): \"\"\"Setup function ``` @param username: str - username for Aussie Broadband account @param password: str - password for Aussie Broadband account @param debug: bool - debug mode @param services_cache_time: int - seconds between caching get_services() - defaults to 8 hours @param session : requests.session - session object ``` \"\"\" super () . __init__ ( username , password , debug , services_cache_time ) if session is None : self . session = requests . Session () else : self . session = session account_contacts ( self ) Pulls the contacts with the account, returns a list of dicts Dict keys: ['id', 'first_name', 'last_name', 'email', 'dob', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact'] Source code in aussiebb/__init__.py def account_contacts ( self ) -> List [ AccountContact ]: \"\"\"Pulls the contacts with the account, returns a list of dicts Dict keys: `['id', 'first_name', 'last_name', 'email', 'dob', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact']` \"\"\" url = self . get_url ( \"account_contacts\" ) response = self . request_get_json ( url = url ) return [ AccountContact . parse_obj ( contact ) for contact in response ] account_paymentplans ( self ) Returns a dict of payment plans for an account Source code in aussiebb/__init__.py def account_paymentplans ( self ): \"\"\"Returns a dict of payment plans for an account\"\"\" url = self . get_url ( \"account_paymentplans\" ) return self . request_get_json ( url = url ) account_transactions ( self ) Pulls the data for transactions on your account. Returns a dict where the key is the month and year of the transaction. Keys: ['id', 'type', 'time', 'description', 'amountCents', 'runningBalanceCents'] Example output: \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], Source code in aussiebb/__init__.py def account_transactions ( self ) -> Dict [ str , AccountTransaction ]: \"\"\"Pulls the data for transactions on your account. Returns a dict where the key is the month and year of the transaction. Keys: `['id', 'type', 'time', 'description', 'amountCents', 'runningBalanceCents']` Example output: ``` json \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], ``` \"\"\" url = self . get_url ( \"account_transactions\" ) result : Dict [ str , AccountTransaction ] = self . request_get_json ( url = url ) return result billing_invoice ( self , invoice_id ) Downloads an invoice This returns the bare response object, parsing the result is an exercise for the consumer. It's a PDF file. Source code in aussiebb/__init__.py def billing_invoice ( self , invoice_id : int ) -> Dict [ str , Any ]: \"\"\"Downloads an invoice This returns the bare response object, parsing the result is an exercise for the consumer. It's a PDF file. \"\"\" url = self . get_url ( \"billing_invoice\" , { \"invoice_id\" : invoice_id }) result : Dict [ str , Any ] = self . request_get_json ( url = url ) return result do_login_check ( self , skip_login_check ) checks if we're skipping the login check and logs in if necessary Source code in aussiebb/__init__.py def do_login_check ( self , skip_login_check : bool ) -> None : \"\"\"checks if we're skipping the login check and logs in if necessary\"\"\" if not skip_login_check : self . logger . debug ( \"skip_login_check false\" ) if self . _has_token_expired (): self . logger . debug ( \"token has expired, logging in...\" ) self . login () get_appointment ( self , ticketid ) Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] Source code in aussiebb/__init__.py def get_appointment ( self , ticketid : int ): \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"get_appointment\" , { \"ticketid\" : ticketid }) return self . request_get_json ( url = url ) get_customer_details ( self ) Grabs the customer details. Returns a dict Source code in aussiebb/__init__.py def get_customer_details ( self ) -> Dict [ str , Any ]: \"\"\"Grabs the customer details. Returns a dict\"\"\" url = self . get_url ( \"get_customer_details\" ) querystring = { \"v\" : \"2\" } responsedata : Dict [ str , Any ] = self . request_get_json ( url = url , params = querystring , ) return responsedata get_order ( self , order_id ) gets a specific order Source code in aussiebb/__init__.py def get_order ( self , order_id : int ) -> OrderDetailResponse : \"\"\"gets a specific order\"\"\" url = self . get_url ( \"get_order\" , { \"order_id\" : order_id }) result = cast ( OrderDetailResponse , OrderDetailResponseModel ( ** self . request_get_json ( url = url )) . dict (), ) return result get_orders ( self ) pulls the outstanding orders for an account Source code in aussiebb/__init__.py def get_orders ( self ): \"\"\"pulls the outstanding orders for an account\"\"\" url = self . get_url ( \"get_orders\" ) result = OrderResponse ( ** self . request_get_json ( url = url )) return result . dict () get_service_tests ( self , service_id ) Gets the available tests for a given service ID Returns list of dicts Example data: [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] This has a habit of throwing 400 errors if you query a VOIP service... Source code in aussiebb/__init__.py def get_service_tests ( self , service_id : int ) -> List [ ServiceTest ]: \"\"\"Gets the available tests for a given service ID Returns list of dicts Example data: ``` [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] ``` This has a habit of throwing 400 errors if you query a VOIP service... \"\"\" url = self . get_url ( \"get_service_tests\" , { \"service_id\" : service_id }) results : List [ ServiceTest ] = self . request_get_json ( url = url ) return results get_services ( self , page = 1 , servicetypes = None , use_cached = False ) Returns a list of dicts of services associated with the account. If you want a specific kind of service, or services, provide a list of matching strings in servicetypes. If you want to use cached data, call it with use_cached=True Source code in aussiebb/__init__.py def get_services ( self , page : int = 1 , servicetypes : Optional [ List [ str ]] = None , use_cached : bool = False , ) -> Optional [ List [ Dict [ str , Any ]]]: \"\"\"Returns a `list` of `dicts` of services associated with the account. If you want a specific kind of service, or services, provide a list of matching strings in servicetypes. If you want to use cached data, call it with `use_cached=True` \"\"\" if use_cached : self . logger . debug ( \"Using cached data for get_services.\" ) self . _check_reload_cached_services () else : url = self . get_url ( \"get_services\" ) services_list : List [ Dict [ str , Any ]] = [] while True : params = { \"page\" : page } responsedata = self . request_get_json ( url = url , params = params ) servicedata = GetServicesResponse . parse_obj ( responsedata ) for link in servicedata . data : services_list . append ( link ) if servicedata . links . next is None : break url = servicedata . links . next page = servicedata . meta [ \"current_page\" ] self . services = services_list self . services_last_update = int ( time ()) # only filter if we need to if servicetypes is not None : self . logger . debug ( \"Filtering services based on provided list: %s \" , servicetypes ) filtered_responsedata : List [ Dict [ str , Any ]] = [] if self . services is not None : for service in self . services : if \"type\" not in service : raise ValueError ( f \"No type field in service info: { service } \" ) if service [ \"type\" ] in servicetypes : filtered_responsedata . append ( service ) else : self . logger . debug ( \"Skipping as type== %s - %s \" , service [ \"type\" ], service ) return filtered_responsedata return self . services get_test_history ( self , service_id ) Gets the available tests for a given service ID Returns a list of dicts with tests which have been run Source code in aussiebb/__init__.py def get_test_history ( self , service_id : int ): \"\"\"Gets the available tests for a given service ID Returns a list of dicts with tests which have been run \"\"\" url = self . get_url ( \"get_test_history\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) get_usage ( self , service_id , use_cached = True ) Returns a dict of usage for a service. If it's a telephony service ( type=PhoneMobile ) it'll pull from the telephony endpoint. Source code in aussiebb/__init__.py def get_usage ( self , service_id : int , use_cached : bool = True ) -> Dict [ str , Any ]: \"\"\" Returns a dict of usage for a service. If it's a telephony service (`type=PhoneMobile`) it'll pull from the telephony endpoint. \"\"\" if self . services is None : self . get_services ( use_cached = use_cached ) if self . services is not None : for service in self . services : if service_id == service [ \"service_id\" ]: # throw an error if we're trying to parse something we can't self . validate_service_type ( service ) if service [ \"type\" ] in PHONE_TYPES : return self . telephony_usage ( service_id ) url = self . get_url ( \"get_usage\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) return {} get_voip_devices ( self , service_id ) gets the devices associatd with a VOIP service Source code in aussiebb/__init__.py def get_voip_devices ( self , service_id : int ) -> List [ VOIPDevice ]: \"\"\"gets the devices associatd with a VOIP service\"\"\" url = self . get_url ( \"voip_devices\" , { \"service_id\" : service_id }) service_list : List [ VOIPDevice ] = [] for service in self . request_get_json ( url = url ): service_list . append ( VOIPDevice . parse_obj ( service )) return service_list get_voip_service ( self , service_id ) gets the details of a VOIP service Source code in aussiebb/__init__.py def get_voip_service ( self , service_id : int ) -> VOIPService : \"\"\"gets the details of a VOIP service\"\"\" url = self . get_url ( \"voip_service\" , { \"service_id\" : service_id }) return VOIPService . parse_obj ( self . request_get_json ( url = url )) login ( self , depth = 0 ) Logs into the account and caches the cookie. Source code in aussiebb/__init__.py def login ( self , depth : int = 0 ) -> bool : \"\"\"Logs into the account and caches the cookie.\"\"\" if depth > 2 : raise RecursiveDepth ( \"Login recursion depth > 2\" ) self . logger . debug ( \"Logging in...\" ) url = BASEURL [ \"login\" ] payload = { \"username\" : self . username , \"password\" : self . password , } headers = default_headers () response = self . session . post ( url , headers = headers , json = payload , ) response . raise_for_status () jsondata = response . json () return self . _handle_login_response ( response . status_code , jsondata , response . cookies ) request_get ( self , url , skip_login_check = False , cookies = None , ** kwargs ) Performs a GET request and logs in first if needed. Returns the requests.Response object. Source code in aussiebb/__init__.py def request_get ( # type: ignore self , url : str , skip_login_check : bool = False , cookies : Optional [ Any ] = None , ** kwargs , ): \"\"\"Performs a GET request and logs in first if needed. Returns the `requests.Response` object.\"\"\" self . do_login_check ( skip_login_check ) if cookies is None : cookies = { \"myaussie_cookie\" : self . myaussie_cookie } response = self . session . get ( url = url , cookies = cookies , ** kwargs ) response . raise_for_status () return response request_get_json ( self , url , skip_login_check = False , ** kwargs ) Performs a GET request and logs in first if needed. Returns a dict of the JSON response. Source code in aussiebb/__init__.py def request_get_json ( self , url : str , skip_login_check : bool = False , ** kwargs : Dict [ str , Any ], ): \"\"\"Performs a GET request and logs in first if needed. Returns a dict of the JSON response. \"\"\" if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } self . do_login_check ( skip_login_check ) response = self . session . get ( url , ** kwargs ) # type: ignore response . raise_for_status () return response . json () request_get_list ( self , skip_login_check = False , ** kwargs ) Performs a GET request and logs in first if needed. Returns a list from the response. Source code in aussiebb/__init__.py def request_get_list ( self , skip_login_check : bool = False , ** kwargs : Any ) -> List [ Any ]: \"\"\"Performs a GET request and logs in first if needed. Returns a list from the response. \"\"\" if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } self . do_login_check ( skip_login_check ) response = self . session . get ( ** kwargs ) response . raise_for_status () result : List [ Any ] = response . json () return result request_post ( self , url , skip_login_check = False , ** kwargs ) Performs a POST request and logs in first if needed. Source code in aussiebb/__init__.py def request_post ( self , url : str , skip_login_check : bool = False , ** kwargs : Dict [ str , Any ] ): \"\"\"Performs a POST request and logs in first if needed.\"\"\" self . do_login_check ( skip_login_check ) if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } response = self . session . post ( url = url , headers = kwargs . get ( \"headers\" , default_headers ()), ** kwargs , # type: ignore ) response . raise_for_status () return response run_test ( self , service_id , test_name , test_method = 'post' ) Run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' 'status' of 'Completed' means you've got the full response Source code in aussiebb/__init__.py def run_test ( self , service_id : int , test_name : str , test_method : str = \"post\" ): \"\"\"Run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis - 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' - 'status' of 'Completed' means you've got the full response \"\"\" test_links = [ test for test in self . get_service_tests ( service_id ) if test . get ( \"link\" , \"\" ) . endswith ( f \"/ { test_name } \" ) ] # pylint: disable=line-too-long if not test_links : return False if len ( test_links ) != 1 : self . logger . debug ( \"Too many tests? %s \" , test_links ) test_name = test_links [ 0 ][ \"name\" ] self . logger . debug ( \"Running %s \" , test_name ) if test_method == \"get\" : return self . request_get_json ( url = test_links [ 0 ][ \"link\" ]) return self . request_post ( url = test_links [ 0 ][ \"link\" ]) . json () service_boltons ( self , service_id ) Pulls addons associated with the service. Keys: ['id', 'name', 'description', 'costCents', 'additionalNote', 'active'] Example data: [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] Source code in aussiebb/__init__.py def service_boltons ( self , service_id : int ): \"\"\"Pulls addons associated with the service. Keys: `['id', 'name', 'description', 'costCents', 'additionalNote', 'active']` Example data: ``` [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] ``` \"\"\" url = self . get_url ( \"service_boltons\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) service_datablocks ( self , service_id ) Pulls datablocks associated with the service. Keys: ['current', 'available'] Example data: { \"current\": [], \"available\": [] } Source code in aussiebb/__init__.py def service_datablocks ( self , service_id : int ): \"\"\"Pulls datablocks associated with the service. Keys: `['current', 'available']` Example data: ``` { \"current\": [], \"available\": [] } ``` \"\"\" url = self . get_url ( \"service_datablocks\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) service_outages ( self , service_id ) Pulls outages associated with a service. Keys: ['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages'] ``` Source code in aussiebb/__init__.py def service_outages ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls outages associated with a service. Keys: `['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages']` ``` \"\"\" url = self . get_url ( \"service_outages\" , { \"service_id\" : service_id }) result = AussieBBOutage . parse_obj ( self . request_get_json ( url = url )) return result . dict () service_plans ( self , service_id ) Pulls the plan data for a given service. Keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] Source code in aussiebb/__init__.py def service_plans ( self , service_id : int ): \"\"\"Pulls the plan data for a given service. Keys: `['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds']` \"\"\" url = self . get_url ( \"service_plans\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) support_tickets ( self ) Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] Source code in aussiebb/__init__.py def support_tickets ( self ): \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"support_tickets\" ) return self . request_get_json ( url = url ) telephony_usage ( self , service_id ) Pulls the telephony usage associated with the service. Keys: ['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical'] Example data: {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} Source code in aussiebb/__init__.py def telephony_usage ( self , service_id : int ): \"\"\"Pulls the telephony usage associated with the service. Keys: `['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical']` Example data: ``` {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} ``` \"\"\" url = self . get_url ( \"telephony_usage\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) test_line_state ( self , service_id ) Tests the line state for a given service ID Source code in aussiebb/__init__.py def test_line_state ( self , service_id : int ): \"\"\"Tests the line state for a given service ID\"\"\" # TODO: check if this is valid for the service id url = self . get_url ( \"test_line_state\" , { \"service_id\" : service_id }) self . logger . debug ( \"Testing line state, can take a few seconds...\" ) response = self . request_post ( url = url ) return response . json () asyncio special aiohttp support for AussieBB AussieBB ( BaseClass ) aiohttp class for interacting with Aussie Broadband APIs Source code in aussiebb/asyncio/__init__.py class AussieBB ( BaseClass ): # pylint: disable=too-many-public-methods \"\"\"aiohttp class for interacting with Aussie Broadband APIs\"\"\" # pylint: disable=too-many-arguments def __init__ ( self , username : str , password : str , session : Optional [ aiohttp . client . ClientSession ] = None , debug : bool = False , services_cache_time : int = 28800 , ): \"\"\"Setup function ``` @param username: str - username for Aussie Broadband account @param password: str - password for Aussie Broadband account @param debug: bool - debug mode @param services_cache_time: int - seconds between caching get_services() - defaults to 8 hours ``` \"\"\" super () . __init__ ( username , password , debug , services_cache_time ) if not session : self . session = aiohttp . ClientSession () else : self . session = session async def login ( self , depth : int = 0 ) -> bool : \"\"\"Logs into the account and caches the cookie.\"\"\" if depth > 2 : raise RecursiveDepth ( \"Login recursion depth > 2\" ) self . logger . debug ( \"Logging in...\" ) url = BASEURL [ \"login\" ] if not self . _has_token_expired (): return True payload = { \"username\" : self . username , \"password\" : self . password , } headers = default_headers () async with self . session . post ( url = url , headers = headers , json = payload , ) as response : try : await self . handle_response_fail ( response ) jsondata = await response . json () except RateLimitException : return await self . login ( depth + 1 ) self . logger . debug ( \"Login response status: %s \" , response . status ) self . logger . debug ( \"Dumping login response: %s \" , json . dumps ( jsondata )) return self . _handle_login_response ( response . status , jsondata , response . cookies ) async def handle_response_fail ( self , response : ClientResponse , wait_on_rate_limit : bool = True , ) -> None : \"\"\"Handles response status codes. Tries to gracefully handle the rate limiting. ``` @param response - aiohttp.Response - the full response object @param wait_on_rate_limit - bool - if hitting a rate limit, async wait on the time limit ``` \"\"\" ratelimit_remaining = int ( response . headers . get ( \"x-ratelimit-remaining\" , - 1 )) self . logger . debug ( \"Rate limit header: %s \" , response . headers . get ( \"x-ratelimit-remaining\" , - 1 ) ) if ratelimit_remaining < 5 and wait_on_rate_limit : print ( \"Rate limit below 5, sleeping for 1 second.\" , file = sys . stderr ) await asyncio . sleep ( 1 ) if response . status == 422 : raise AuthenticationException ( await response . json ()) if response . status == 429 : jsondata = await response . json () self . logger . debug ( \"Dumping headers: %s \" , response . headers ) self . logger . debug ( \"Dumping response: %s \" , json . dumps ( jsondata , default = str )) delay = DEFAULT_BACKOFF_DELAY if \"Please try again in \" in str ( jsondata . get ( \"errors\" )): fallback_value = [ f \"default { DEFAULT_BACKOFF_DELAY } seconds\" ] delay = ( jsondata . get ( \"errors\" , {}) . get ( \"username\" , fallback_value )[ 0 ] . split ()[ - 2 ] ) # give it some extra time to cool off delay = int ( delay ) + 5 if 0 < delay < 1000 : self . logger . debug ( \"Found required rate limit delay: %s \" , delay ) delay = int ( delay ) else : self . logger . debug ( \"Couldn't parse rate limit delay, using default: %s \" , delay ) else : delay = DEFAULT_BACKOFF_DELAY self . logger . debug ( \"Couldn't parse delay, using default: %s \" , delay ) if wait_on_rate_limit : self . logger . debug ( \"Rate limit on Aussie API calls raised, sleeping for %s seconds.\" , delay , ) await asyncio . sleep ( delay ) raise RateLimitException ( jsondata ) response . raise_for_status () async def do_login_check ( self , skip_login_check : bool ) -> None : \"\"\"checks if we're skipping the login check and logs in if necessary\"\"\" if not skip_login_check : self . logger . debug ( \"skip_login_check false\" ) if self . _has_token_expired (): self . logger . debug ( \"token has expired, logging in...\" ) await self . login () async def request_get ( self , url : str , skip_login_check : bool = False , depth : int = 0 , ** kwargs : Dict [ str , Any ], ) -> ClientResponse : \"\"\"Performs a GET request and logs in first if needed.\"\"\" if depth > 2 : raise RecursiveDepth ( f \"depth: { depth } \" ) if self . session is None : self . session = aiohttp . ClientSession () await self . do_login_check ( skip_login_check ) if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } response = await self . session . get ( url = url , ** kwargs ) # type: ignore # async with self.session.get(url=url, **kwargs) as response: try : await self . handle_response_fail ( response ) await response . read () except RateLimitException : response = await self . request_get ( url = url , skip_login_check = skip_login_check , depth = depth , ** kwargs ) return response async def request_get_json ( self , skip_login_check : bool = False , ** kwargs ) -> Any : \"\"\"Performs a GET request and logs in first if needed. Returns a dict of the JSON response. \"\"\" depth = kwargs . get ( \"depth\" , 0 ) if depth > 2 : raise RecursiveDepth ( f \"depth: { depth } \" ) if self . session is None : self . session = aiohttp . ClientSession () await self . do_login_check ( skip_login_check ) if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } async with self . session . get ( ** kwargs ) as response : try : await self . handle_response_fail ( response ) jsondata = await response . json () except RateLimitException : jsondata = await self . request_get_json ( skip_login_check , ** kwargs ) return jsondata async def request_post_json ( self , url = str , depth : int = 0 , skip_login_check : bool = False , ** kwargs : Dict [ str , Any ], ) -> Dict [ str , Any ]: \"\"\"Performs a POST request and logs in first if needed. Returns a dict of the response data. \"\"\" if depth > 2 : raise RecursiveDepth ( f \"depth: { depth } \" ) if self . session is None : self . session = aiohttp . ClientSession () await self . do_login_check ( skip_login_check ) cookies = kwargs . get ( \"cookies\" , { \"myaussie_cookie\" : self . myaussie_cookie }) headers = kwargs . get ( \"headers\" , default_headers ()) async with self . session . post ( url = url , cookies = cookies , headers = headers ) as response : try : await self . handle_response_fail ( response ) jsondata : Dict [ str , Any ] = await response . json () except RateLimitException : jsondata = await self . request_post_json ( url = url , depth = depth + 1 , skip_login_check = skip_login_check , ** kwargs , ) return jsondata async def get_customer_details ( self ) -> Dict [ str , Any ]: \"\"\"Grabs the customer details. Returns a dict\"\"\" url = self . get_url ( \"get_customer_details\" ) params = { \"v\" : \"2\" } result : Dict [ str , Any ] = await self . request_get_json ( url = url , params = params , ) return result @property async def referral_code ( self ): \"\"\"returns the referral code, which is just the customer number\"\"\" response = await self . get_customer_details () if \"customer_number\" not in response : raise ValueError ( \"Couldn't get customer_number from customer_details call.\" ) return int ( response [ \"customer_number\" ]) async def _check_reload_cached_services ( self ) -> bool : \"\"\"If the age of the service data caching is too old, clear it and re-poll. Returns bool - if it reloaded the cache. \"\"\" if not self . services : await self . get_services ( use_cached = False ) return True cache_expiry = self . services_last_update + self . services_cache_time if time () >= cache_expiry : await self . get_services ( use_cached = False ) return True return False async def get_services ( self , page : int = 1 , servicetypes : Optional [ List [ str ]] = None , use_cached : bool = False , ): \"\"\"Returns a `list` of `dicts` of services associated with the account. If you want a specific kind of service, or services, provide a list of matching strings in servicetypes. If you want to use cached data, call it with `use_cached=True` \"\"\" if use_cached : self . logger . debug ( \"Using cached data for get_services.\" ) await self . _check_reload_cached_services () else : url = self . get_url ( \"get_services\" ) services_list : List [ Dict [ str , Any ]] = [] while True : params = { \"page\" : page } responsedata = await self . request_get_json ( url = url , params = params ) servicedata = GetServicesResponse . parse_obj ( responsedata ) for link in servicedata . data : services_list . append ( link ) if servicedata . links . next is None : break url = servicedata . links . next page = servicedata . meta [ \"current_page\" ] self . services = services_list self . services_last_update = int ( time ()) # TODO: validate the expected fields in the service (type, name, plan, description, service_id at a minimum) # only filter if we need to if servicetypes is not None : self . logger . debug ( \"Filtering services based on provided list: %s \" , servicetypes ) filtered_responsedata : List [ Any ] = [] if self . services is not None : for service in self . services : if \"type\" not in service : raise ValueError ( f \"No type field in service info: { service } \" ) if service [ \"type\" ] in servicetypes : filtered_responsedata . append ( service ) else : self . logger . debug ( \"Skipping as type== %s - %s \" , service [ \"type\" ], service ) return filtered_responsedata return self . services async def account_transactions ( self ) -> Dict [ str , AccountTransaction ]: \"\"\"Pulls the data for transactions on your account. Returns a dict where the key is the month and year of the transaction. Keys: `['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds']` Example output: ``` json \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], ``` \"\"\" url = self . get_url ( \"account_transactions\" ) responsedata : Dict [ str , AccountTransaction ] = await self . request_get_json ( url = url ) return responsedata async def billing_invoice ( self , invoice_id : int ): \"\"\"Downloads an invoice This returns the bare response object, parsing the result is an exercise for the consumer. It's a PDF file. \"\"\" url = self . get_url ( \"billing_invoice\" , { \"invoice_id\" : invoice_id }) responsedata = await self . request_get_json ( url = url ) return responsedata async def account_paymentplans ( self ): \"\"\"Returns a dict of payment plans for an account\"\"\" url = self . get_url ( \"account_paymentplans\" ) responsedata = await self . request_get_json ( url = url ) return responsedata async def get_usage ( self , service_id : int , use_cached : bool = True ): \"\"\" Returns a dict of usage for a service. If it's a telephony service (`type in aussiebb.const.PHONE_TYPES`) it'll pull from the telephony endpoint. \"\"\" services = await self . get_services ( use_cached = use_cached ) for service in services : if service_id == service [ \"service_id\" ]: # throw an error if we're trying to parse something we can't self . validate_service_type ( service ) if service [ \"type\" ] in PHONE_TYPES : return await self . telephony_usage ( service_id ) url = self . get_url ( \"get_usage\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) return responsedata async def get_service_tests ( self , service_id : int ) -> List [ ServiceTest ]: \"\"\"Gets the available tests for a given service ID Returns list of dicts Example data: ``` [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] ``` This has a habit of throwing 400 errors if you query a VOIP service... \"\"\" if self . debug : print ( f \"Getting service tests for { service_id } \" , file = sys . stderr ) url = self . get_url ( \"get_service_tests\" , { \"service_id\" : service_id }) responsedata : List [ ServiceTest ] = await self . request_get_json ( url = url ) return responsedata async def get_test_history ( self , service_id : int ): \"\"\"Gets the available tests for a given service ID Returns a list of dicts with tests which have been run \"\"\" url = self . get_url ( \"get_test_history\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) return responsedata async def test_line_state ( self , service_id : int ): \"\"\"Tests the line state for a given service ID\"\"\" # TODO: check if this is valid for the service id url = self . get_url ( \"test_line_state\" , { \"service_id\" : service_id }) if self . debug : print ( \"Testing line state, can take a few seconds...\" ) response = await self . request_post_json ( url = url ) if self . debug : print ( f \"Response: { response } \" , file = sys . stderr ) return response async def run_test ( self , service_id : int , test_name : str , test_method : str = \"post\" ): \"\"\"Run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis - 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' - 'status' of 'Completed' means you've got the full response \"\"\" service_tests = await self . get_service_tests ( service_id ) test_links = [ test for test in service_tests if test . get ( \"link\" , \"\" ) . endswith ( f \"/ { test_name } \" ) ] # pylint: disable=line-too-long if not test_links : return False if len ( test_links ) != 1 : if self . debug : print ( f \"Too many tests? { test_links } \" , file = sys . stderr ) test_name = test_links [ 0 ][ \"name\" ] if self . debug : print ( f \"Running { test_name } \" , file = sys . stderr ) if test_method == \"get\" : result = await self . request_get_json ( url = test_links [ 0 ] . get ( \"link\" )) else : result = await self . request_post_json ( url = test_links [ 0 ] . get ( \"link\" )) return result async def service_plans ( self , service_id : int ): \"\"\"Pulls the plan data for a given service. Keys: `['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds']` \"\"\" url = self . get_url ( \"service_plans\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata async def service_outages ( self , service_id : int ): \"\"\"Pulls outages associated with a service. Keys: `['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages']` Example data: ``` { \"networkEvents\": [], \"aussieOutages\": [], \"currentNbnOutages\": [], \"scheduledNbnOutages\": [], \"resolvedScheduledNbnOutages\": [ { \"start_date\": \"2021-08-17T14:00:00Z\", \"end_date\": \"2021-08-17T20:00:00Z\", \"duration\": \"6.0\" } ], \"resolvedNbnOutages\": [] } ``` \"\"\" url = self . get_url ( \"service_outages\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata async def service_boltons ( self , service_id : int ): \"\"\"Pulls addons associated with the service. Keys: `['id', 'name', 'description', 'costCents', 'additionalNote', 'active']` Example data: ``` [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] ``` \"\"\" url = self . get_url ( \"service_boltons\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata async def service_datablocks ( self , service_id : int ): \"\"\"Pulls datablocks associated with the service. Keys: `['current', 'available']` Example data: ``` { \"current\": [], \"available\": [] } ``` \"\"\" url = self . get_url ( \"service_datablocks\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata async def telephony_usage ( self , service_id : int ): \"\"\"Pulls the telephony usage associated with the service. Keys: `['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical']` Example data: ``` {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} ``` \"\"\" url = self . get_url ( \"telephony_usage\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata async def support_tickets ( self ): \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"support_tickets\" ) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata async def get_appointment ( self , ticketid : int ): \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"get_appointment\" , { \"ticketid\" : ticketid }) return await self . request_get_json ( url = url ) async def account_contacts ( self ) -> List [ AccountContact ]: \"\"\"Pulls the contacts with the account, returns a list of dicts Dict keys: `['id', 'first_name', 'last_name', 'email', 'dob', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact']` \"\"\" url = self . get_url ( \"account_contacts\" ) response = await self . request_get_json ( url = url ) return [ AccountContact . parse_obj ( contact ) for contact in response ] async def get_orders ( self ) -> Dict [ str , Any ]: \"\"\"pulls the outstanding orders for an account\"\"\" url = self . get_url ( \"get_orders\" ) responsedata = await self . request_get_json ( url = url ) result = OrderDetailResponseModel ( ** responsedata ) return result . dict () async def get_order ( self , order_id : int ) -> Dict [ str , Any ]: \"\"\"gets a specific order\"\"\" url = self . get_url ( \"get_order\" , { \"order_id\" : order_id }) responsedata = await self . request_get_json ( url = url ) result = OrderDetailResponseModel ( ** responsedata ) return result . dict () async def get_voip_devices ( self , service_id : int ) -> List [ VOIPDevice ]: \"\"\"gets the devices associatd with a VOIP service\"\"\" url = self . get_url ( \"voip_devices\" , { \"service_id\" : service_id }) service_list : List [ VOIPDevice ] = [] data = await self . request_get_json ( url = url ) for service in data : service_list . append ( VOIPDevice . parse_obj ( service )) return service_list async def get_voip_service ( self , service_id : int ) -> VOIPService : \"\"\"gets the details of a VOIP service\"\"\" url = self . get_url ( \"voip_service\" , { \"service_id\" : service_id }) data = await self . request_get_json ( url = url ) return VOIPService . parse_obj ( data ) referral_code property readonly returns the referral code, which is just the customer number __init__ ( self , username , password , session = None , debug = False , services_cache_time = 28800 ) special Setup function @param username: str - username for Aussie Broadband account @param password: str - password for Aussie Broadband account @param debug: bool - debug mode @param services_cache_time: int - seconds between caching get_services() - defaults to 8 hours Source code in aussiebb/asyncio/__init__.py def __init__ ( self , username : str , password : str , session : Optional [ aiohttp . client . ClientSession ] = None , debug : bool = False , services_cache_time : int = 28800 , ): \"\"\"Setup function ``` @param username: str - username for Aussie Broadband account @param password: str - password for Aussie Broadband account @param debug: bool - debug mode @param services_cache_time: int - seconds between caching get_services() - defaults to 8 hours ``` \"\"\" super () . __init__ ( username , password , debug , services_cache_time ) if not session : self . session = aiohttp . ClientSession () else : self . session = session account_contacts ( self ) async Pulls the contacts with the account, returns a list of dicts Dict keys: ['id', 'first_name', 'last_name', 'email', 'dob', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact'] Source code in aussiebb/asyncio/__init__.py async def account_contacts ( self ) -> List [ AccountContact ]: \"\"\"Pulls the contacts with the account, returns a list of dicts Dict keys: `['id', 'first_name', 'last_name', 'email', 'dob', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact']` \"\"\" url = self . get_url ( \"account_contacts\" ) response = await self . request_get_json ( url = url ) return [ AccountContact . parse_obj ( contact ) for contact in response ] account_paymentplans ( self ) async Returns a dict of payment plans for an account Source code in aussiebb/asyncio/__init__.py async def account_paymentplans ( self ): \"\"\"Returns a dict of payment plans for an account\"\"\" url = self . get_url ( \"account_paymentplans\" ) responsedata = await self . request_get_json ( url = url ) return responsedata account_transactions ( self ) async Pulls the data for transactions on your account. Returns a dict where the key is the month and year of the transaction. Keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] Example output: \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], Source code in aussiebb/asyncio/__init__.py async def account_transactions ( self ) -> Dict [ str , AccountTransaction ]: \"\"\"Pulls the data for transactions on your account. Returns a dict where the key is the month and year of the transaction. Keys: `['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds']` Example output: ``` json \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], ``` \"\"\" url = self . get_url ( \"account_transactions\" ) responsedata : Dict [ str , AccountTransaction ] = await self . request_get_json ( url = url ) return responsedata billing_invoice ( self , invoice_id ) async Downloads an invoice This returns the bare response object, parsing the result is an exercise for the consumer. It's a PDF file. Source code in aussiebb/asyncio/__init__.py async def billing_invoice ( self , invoice_id : int ): \"\"\"Downloads an invoice This returns the bare response object, parsing the result is an exercise for the consumer. It's a PDF file. \"\"\" url = self . get_url ( \"billing_invoice\" , { \"invoice_id\" : invoice_id }) responsedata = await self . request_get_json ( url = url ) return responsedata do_login_check ( self , skip_login_check ) async checks if we're skipping the login check and logs in if necessary Source code in aussiebb/asyncio/__init__.py async def do_login_check ( self , skip_login_check : bool ) -> None : \"\"\"checks if we're skipping the login check and logs in if necessary\"\"\" if not skip_login_check : self . logger . debug ( \"skip_login_check false\" ) if self . _has_token_expired (): self . logger . debug ( \"token has expired, logging in...\" ) await self . login () get_appointment ( self , ticketid ) async Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] Source code in aussiebb/asyncio/__init__.py async def get_appointment ( self , ticketid : int ): \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"get_appointment\" , { \"ticketid\" : ticketid }) return await self . request_get_json ( url = url ) get_customer_details ( self ) async Grabs the customer details. Returns a dict Source code in aussiebb/asyncio/__init__.py async def get_customer_details ( self ) -> Dict [ str , Any ]: \"\"\"Grabs the customer details. Returns a dict\"\"\" url = self . get_url ( \"get_customer_details\" ) params = { \"v\" : \"2\" } result : Dict [ str , Any ] = await self . request_get_json ( url = url , params = params , ) return result get_order ( self , order_id ) async gets a specific order Source code in aussiebb/asyncio/__init__.py async def get_order ( self , order_id : int ) -> Dict [ str , Any ]: \"\"\"gets a specific order\"\"\" url = self . get_url ( \"get_order\" , { \"order_id\" : order_id }) responsedata = await self . request_get_json ( url = url ) result = OrderDetailResponseModel ( ** responsedata ) return result . dict () get_orders ( self ) async pulls the outstanding orders for an account Source code in aussiebb/asyncio/__init__.py async def get_orders ( self ) -> Dict [ str , Any ]: \"\"\"pulls the outstanding orders for an account\"\"\" url = self . get_url ( \"get_orders\" ) responsedata = await self . request_get_json ( url = url ) result = OrderDetailResponseModel ( ** responsedata ) return result . dict () get_service_tests ( self , service_id ) async Gets the available tests for a given service ID Returns list of dicts Example data: [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] This has a habit of throwing 400 errors if you query a VOIP service... Source code in aussiebb/asyncio/__init__.py async def get_service_tests ( self , service_id : int ) -> List [ ServiceTest ]: \"\"\"Gets the available tests for a given service ID Returns list of dicts Example data: ``` [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] ``` This has a habit of throwing 400 errors if you query a VOIP service... \"\"\" if self . debug : print ( f \"Getting service tests for { service_id } \" , file = sys . stderr ) url = self . get_url ( \"get_service_tests\" , { \"service_id\" : service_id }) responsedata : List [ ServiceTest ] = await self . request_get_json ( url = url ) return responsedata get_services ( self , page = 1 , servicetypes = None , use_cached = False ) async Returns a list of dicts of services associated with the account. If you want a specific kind of service, or services, provide a list of matching strings in servicetypes. If you want to use cached data, call it with use_cached=True Source code in aussiebb/asyncio/__init__.py async def get_services ( self , page : int = 1 , servicetypes : Optional [ List [ str ]] = None , use_cached : bool = False , ): \"\"\"Returns a `list` of `dicts` of services associated with the account. If you want a specific kind of service, or services, provide a list of matching strings in servicetypes. If you want to use cached data, call it with `use_cached=True` \"\"\" if use_cached : self . logger . debug ( \"Using cached data for get_services.\" ) await self . _check_reload_cached_services () else : url = self . get_url ( \"get_services\" ) services_list : List [ Dict [ str , Any ]] = [] while True : params = { \"page\" : page } responsedata = await self . request_get_json ( url = url , params = params ) servicedata = GetServicesResponse . parse_obj ( responsedata ) for link in servicedata . data : services_list . append ( link ) if servicedata . links . next is None : break url = servicedata . links . next page = servicedata . meta [ \"current_page\" ] self . services = services_list self . services_last_update = int ( time ()) # TODO: validate the expected fields in the service (type, name, plan, description, service_id at a minimum) # only filter if we need to if servicetypes is not None : self . logger . debug ( \"Filtering services based on provided list: %s \" , servicetypes ) filtered_responsedata : List [ Any ] = [] if self . services is not None : for service in self . services : if \"type\" not in service : raise ValueError ( f \"No type field in service info: { service } \" ) if service [ \"type\" ] in servicetypes : filtered_responsedata . append ( service ) else : self . logger . debug ( \"Skipping as type== %s - %s \" , service [ \"type\" ], service ) return filtered_responsedata return self . services get_test_history ( self , service_id ) async Gets the available tests for a given service ID Returns a list of dicts with tests which have been run Source code in aussiebb/asyncio/__init__.py async def get_test_history ( self , service_id : int ): \"\"\"Gets the available tests for a given service ID Returns a list of dicts with tests which have been run \"\"\" url = self . get_url ( \"get_test_history\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) return responsedata get_usage ( self , service_id , use_cached = True ) async Returns a dict of usage for a service. If it's a telephony service ( type in aussiebb.const.PHONE_TYPES ) it'll pull from the telephony endpoint. Source code in aussiebb/asyncio/__init__.py async def get_usage ( self , service_id : int , use_cached : bool = True ): \"\"\" Returns a dict of usage for a service. If it's a telephony service (`type in aussiebb.const.PHONE_TYPES`) it'll pull from the telephony endpoint. \"\"\" services = await self . get_services ( use_cached = use_cached ) for service in services : if service_id == service [ \"service_id\" ]: # throw an error if we're trying to parse something we can't self . validate_service_type ( service ) if service [ \"type\" ] in PHONE_TYPES : return await self . telephony_usage ( service_id ) url = self . get_url ( \"get_usage\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) return responsedata get_voip_devices ( self , service_id ) async gets the devices associatd with a VOIP service Source code in aussiebb/asyncio/__init__.py async def get_voip_devices ( self , service_id : int ) -> List [ VOIPDevice ]: \"\"\"gets the devices associatd with a VOIP service\"\"\" url = self . get_url ( \"voip_devices\" , { \"service_id\" : service_id }) service_list : List [ VOIPDevice ] = [] data = await self . request_get_json ( url = url ) for service in data : service_list . append ( VOIPDevice . parse_obj ( service )) return service_list get_voip_service ( self , service_id ) async gets the details of a VOIP service Source code in aussiebb/asyncio/__init__.py async def get_voip_service ( self , service_id : int ) -> VOIPService : \"\"\"gets the details of a VOIP service\"\"\" url = self . get_url ( \"voip_service\" , { \"service_id\" : service_id }) data = await self . request_get_json ( url = url ) return VOIPService . parse_obj ( data ) handle_response_fail ( self , response , wait_on_rate_limit = True ) async Handles response status codes. Tries to gracefully handle the rate limiting. @param response - aiohttp.Response - the full response object @param wait_on_rate_limit - bool - if hitting a rate limit, async wait on the time limit Source code in aussiebb/asyncio/__init__.py async def handle_response_fail ( self , response : ClientResponse , wait_on_rate_limit : bool = True , ) -> None : \"\"\"Handles response status codes. Tries to gracefully handle the rate limiting. ``` @param response - aiohttp.Response - the full response object @param wait_on_rate_limit - bool - if hitting a rate limit, async wait on the time limit ``` \"\"\" ratelimit_remaining = int ( response . headers . get ( \"x-ratelimit-remaining\" , - 1 )) self . logger . debug ( \"Rate limit header: %s \" , response . headers . get ( \"x-ratelimit-remaining\" , - 1 ) ) if ratelimit_remaining < 5 and wait_on_rate_limit : print ( \"Rate limit below 5, sleeping for 1 second.\" , file = sys . stderr ) await asyncio . sleep ( 1 ) if response . status == 422 : raise AuthenticationException ( await response . json ()) if response . status == 429 : jsondata = await response . json () self . logger . debug ( \"Dumping headers: %s \" , response . headers ) self . logger . debug ( \"Dumping response: %s \" , json . dumps ( jsondata , default = str )) delay = DEFAULT_BACKOFF_DELAY if \"Please try again in \" in str ( jsondata . get ( \"errors\" )): fallback_value = [ f \"default { DEFAULT_BACKOFF_DELAY } seconds\" ] delay = ( jsondata . get ( \"errors\" , {}) . get ( \"username\" , fallback_value )[ 0 ] . split ()[ - 2 ] ) # give it some extra time to cool off delay = int ( delay ) + 5 if 0 < delay < 1000 : self . logger . debug ( \"Found required rate limit delay: %s \" , delay ) delay = int ( delay ) else : self . logger . debug ( \"Couldn't parse rate limit delay, using default: %s \" , delay ) else : delay = DEFAULT_BACKOFF_DELAY self . logger . debug ( \"Couldn't parse delay, using default: %s \" , delay ) if wait_on_rate_limit : self . logger . debug ( \"Rate limit on Aussie API calls raised, sleeping for %s seconds.\" , delay , ) await asyncio . sleep ( delay ) raise RateLimitException ( jsondata ) response . raise_for_status () login ( self , depth = 0 ) async Logs into the account and caches the cookie. Source code in aussiebb/asyncio/__init__.py async def login ( self , depth : int = 0 ) -> bool : \"\"\"Logs into the account and caches the cookie.\"\"\" if depth > 2 : raise RecursiveDepth ( \"Login recursion depth > 2\" ) self . logger . debug ( \"Logging in...\" ) url = BASEURL [ \"login\" ] if not self . _has_token_expired (): return True payload = { \"username\" : self . username , \"password\" : self . password , } headers = default_headers () async with self . session . post ( url = url , headers = headers , json = payload , ) as response : try : await self . handle_response_fail ( response ) jsondata = await response . json () except RateLimitException : return await self . login ( depth + 1 ) self . logger . debug ( \"Login response status: %s \" , response . status ) self . logger . debug ( \"Dumping login response: %s \" , json . dumps ( jsondata )) return self . _handle_login_response ( response . status , jsondata , response . cookies ) request_get ( self , url , skip_login_check = False , depth = 0 , ** kwargs ) async Performs a GET request and logs in first if needed. Source code in aussiebb/asyncio/__init__.py async def request_get ( self , url : str , skip_login_check : bool = False , depth : int = 0 , ** kwargs : Dict [ str , Any ], ) -> ClientResponse : \"\"\"Performs a GET request and logs in first if needed.\"\"\" if depth > 2 : raise RecursiveDepth ( f \"depth: { depth } \" ) if self . session is None : self . session = aiohttp . ClientSession () await self . do_login_check ( skip_login_check ) if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } response = await self . session . get ( url = url , ** kwargs ) # type: ignore # async with self.session.get(url=url, **kwargs) as response: try : await self . handle_response_fail ( response ) await response . read () except RateLimitException : response = await self . request_get ( url = url , skip_login_check = skip_login_check , depth = depth , ** kwargs ) return response request_get_json ( self , skip_login_check = False , ** kwargs ) async Performs a GET request and logs in first if needed. Returns a dict of the JSON response. Source code in aussiebb/asyncio/__init__.py async def request_get_json ( self , skip_login_check : bool = False , ** kwargs ) -> Any : \"\"\"Performs a GET request and logs in first if needed. Returns a dict of the JSON response. \"\"\" depth = kwargs . get ( \"depth\" , 0 ) if depth > 2 : raise RecursiveDepth ( f \"depth: { depth } \" ) if self . session is None : self . session = aiohttp . ClientSession () await self . do_login_check ( skip_login_check ) if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } async with self . session . get ( ** kwargs ) as response : try : await self . handle_response_fail ( response ) jsondata = await response . json () except RateLimitException : jsondata = await self . request_get_json ( skip_login_check , ** kwargs ) return jsondata request_post_json ( self , url =< class ' str '>, depth=0, skip_login_check=False, **kwargs) async Performs a POST request and logs in first if needed. Returns a dict of the response data. Source code in aussiebb/asyncio/__init__.py async def request_post_json ( self , url = str , depth : int = 0 , skip_login_check : bool = False , ** kwargs : Dict [ str , Any ], ) -> Dict [ str , Any ]: \"\"\"Performs a POST request and logs in first if needed. Returns a dict of the response data. \"\"\" if depth > 2 : raise RecursiveDepth ( f \"depth: { depth } \" ) if self . session is None : self . session = aiohttp . ClientSession () await self . do_login_check ( skip_login_check ) cookies = kwargs . get ( \"cookies\" , { \"myaussie_cookie\" : self . myaussie_cookie }) headers = kwargs . get ( \"headers\" , default_headers ()) async with self . session . post ( url = url , cookies = cookies , headers = headers ) as response : try : await self . handle_response_fail ( response ) jsondata : Dict [ str , Any ] = await response . json () except RateLimitException : jsondata = await self . request_post_json ( url = url , depth = depth + 1 , skip_login_check = skip_login_check , ** kwargs , ) return jsondata run_test ( self , service_id , test_name , test_method = 'post' ) async Run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' 'status' of 'Completed' means you've got the full response Source code in aussiebb/asyncio/__init__.py async def run_test ( self , service_id : int , test_name : str , test_method : str = \"post\" ): \"\"\"Run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis - 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' - 'status' of 'Completed' means you've got the full response \"\"\" service_tests = await self . get_service_tests ( service_id ) test_links = [ test for test in service_tests if test . get ( \"link\" , \"\" ) . endswith ( f \"/ { test_name } \" ) ] # pylint: disable=line-too-long if not test_links : return False if len ( test_links ) != 1 : if self . debug : print ( f \"Too many tests? { test_links } \" , file = sys . stderr ) test_name = test_links [ 0 ][ \"name\" ] if self . debug : print ( f \"Running { test_name } \" , file = sys . stderr ) if test_method == \"get\" : result = await self . request_get_json ( url = test_links [ 0 ] . get ( \"link\" )) else : result = await self . request_post_json ( url = test_links [ 0 ] . get ( \"link\" )) return result service_boltons ( self , service_id ) async Pulls addons associated with the service. Keys: ['id', 'name', 'description', 'costCents', 'additionalNote', 'active'] Example data: [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] Source code in aussiebb/asyncio/__init__.py async def service_boltons ( self , service_id : int ): \"\"\"Pulls addons associated with the service. Keys: `['id', 'name', 'description', 'costCents', 'additionalNote', 'active']` Example data: ``` [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] ``` \"\"\" url = self . get_url ( \"service_boltons\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata service_datablocks ( self , service_id ) async Pulls datablocks associated with the service. Keys: ['current', 'available'] Example data: { \"current\": [], \"available\": [] } Source code in aussiebb/asyncio/__init__.py async def service_datablocks ( self , service_id : int ): \"\"\"Pulls datablocks associated with the service. Keys: `['current', 'available']` Example data: ``` { \"current\": [], \"available\": [] } ``` \"\"\" url = self . get_url ( \"service_datablocks\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata service_outages ( self , service_id ) async Pulls outages associated with a service. Keys: ['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages'] Example data: { \"networkEvents\": [], \"aussieOutages\": [], \"currentNbnOutages\": [], \"scheduledNbnOutages\": [], \"resolvedScheduledNbnOutages\": [ { \"start_date\": \"2021-08-17T14:00:00Z\", \"end_date\": \"2021-08-17T20:00:00Z\", \"duration\": \"6.0\" } ], \"resolvedNbnOutages\": [] } Source code in aussiebb/asyncio/__init__.py async def service_outages ( self , service_id : int ): \"\"\"Pulls outages associated with a service. Keys: `['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages']` Example data: ``` { \"networkEvents\": [], \"aussieOutages\": [], \"currentNbnOutages\": [], \"scheduledNbnOutages\": [], \"resolvedScheduledNbnOutages\": [ { \"start_date\": \"2021-08-17T14:00:00Z\", \"end_date\": \"2021-08-17T20:00:00Z\", \"duration\": \"6.0\" } ], \"resolvedNbnOutages\": [] } ``` \"\"\" url = self . get_url ( \"service_outages\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata service_plans ( self , service_id ) async Pulls the plan data for a given service. Keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] Source code in aussiebb/asyncio/__init__.py async def service_plans ( self , service_id : int ): \"\"\"Pulls the plan data for a given service. Keys: `['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds']` \"\"\" url = self . get_url ( \"service_plans\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata support_tickets ( self ) async Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] Source code in aussiebb/asyncio/__init__.py async def support_tickets ( self ): \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"support_tickets\" ) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata telephony_usage ( self , service_id ) async Pulls the telephony usage associated with the service. Keys: ['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical'] Example data: {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} Source code in aussiebb/asyncio/__init__.py async def telephony_usage ( self , service_id : int ): \"\"\"Pulls the telephony usage associated with the service. Keys: `['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical']` Example data: ``` {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} ``` \"\"\" url = self . get_url ( \"telephony_usage\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata test_line_state ( self , service_id ) async Tests the line state for a given service ID Source code in aussiebb/asyncio/__init__.py async def test_line_state ( self , service_id : int ): \"\"\"Tests the line state for a given service ID\"\"\" # TODO: check if this is valid for the service id url = self . get_url ( \"test_line_state\" , { \"service_id\" : service_id }) if self . debug : print ( \"Testing line state, can take a few seconds...\" ) response = await self . request_post_json ( url = url ) if self . debug : print ( f \"Response: { response } \" , file = sys . stderr ) return response baseclass base class def BaseClass Base class for aussiebb API clients Source code in aussiebb/baseclass.py class BaseClass : \"\"\"Base class for aussiebb API clients\"\"\" API_ENDPOINTS = API_ENDPOINTS BASEURL = BASEURL def __init__ ( self , username : str , password : str , debug : bool = False , services_cache_time : int = 28800 , logger : logging . Logger = logging . getLogger (), ): if not ( username and password ): raise AuthenticationException ( \"You need to supply both username and password\" ) self . myaussie_cookie : Optional [ Union [ Morsel [ Any ], SimpleCookie [ Any ]]] = None self . token_expires = - 1 self . services_cache_time = services_cache_time # defaults to 8 hours self . services_last_update = - 1 self . services : List [ Dict [ str , Any ]] = [] self . username = username self . password = password self . logger = logger self . debug = debug def __str__ ( self ) -> str : \"\"\"string repr of account - returns username\"\"\" return self . username def get_url ( self , function_name : str , data : Optional [ Dict [ str , Any ]] = None ) -> str : \"\"\"gets the URL based on the data/function\"\"\" if function_name not in self . API_ENDPOINTS : raise ValueError ( f \"Function name { function_name } not found, cannot find URL\" ) if data : api_endpoint = self . API_ENDPOINTS [ function_name ] . format ( ** data ) else : api_endpoint = self . API_ENDPOINTS [ function_name ] return f \" { self . BASEURL . get ( 'api' ) }{ api_endpoint } \" def _has_token_expired ( self ) -> bool : \"\"\"Returns bool of if the token has expired\"\"\" if time () > self . token_expires : return True return False def _handle_login_response ( self , status_code : int , jsondata : Dict [ str , Any ], cookies : Union [ RequestsCookieJar , SimpleCookie [ Any ]], ) -> bool : \"\"\"Handles the login response. We expire the session a little early just to be safe, and if we don't get an expiry, we just bail.\"\"\" # just reset it in case self . token_expires = - 1 self . myaussie_cookie = None if status_code == 422 : raise AuthenticationException ( jsondata ) if status_code == 429 : raise RateLimitException ( jsondata ) # expected response from the API looks like # data: { \"expiresIn\" : 500 } # cookies: { \"myaussie_cookie\" : \"somerandomcookiethings\" } if \"expiresIn\" not in jsondata : return False if ( \"myaussie_cookie\" not in cookies or str ( cookies [ \"myaussie_cookie\" ]) . strip () == \"\" ): return False self . token_expires = time () + jsondata . get ( \"expiresIn\" , 0 ) - 50 self . myaussie_cookie = cookies [ \"myaussie_cookie\" ] self . logger . debug ( \"Login Cookie: %s \" , self . myaussie_cookie ) return True @classmethod def validate_service_type ( cls , service : Dict [ str , Any ]) -> None : \"\"\"Check the service types against known types\"\"\" if \"type\" not in service : raise ValueError ( \"Field 'type' not found in service data\" ) if service [ \"type\" ] not in NBN_TYPES + PHONE_TYPES : raise UnrecognisedServiceType ( f \"Service type ' { service [ 'type' ] } ' not recognised - please raise an issue about this - https://github.com/yaleman/aussiebb/issues/new\" ) __str__ ( self ) special string repr of account - returns username Source code in aussiebb/baseclass.py def __str__ ( self ) -> str : \"\"\"string repr of account - returns username\"\"\" return self . username get_url ( self , function_name , data = None ) gets the URL based on the data/function Source code in aussiebb/baseclass.py def get_url ( self , function_name : str , data : Optional [ Dict [ str , Any ]] = None ) -> str : \"\"\"gets the URL based on the data/function\"\"\" if function_name not in self . API_ENDPOINTS : raise ValueError ( f \"Function name { function_name } not found, cannot find URL\" ) if data : api_endpoint = self . API_ENDPOINTS [ function_name ] . format ( ** data ) else : api_endpoint = self . API_ENDPOINTS [ function_name ] return f \" { self . BASEURL . get ( 'api' ) }{ api_endpoint } \" validate_service_type ( service ) classmethod Check the service types against known types Source code in aussiebb/baseclass.py @classmethod def validate_service_type ( cls , service : Dict [ str , Any ]) -> None : \"\"\"Check the service types against known types\"\"\" if \"type\" not in service : raise ValueError ( \"Field 'type' not found in service data\" ) if service [ \"type\" ] not in NBN_TYPES + PHONE_TYPES : raise UnrecognisedServiceType ( f \"Service type ' { service [ 'type' ] } ' not recognised - please raise an issue about this - https://github.com/yaleman/aussiebb/issues/new\" ) const constants and utilities default_headers () returns a default set of headers Source code in aussiebb/const.py def default_headers () -> DefaultHeaders : \"\"\"returns a default set of headers\"\"\" return { \"Accept\" : \"application/json\" , \"Content-Type\" : \"application/json\" , \"Origin\" : \"https://my.aussiebroadband.com.au\" , \"Referer\" : \"https://my.aussiebroadband.com.au/\" , \"Cache-Control\" : \"no-cache\" , } exceptions exceptions for the AussieBB module AuthenticationException ( BaseException ) authentication error for AussieBB Source code in aussiebb/exceptions.py class AuthenticationException ( BaseException ): \"\"\"authentication error for AussieBB\"\"\" InvalidTestForService ( BaseException ) user specified an invalid test Source code in aussiebb/exceptions.py class InvalidTestForService ( BaseException ): \"\"\"user specified an invalid test\"\"\" RateLimitException ( BaseException ) rate limit error for AussieBB Source code in aussiebb/exceptions.py class RateLimitException ( BaseException ): \"\"\"rate limit error for AussieBB\"\"\" RecursiveDepth ( BaseException ) you've gone too far down the rabbit hole Source code in aussiebb/exceptions.py class RecursiveDepth ( BaseException ): \"\"\"you've gone too far down the rabbit hole\"\"\" UnrecognisedServiceType ( BaseException ) You've got a service type we haven't seen before Source code in aussiebb/exceptions.py class UnrecognisedServiceType ( BaseException ): \"\"\"You've got a service type we haven't seen before\"\"\" types types APIResponseLinks ( BaseModel ) pydantic-model the links field from an API response Source code in aussiebb/types.py class APIResponseLinks ( BaseModel ): \"\"\"the links field from an API response\"\"\" first : str last : str prev : Optional [ str ] next : Optional [ str ] AccountContact ( BaseModel ) pydantic-model account contact data Source code in aussiebb/types.py class AccountContact ( BaseModel ): \"\"\"account contact data\"\"\" contact_id : int = Field ( ... , alias = \"id\" ) first_name : str last_name : str email : List [ str ] dob : str home_phone : Optional [ str ] work_phone : Optional [ str ] mobile_phone : Optional [ str ] work_mobile : Optional [ str ] primary_contact : bool username : Optional [ str ] preferred_name : Optional [ str ] middle_name : Optional [ str ] AccountTransaction ( dict ) Transaction data typing, returns from account_transactions Source code in aussiebb/types.py class AccountTransaction ( TypedDict ): \"\"\"Transaction data typing, returns from account_transactions\"\"\" id : int type : str time : str description : str amountCents : int runningBalanceCents : int AussieBBConfigFile ( BaseModel ) pydantic-model config file definition Source code in aussiebb/types.py class AussieBBConfigFile ( BaseModel ): \"\"\"config file definition\"\"\" users : List [ ConfigUser ] username : Optional [ str ] password : Optional [ SecretStr ] class Config : \"\"\"metadata\"\"\" arbitrary_types_allowed = True Config metadata Source code in aussiebb/types.py class Config : \"\"\"metadata\"\"\" arbitrary_types_allowed = True AussieBBOutage ( BaseModel ) pydantic-model outage class Source code in aussiebb/types.py class AussieBBOutage ( BaseModel ): \"\"\"outage class\"\"\" networkEvents : List [ OutageRecord ] aussieOutages : Dict [ str , List [ OutageRecord ]] currentNbnOutages : List [ Any ] # TODO: define currentNbnOutages scheduledNbnOutages : List [ ScheduledOutageRecord ] # TODO: define scheduledNbnOutages resolvedScheduledNbnOutages : List [ ScheduledOutageRecord ] # TODO: define resolvedScheduledNbnOutages resolvedNbnOutages : List [ Any ] # TODO: define resolvedNbnOutages class Config : \"\"\"config\"\"\" arbitrary_types_allowed = True Config config Source code in aussiebb/types.py class Config : \"\"\"config\"\"\" arbitrary_types_allowed = True ConfigUser ( BaseModel ) pydantic-model just a username and password field Source code in aussiebb/types.py class ConfigUser ( BaseModel ): \"\"\"just a username and password field\"\"\" username : str password : str GetServicesResponse ( BaseModel ) pydantic-model the format for a response from the get_services call Source code in aussiebb/types.py class GetServicesResponse ( BaseModel ): \"\"\"the format for a response from the get_services call\"\"\" data : List [ Dict [ str , Any ]] links : APIResponseLinks meta : APIResponseMeta class Config : \"\"\"metadata\"\"\" arbitrary_types_allowed = True Config metadata Source code in aussiebb/types.py class Config : \"\"\"metadata\"\"\" arbitrary_types_allowed = True OrderData ( dict ) order element for OrderResponse get_orders Source code in aussiebb/types.py class OrderData ( TypedDict ): \"\"\"order element for OrderResponse get_orders\"\"\" id : int status : str type : str description : str OrderDetailResponseModel ( BaseModel ) pydantic-model order Response for get_order(int) Source code in aussiebb/types.py class OrderDetailResponseModel ( BaseModel ): \"\"\"order Response for get_order(int)\"\"\" id : int status : str plan : str address : str appointment : str appointment_reschedule_code : int = Field ( ... , alias = \"appointmentRescheduleCode\" ) statuses : List [ str ] OrderResponse ( BaseModel ) pydantic-model response from get_orders Source code in aussiebb/types.py class OrderResponse ( BaseModel ): \"\"\"response from get_orders\"\"\" data : List [ OrderData ] links : APIResponseLinks meta : APIResponseMeta class Config : \"\"\"config\"\"\" arbitrary_types_allowed = True Config config Source code in aussiebb/types.py class Config : \"\"\"config\"\"\" arbitrary_types_allowed = True OutageRecord ( BaseModel ) pydantic-model outage def Source code in aussiebb/types.py class OutageRecord ( BaseModel ): \"\"\"outage def\"\"\" reference : int title : str summary : str start_time : datetime end_time : datetime restored_at : Optional [ datetime ] last_updated : Optional [ datetime ] ScheduledOutageRecord scheduled outage record Source code in aussiebb/types.py class ScheduledOutageRecord : \"\"\"scheduled outage record\"\"\" start_date : datetime end_date : datetime duration : float ServiceTest ( dict ) A service test object Source code in aussiebb/types.py class ServiceTest ( TypedDict ): \"\"\"A service test object\"\"\" name : str description : str link : str VOIPDevice ( BaseModel ) pydantic-model an individual service device Source code in aussiebb/types.py class VOIPDevice ( BaseModel ): \"\"\"an individual service device\"\"\" username : str password : str registered : bool # is it online? VOIPService ( BaseModel ) pydantic-model individual VOIP service Source code in aussiebb/types.py class VOIPService ( BaseModel ): \"\"\"individual VOIP service\"\"\" phoneNumber : str barInternational : bool divertNumber : Optional [ str ] supportsNumberDiversion : bool utils shared utility functions","title":"API Documentation"},{"location":"aussiebb/#aussiebb.AussieBB","text":"A class for interacting with Aussie Broadband APIs Source code in aussiebb/__init__.py class AussieBB ( BaseClass ): \"\"\"A class for interacting with Aussie Broadband APIs\"\"\" def __init__ ( self , username : str , password : str , debug : bool = False , services_cache_time : int = 28800 , session : Optional [ requests . sessions . Session ] = None , ): \"\"\"Setup function ``` @param username: str - username for Aussie Broadband account @param password: str - password for Aussie Broadband account @param debug: bool - debug mode @param services_cache_time: int - seconds between caching get_services() - defaults to 8 hours @param session : requests.session - session object ``` \"\"\" super () . __init__ ( username , password , debug , services_cache_time ) if session is None : self . session = requests . Session () else : self . session = session def login ( self , depth : int = 0 ) -> bool : \"\"\"Logs into the account and caches the cookie.\"\"\" if depth > 2 : raise RecursiveDepth ( \"Login recursion depth > 2\" ) self . logger . debug ( \"Logging in...\" ) url = BASEURL [ \"login\" ] payload = { \"username\" : self . username , \"password\" : self . password , } headers = default_headers () response = self . session . post ( url , headers = headers , json = payload , ) response . raise_for_status () jsondata = response . json () return self . _handle_login_response ( response . status_code , jsondata , response . cookies ) def do_login_check ( self , skip_login_check : bool ) -> None : \"\"\"checks if we're skipping the login check and logs in if necessary\"\"\" if not skip_login_check : self . logger . debug ( \"skip_login_check false\" ) if self . _has_token_expired (): self . logger . debug ( \"token has expired, logging in...\" ) self . login () def request_get ( # type: ignore self , url : str , skip_login_check : bool = False , cookies : Optional [ Any ] = None , ** kwargs , ): \"\"\"Performs a GET request and logs in first if needed. Returns the `requests.Response` object.\"\"\" self . do_login_check ( skip_login_check ) if cookies is None : cookies = { \"myaussie_cookie\" : self . myaussie_cookie } response = self . session . get ( url = url , cookies = cookies , ** kwargs ) response . raise_for_status () return response def request_get_list ( self , skip_login_check : bool = False , ** kwargs : Any ) -> List [ Any ]: \"\"\"Performs a GET request and logs in first if needed. Returns a list from the response. \"\"\" if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } self . do_login_check ( skip_login_check ) response = self . session . get ( ** kwargs ) response . raise_for_status () result : List [ Any ] = response . json () return result def request_get_json ( self , url : str , skip_login_check : bool = False , ** kwargs : Dict [ str , Any ], ): \"\"\"Performs a GET request and logs in first if needed. Returns a dict of the JSON response. \"\"\" if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } self . do_login_check ( skip_login_check ) response = self . session . get ( url , ** kwargs ) # type: ignore response . raise_for_status () return response . json () def request_post ( self , url : str , skip_login_check : bool = False , ** kwargs : Dict [ str , Any ] ): \"\"\"Performs a POST request and logs in first if needed.\"\"\" self . do_login_check ( skip_login_check ) if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } response = self . session . post ( url = url , headers = kwargs . get ( \"headers\" , default_headers ()), ** kwargs , # type: ignore ) response . raise_for_status () return response def get_customer_details ( self ) -> Dict [ str , Any ]: \"\"\"Grabs the customer details. Returns a dict\"\"\" url = self . get_url ( \"get_customer_details\" ) querystring = { \"v\" : \"2\" } responsedata : Dict [ str , Any ] = self . request_get_json ( url = url , params = querystring , ) return responsedata @property def referral_code ( self ): \"\"\"returns the referral code, which is just the customer number\"\"\" response = self . get_customer_details () if \"customer_number\" not in response : raise ValueError ( \"Couldn't get customer_number from customer_details call.\" ) return int ( response [ \"customer_number\" ]) def _check_reload_cached_services ( self ) -> bool : \"\"\"If the age of the service data caching is too old, clear it and re-poll. Returns bool - if it reloaded the cache. \"\"\" if not self . services : self . get_services ( use_cached = False ) return True cache_expiry = self . services_last_update + self . services_cache_time if time () >= cache_expiry : self . get_services ( use_cached = False ) return True return False def get_services ( self , page : int = 1 , servicetypes : Optional [ List [ str ]] = None , use_cached : bool = False , ) -> Optional [ List [ Dict [ str , Any ]]]: \"\"\"Returns a `list` of `dicts` of services associated with the account. If you want a specific kind of service, or services, provide a list of matching strings in servicetypes. If you want to use cached data, call it with `use_cached=True` \"\"\" if use_cached : self . logger . debug ( \"Using cached data for get_services.\" ) self . _check_reload_cached_services () else : url = self . get_url ( \"get_services\" ) services_list : List [ Dict [ str , Any ]] = [] while True : params = { \"page\" : page } responsedata = self . request_get_json ( url = url , params = params ) servicedata = GetServicesResponse . parse_obj ( responsedata ) for link in servicedata . data : services_list . append ( link ) if servicedata . links . next is None : break url = servicedata . links . next page = servicedata . meta [ \"current_page\" ] self . services = services_list self . services_last_update = int ( time ()) # only filter if we need to if servicetypes is not None : self . logger . debug ( \"Filtering services based on provided list: %s \" , servicetypes ) filtered_responsedata : List [ Dict [ str , Any ]] = [] if self . services is not None : for service in self . services : if \"type\" not in service : raise ValueError ( f \"No type field in service info: { service } \" ) if service [ \"type\" ] in servicetypes : filtered_responsedata . append ( service ) else : self . logger . debug ( \"Skipping as type== %s - %s \" , service [ \"type\" ], service ) return filtered_responsedata return self . services def account_transactions ( self ) -> Dict [ str , AccountTransaction ]: \"\"\"Pulls the data for transactions on your account. Returns a dict where the key is the month and year of the transaction. Keys: `['id', 'type', 'time', 'description', 'amountCents', 'runningBalanceCents']` Example output: ``` json \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], ``` \"\"\" url = self . get_url ( \"account_transactions\" ) result : Dict [ str , AccountTransaction ] = self . request_get_json ( url = url ) return result def billing_invoice ( self , invoice_id : int ) -> Dict [ str , Any ]: \"\"\"Downloads an invoice This returns the bare response object, parsing the result is an exercise for the consumer. It's a PDF file. \"\"\" url = self . get_url ( \"billing_invoice\" , { \"invoice_id\" : invoice_id }) result : Dict [ str , Any ] = self . request_get_json ( url = url ) return result def account_paymentplans ( self ): \"\"\"Returns a dict of payment plans for an account\"\"\" url = self . get_url ( \"account_paymentplans\" ) return self . request_get_json ( url = url ) def get_usage ( self , service_id : int , use_cached : bool = True ) -> Dict [ str , Any ]: \"\"\" Returns a dict of usage for a service. If it's a telephony service (`type=PhoneMobile`) it'll pull from the telephony endpoint. \"\"\" if self . services is None : self . get_services ( use_cached = use_cached ) if self . services is not None : for service in self . services : if service_id == service [ \"service_id\" ]: # throw an error if we're trying to parse something we can't self . validate_service_type ( service ) if service [ \"type\" ] in PHONE_TYPES : return self . telephony_usage ( service_id ) url = self . get_url ( \"get_usage\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) return {} def get_service_tests ( self , service_id : int ) -> List [ ServiceTest ]: \"\"\"Gets the available tests for a given service ID Returns list of dicts Example data: ``` [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] ``` This has a habit of throwing 400 errors if you query a VOIP service... \"\"\" url = self . get_url ( \"get_service_tests\" , { \"service_id\" : service_id }) results : List [ ServiceTest ] = self . request_get_json ( url = url ) return results def get_test_history ( self , service_id : int ): \"\"\"Gets the available tests for a given service ID Returns a list of dicts with tests which have been run \"\"\" url = self . get_url ( \"get_test_history\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) def test_line_state ( self , service_id : int ): \"\"\"Tests the line state for a given service ID\"\"\" # TODO: check if this is valid for the service id url = self . get_url ( \"test_line_state\" , { \"service_id\" : service_id }) self . logger . debug ( \"Testing line state, can take a few seconds...\" ) response = self . request_post ( url = url ) return response . json () def run_test ( self , service_id : int , test_name : str , test_method : str = \"post\" ): \"\"\"Run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis - 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' - 'status' of 'Completed' means you've got the full response \"\"\" test_links = [ test for test in self . get_service_tests ( service_id ) if test . get ( \"link\" , \"\" ) . endswith ( f \"/ { test_name } \" ) ] # pylint: disable=line-too-long if not test_links : return False if len ( test_links ) != 1 : self . logger . debug ( \"Too many tests? %s \" , test_links ) test_name = test_links [ 0 ][ \"name\" ] self . logger . debug ( \"Running %s \" , test_name ) if test_method == \"get\" : return self . request_get_json ( url = test_links [ 0 ][ \"link\" ]) return self . request_post ( url = test_links [ 0 ][ \"link\" ]) . json () def service_plans ( self , service_id : int ): \"\"\"Pulls the plan data for a given service. Keys: `['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds']` \"\"\" url = self . get_url ( \"service_plans\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) def service_outages ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls outages associated with a service. Keys: `['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages']` ``` \"\"\" url = self . get_url ( \"service_outages\" , { \"service_id\" : service_id }) result = AussieBBOutage . parse_obj ( self . request_get_json ( url = url )) return result . dict () def service_boltons ( self , service_id : int ): \"\"\"Pulls addons associated with the service. Keys: `['id', 'name', 'description', 'costCents', 'additionalNote', 'active']` Example data: ``` [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] ``` \"\"\" url = self . get_url ( \"service_boltons\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) def service_datablocks ( self , service_id : int ): \"\"\"Pulls datablocks associated with the service. Keys: `['current', 'available']` Example data: ``` { \"current\": [], \"available\": [] } ``` \"\"\" url = self . get_url ( \"service_datablocks\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) def telephony_usage ( self , service_id : int ): \"\"\"Pulls the telephony usage associated with the service. Keys: `['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical']` Example data: ``` {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} ``` \"\"\" url = self . get_url ( \"telephony_usage\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) def support_tickets ( self ): \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"support_tickets\" ) return self . request_get_json ( url = url ) def get_appointment ( self , ticketid : int ): \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"get_appointment\" , { \"ticketid\" : ticketid }) return self . request_get_json ( url = url ) def account_contacts ( self ) -> List [ AccountContact ]: \"\"\"Pulls the contacts with the account, returns a list of dicts Dict keys: `['id', 'first_name', 'last_name', 'email', 'dob', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact']` \"\"\" url = self . get_url ( \"account_contacts\" ) response = self . request_get_json ( url = url ) return [ AccountContact . parse_obj ( contact ) for contact in response ] def get_orders ( self ): \"\"\"pulls the outstanding orders for an account\"\"\" url = self . get_url ( \"get_orders\" ) result = OrderResponse ( ** self . request_get_json ( url = url )) return result . dict () def get_order ( self , order_id : int ) -> OrderDetailResponse : \"\"\"gets a specific order\"\"\" url = self . get_url ( \"get_order\" , { \"order_id\" : order_id }) result = cast ( OrderDetailResponse , OrderDetailResponseModel ( ** self . request_get_json ( url = url )) . dict (), ) return result def get_voip_devices ( self , service_id : int ) -> List [ VOIPDevice ]: \"\"\"gets the devices associatd with a VOIP service\"\"\" url = self . get_url ( \"voip_devices\" , { \"service_id\" : service_id }) service_list : List [ VOIPDevice ] = [] for service in self . request_get_json ( url = url ): service_list . append ( VOIPDevice . parse_obj ( service )) return service_list def get_voip_service ( self , service_id : int ) -> VOIPService : \"\"\"gets the details of a VOIP service\"\"\" url = self . get_url ( \"voip_service\" , { \"service_id\" : service_id }) return VOIPService . parse_obj ( self . request_get_json ( url = url ))","title":"AussieBB"},{"location":"aussiebb/#aussiebb.AussieBB.referral_code","text":"returns the referral code, which is just the customer number","title":"referral_code"},{"location":"aussiebb/#aussiebb.AussieBB.__init__","text":"Setup function @param username: str - username for Aussie Broadband account @param password: str - password for Aussie Broadband account @param debug: bool - debug mode @param services_cache_time: int - seconds between caching get_services() - defaults to 8 hours @param session : requests.session - session object Source code in aussiebb/__init__.py def __init__ ( self , username : str , password : str , debug : bool = False , services_cache_time : int = 28800 , session : Optional [ requests . sessions . Session ] = None , ): \"\"\"Setup function ``` @param username: str - username for Aussie Broadband account @param password: str - password for Aussie Broadband account @param debug: bool - debug mode @param services_cache_time: int - seconds between caching get_services() - defaults to 8 hours @param session : requests.session - session object ``` \"\"\" super () . __init__ ( username , password , debug , services_cache_time ) if session is None : self . session = requests . Session () else : self . session = session","title":"__init__()"},{"location":"aussiebb/#aussiebb.AussieBB.account_contacts","text":"Pulls the contacts with the account, returns a list of dicts Dict keys: ['id', 'first_name', 'last_name', 'email', 'dob', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact'] Source code in aussiebb/__init__.py def account_contacts ( self ) -> List [ AccountContact ]: \"\"\"Pulls the contacts with the account, returns a list of dicts Dict keys: `['id', 'first_name', 'last_name', 'email', 'dob', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact']` \"\"\" url = self . get_url ( \"account_contacts\" ) response = self . request_get_json ( url = url ) return [ AccountContact . parse_obj ( contact ) for contact in response ]","title":"account_contacts()"},{"location":"aussiebb/#aussiebb.AussieBB.account_paymentplans","text":"Returns a dict of payment plans for an account Source code in aussiebb/__init__.py def account_paymentplans ( self ): \"\"\"Returns a dict of payment plans for an account\"\"\" url = self . get_url ( \"account_paymentplans\" ) return self . request_get_json ( url = url )","title":"account_paymentplans()"},{"location":"aussiebb/#aussiebb.AussieBB.account_transactions","text":"Pulls the data for transactions on your account. Returns a dict where the key is the month and year of the transaction. Keys: ['id', 'type', 'time', 'description', 'amountCents', 'runningBalanceCents'] Example output: \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], Source code in aussiebb/__init__.py def account_transactions ( self ) -> Dict [ str , AccountTransaction ]: \"\"\"Pulls the data for transactions on your account. Returns a dict where the key is the month and year of the transaction. Keys: `['id', 'type', 'time', 'description', 'amountCents', 'runningBalanceCents']` Example output: ``` json \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], ``` \"\"\" url = self . get_url ( \"account_transactions\" ) result : Dict [ str , AccountTransaction ] = self . request_get_json ( url = url ) return result","title":"account_transactions()"},{"location":"aussiebb/#aussiebb.AussieBB.billing_invoice","text":"Downloads an invoice This returns the bare response object, parsing the result is an exercise for the consumer. It's a PDF file. Source code in aussiebb/__init__.py def billing_invoice ( self , invoice_id : int ) -> Dict [ str , Any ]: \"\"\"Downloads an invoice This returns the bare response object, parsing the result is an exercise for the consumer. It's a PDF file. \"\"\" url = self . get_url ( \"billing_invoice\" , { \"invoice_id\" : invoice_id }) result : Dict [ str , Any ] = self . request_get_json ( url = url ) return result","title":"billing_invoice()"},{"location":"aussiebb/#aussiebb.AussieBB.do_login_check","text":"checks if we're skipping the login check and logs in if necessary Source code in aussiebb/__init__.py def do_login_check ( self , skip_login_check : bool ) -> None : \"\"\"checks if we're skipping the login check and logs in if necessary\"\"\" if not skip_login_check : self . logger . debug ( \"skip_login_check false\" ) if self . _has_token_expired (): self . logger . debug ( \"token has expired, logging in...\" ) self . login ()","title":"do_login_check()"},{"location":"aussiebb/#aussiebb.AussieBB.get_appointment","text":"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] Source code in aussiebb/__init__.py def get_appointment ( self , ticketid : int ): \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"get_appointment\" , { \"ticketid\" : ticketid }) return self . request_get_json ( url = url )","title":"get_appointment()"},{"location":"aussiebb/#aussiebb.AussieBB.get_customer_details","text":"Grabs the customer details. Returns a dict Source code in aussiebb/__init__.py def get_customer_details ( self ) -> Dict [ str , Any ]: \"\"\"Grabs the customer details. Returns a dict\"\"\" url = self . get_url ( \"get_customer_details\" ) querystring = { \"v\" : \"2\" } responsedata : Dict [ str , Any ] = self . request_get_json ( url = url , params = querystring , ) return responsedata","title":"get_customer_details()"},{"location":"aussiebb/#aussiebb.AussieBB.get_order","text":"gets a specific order Source code in aussiebb/__init__.py def get_order ( self , order_id : int ) -> OrderDetailResponse : \"\"\"gets a specific order\"\"\" url = self . get_url ( \"get_order\" , { \"order_id\" : order_id }) result = cast ( OrderDetailResponse , OrderDetailResponseModel ( ** self . request_get_json ( url = url )) . dict (), ) return result","title":"get_order()"},{"location":"aussiebb/#aussiebb.AussieBB.get_orders","text":"pulls the outstanding orders for an account Source code in aussiebb/__init__.py def get_orders ( self ): \"\"\"pulls the outstanding orders for an account\"\"\" url = self . get_url ( \"get_orders\" ) result = OrderResponse ( ** self . request_get_json ( url = url )) return result . dict ()","title":"get_orders()"},{"location":"aussiebb/#aussiebb.AussieBB.get_service_tests","text":"Gets the available tests for a given service ID Returns list of dicts Example data: [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] This has a habit of throwing 400 errors if you query a VOIP service... Source code in aussiebb/__init__.py def get_service_tests ( self , service_id : int ) -> List [ ServiceTest ]: \"\"\"Gets the available tests for a given service ID Returns list of dicts Example data: ``` [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] ``` This has a habit of throwing 400 errors if you query a VOIP service... \"\"\" url = self . get_url ( \"get_service_tests\" , { \"service_id\" : service_id }) results : List [ ServiceTest ] = self . request_get_json ( url = url ) return results","title":"get_service_tests()"},{"location":"aussiebb/#aussiebb.AussieBB.get_services","text":"Returns a list of dicts of services associated with the account. If you want a specific kind of service, or services, provide a list of matching strings in servicetypes. If you want to use cached data, call it with use_cached=True Source code in aussiebb/__init__.py def get_services ( self , page : int = 1 , servicetypes : Optional [ List [ str ]] = None , use_cached : bool = False , ) -> Optional [ List [ Dict [ str , Any ]]]: \"\"\"Returns a `list` of `dicts` of services associated with the account. If you want a specific kind of service, or services, provide a list of matching strings in servicetypes. If you want to use cached data, call it with `use_cached=True` \"\"\" if use_cached : self . logger . debug ( \"Using cached data for get_services.\" ) self . _check_reload_cached_services () else : url = self . get_url ( \"get_services\" ) services_list : List [ Dict [ str , Any ]] = [] while True : params = { \"page\" : page } responsedata = self . request_get_json ( url = url , params = params ) servicedata = GetServicesResponse . parse_obj ( responsedata ) for link in servicedata . data : services_list . append ( link ) if servicedata . links . next is None : break url = servicedata . links . next page = servicedata . meta [ \"current_page\" ] self . services = services_list self . services_last_update = int ( time ()) # only filter if we need to if servicetypes is not None : self . logger . debug ( \"Filtering services based on provided list: %s \" , servicetypes ) filtered_responsedata : List [ Dict [ str , Any ]] = [] if self . services is not None : for service in self . services : if \"type\" not in service : raise ValueError ( f \"No type field in service info: { service } \" ) if service [ \"type\" ] in servicetypes : filtered_responsedata . append ( service ) else : self . logger . debug ( \"Skipping as type== %s - %s \" , service [ \"type\" ], service ) return filtered_responsedata return self . services","title":"get_services()"},{"location":"aussiebb/#aussiebb.AussieBB.get_test_history","text":"Gets the available tests for a given service ID Returns a list of dicts with tests which have been run Source code in aussiebb/__init__.py def get_test_history ( self , service_id : int ): \"\"\"Gets the available tests for a given service ID Returns a list of dicts with tests which have been run \"\"\" url = self . get_url ( \"get_test_history\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url )","title":"get_test_history()"},{"location":"aussiebb/#aussiebb.AussieBB.get_usage","text":"Returns a dict of usage for a service. If it's a telephony service ( type=PhoneMobile ) it'll pull from the telephony endpoint. Source code in aussiebb/__init__.py def get_usage ( self , service_id : int , use_cached : bool = True ) -> Dict [ str , Any ]: \"\"\" Returns a dict of usage for a service. If it's a telephony service (`type=PhoneMobile`) it'll pull from the telephony endpoint. \"\"\" if self . services is None : self . get_services ( use_cached = use_cached ) if self . services is not None : for service in self . services : if service_id == service [ \"service_id\" ]: # throw an error if we're trying to parse something we can't self . validate_service_type ( service ) if service [ \"type\" ] in PHONE_TYPES : return self . telephony_usage ( service_id ) url = self . get_url ( \"get_usage\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url ) return {}","title":"get_usage()"},{"location":"aussiebb/#aussiebb.AussieBB.get_voip_devices","text":"gets the devices associatd with a VOIP service Source code in aussiebb/__init__.py def get_voip_devices ( self , service_id : int ) -> List [ VOIPDevice ]: \"\"\"gets the devices associatd with a VOIP service\"\"\" url = self . get_url ( \"voip_devices\" , { \"service_id\" : service_id }) service_list : List [ VOIPDevice ] = [] for service in self . request_get_json ( url = url ): service_list . append ( VOIPDevice . parse_obj ( service )) return service_list","title":"get_voip_devices()"},{"location":"aussiebb/#aussiebb.AussieBB.get_voip_service","text":"gets the details of a VOIP service Source code in aussiebb/__init__.py def get_voip_service ( self , service_id : int ) -> VOIPService : \"\"\"gets the details of a VOIP service\"\"\" url = self . get_url ( \"voip_service\" , { \"service_id\" : service_id }) return VOIPService . parse_obj ( self . request_get_json ( url = url ))","title":"get_voip_service()"},{"location":"aussiebb/#aussiebb.AussieBB.login","text":"Logs into the account and caches the cookie. Source code in aussiebb/__init__.py def login ( self , depth : int = 0 ) -> bool : \"\"\"Logs into the account and caches the cookie.\"\"\" if depth > 2 : raise RecursiveDepth ( \"Login recursion depth > 2\" ) self . logger . debug ( \"Logging in...\" ) url = BASEURL [ \"login\" ] payload = { \"username\" : self . username , \"password\" : self . password , } headers = default_headers () response = self . session . post ( url , headers = headers , json = payload , ) response . raise_for_status () jsondata = response . json () return self . _handle_login_response ( response . status_code , jsondata , response . cookies )","title":"login()"},{"location":"aussiebb/#aussiebb.AussieBB.request_get","text":"Performs a GET request and logs in first if needed. Returns the requests.Response object. Source code in aussiebb/__init__.py def request_get ( # type: ignore self , url : str , skip_login_check : bool = False , cookies : Optional [ Any ] = None , ** kwargs , ): \"\"\"Performs a GET request and logs in first if needed. Returns the `requests.Response` object.\"\"\" self . do_login_check ( skip_login_check ) if cookies is None : cookies = { \"myaussie_cookie\" : self . myaussie_cookie } response = self . session . get ( url = url , cookies = cookies , ** kwargs ) response . raise_for_status () return response","title":"request_get()"},{"location":"aussiebb/#aussiebb.AussieBB.request_get_json","text":"Performs a GET request and logs in first if needed. Returns a dict of the JSON response. Source code in aussiebb/__init__.py def request_get_json ( self , url : str , skip_login_check : bool = False , ** kwargs : Dict [ str , Any ], ): \"\"\"Performs a GET request and logs in first if needed. Returns a dict of the JSON response. \"\"\" if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } self . do_login_check ( skip_login_check ) response = self . session . get ( url , ** kwargs ) # type: ignore response . raise_for_status () return response . json ()","title":"request_get_json()"},{"location":"aussiebb/#aussiebb.AussieBB.request_get_list","text":"Performs a GET request and logs in first if needed. Returns a list from the response. Source code in aussiebb/__init__.py def request_get_list ( self , skip_login_check : bool = False , ** kwargs : Any ) -> List [ Any ]: \"\"\"Performs a GET request and logs in first if needed. Returns a list from the response. \"\"\" if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } self . do_login_check ( skip_login_check ) response = self . session . get ( ** kwargs ) response . raise_for_status () result : List [ Any ] = response . json () return result","title":"request_get_list()"},{"location":"aussiebb/#aussiebb.AussieBB.request_post","text":"Performs a POST request and logs in first if needed. Source code in aussiebb/__init__.py def request_post ( self , url : str , skip_login_check : bool = False , ** kwargs : Dict [ str , Any ] ): \"\"\"Performs a POST request and logs in first if needed.\"\"\" self . do_login_check ( skip_login_check ) if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } response = self . session . post ( url = url , headers = kwargs . get ( \"headers\" , default_headers ()), ** kwargs , # type: ignore ) response . raise_for_status () return response","title":"request_post()"},{"location":"aussiebb/#aussiebb.AussieBB.run_test","text":"Run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' 'status' of 'Completed' means you've got the full response Source code in aussiebb/__init__.py def run_test ( self , service_id : int , test_name : str , test_method : str = \"post\" ): \"\"\"Run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis - 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' - 'status' of 'Completed' means you've got the full response \"\"\" test_links = [ test for test in self . get_service_tests ( service_id ) if test . get ( \"link\" , \"\" ) . endswith ( f \"/ { test_name } \" ) ] # pylint: disable=line-too-long if not test_links : return False if len ( test_links ) != 1 : self . logger . debug ( \"Too many tests? %s \" , test_links ) test_name = test_links [ 0 ][ \"name\" ] self . logger . debug ( \"Running %s \" , test_name ) if test_method == \"get\" : return self . request_get_json ( url = test_links [ 0 ][ \"link\" ]) return self . request_post ( url = test_links [ 0 ][ \"link\" ]) . json ()","title":"run_test()"},{"location":"aussiebb/#aussiebb.AussieBB.service_boltons","text":"Pulls addons associated with the service. Keys: ['id', 'name', 'description', 'costCents', 'additionalNote', 'active'] Example data: [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] Source code in aussiebb/__init__.py def service_boltons ( self , service_id : int ): \"\"\"Pulls addons associated with the service. Keys: `['id', 'name', 'description', 'costCents', 'additionalNote', 'active']` Example data: ``` [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] ``` \"\"\" url = self . get_url ( \"service_boltons\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url )","title":"service_boltons()"},{"location":"aussiebb/#aussiebb.AussieBB.service_datablocks","text":"Pulls datablocks associated with the service. Keys: ['current', 'available'] Example data: { \"current\": [], \"available\": [] } Source code in aussiebb/__init__.py def service_datablocks ( self , service_id : int ): \"\"\"Pulls datablocks associated with the service. Keys: `['current', 'available']` Example data: ``` { \"current\": [], \"available\": [] } ``` \"\"\" url = self . get_url ( \"service_datablocks\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url )","title":"service_datablocks()"},{"location":"aussiebb/#aussiebb.AussieBB.service_outages","text":"Pulls outages associated with a service. Keys: ['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages'] ``` Source code in aussiebb/__init__.py def service_outages ( self , service_id : int ) -> Dict [ str , Any ]: \"\"\"Pulls outages associated with a service. Keys: `['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages']` ``` \"\"\" url = self . get_url ( \"service_outages\" , { \"service_id\" : service_id }) result = AussieBBOutage . parse_obj ( self . request_get_json ( url = url )) return result . dict ()","title":"service_outages()"},{"location":"aussiebb/#aussiebb.AussieBB.service_plans","text":"Pulls the plan data for a given service. Keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] Source code in aussiebb/__init__.py def service_plans ( self , service_id : int ): \"\"\"Pulls the plan data for a given service. Keys: `['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds']` \"\"\" url = self . get_url ( \"service_plans\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url )","title":"service_plans()"},{"location":"aussiebb/#aussiebb.AussieBB.support_tickets","text":"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] Source code in aussiebb/__init__.py def support_tickets ( self ): \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"support_tickets\" ) return self . request_get_json ( url = url )","title":"support_tickets()"},{"location":"aussiebb/#aussiebb.AussieBB.telephony_usage","text":"Pulls the telephony usage associated with the service. Keys: ['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical'] Example data: {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} Source code in aussiebb/__init__.py def telephony_usage ( self , service_id : int ): \"\"\"Pulls the telephony usage associated with the service. Keys: `['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical']` Example data: ``` {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} ``` \"\"\" url = self . get_url ( \"telephony_usage\" , { \"service_id\" : service_id }) return self . request_get_json ( url = url )","title":"telephony_usage()"},{"location":"aussiebb/#aussiebb.AussieBB.test_line_state","text":"Tests the line state for a given service ID Source code in aussiebb/__init__.py def test_line_state ( self , service_id : int ): \"\"\"Tests the line state for a given service ID\"\"\" # TODO: check if this is valid for the service id url = self . get_url ( \"test_line_state\" , { \"service_id\" : service_id }) self . logger . debug ( \"Testing line state, can take a few seconds...\" ) response = self . request_post ( url = url ) return response . json ()","title":"test_line_state()"},{"location":"aussiebb/#aussiebb.asyncio","text":"aiohttp support for AussieBB","title":"asyncio"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB","text":"aiohttp class for interacting with Aussie Broadband APIs Source code in aussiebb/asyncio/__init__.py class AussieBB ( BaseClass ): # pylint: disable=too-many-public-methods \"\"\"aiohttp class for interacting with Aussie Broadband APIs\"\"\" # pylint: disable=too-many-arguments def __init__ ( self , username : str , password : str , session : Optional [ aiohttp . client . ClientSession ] = None , debug : bool = False , services_cache_time : int = 28800 , ): \"\"\"Setup function ``` @param username: str - username for Aussie Broadband account @param password: str - password for Aussie Broadband account @param debug: bool - debug mode @param services_cache_time: int - seconds between caching get_services() - defaults to 8 hours ``` \"\"\" super () . __init__ ( username , password , debug , services_cache_time ) if not session : self . session = aiohttp . ClientSession () else : self . session = session async def login ( self , depth : int = 0 ) -> bool : \"\"\"Logs into the account and caches the cookie.\"\"\" if depth > 2 : raise RecursiveDepth ( \"Login recursion depth > 2\" ) self . logger . debug ( \"Logging in...\" ) url = BASEURL [ \"login\" ] if not self . _has_token_expired (): return True payload = { \"username\" : self . username , \"password\" : self . password , } headers = default_headers () async with self . session . post ( url = url , headers = headers , json = payload , ) as response : try : await self . handle_response_fail ( response ) jsondata = await response . json () except RateLimitException : return await self . login ( depth + 1 ) self . logger . debug ( \"Login response status: %s \" , response . status ) self . logger . debug ( \"Dumping login response: %s \" , json . dumps ( jsondata )) return self . _handle_login_response ( response . status , jsondata , response . cookies ) async def handle_response_fail ( self , response : ClientResponse , wait_on_rate_limit : bool = True , ) -> None : \"\"\"Handles response status codes. Tries to gracefully handle the rate limiting. ``` @param response - aiohttp.Response - the full response object @param wait_on_rate_limit - bool - if hitting a rate limit, async wait on the time limit ``` \"\"\" ratelimit_remaining = int ( response . headers . get ( \"x-ratelimit-remaining\" , - 1 )) self . logger . debug ( \"Rate limit header: %s \" , response . headers . get ( \"x-ratelimit-remaining\" , - 1 ) ) if ratelimit_remaining < 5 and wait_on_rate_limit : print ( \"Rate limit below 5, sleeping for 1 second.\" , file = sys . stderr ) await asyncio . sleep ( 1 ) if response . status == 422 : raise AuthenticationException ( await response . json ()) if response . status == 429 : jsondata = await response . json () self . logger . debug ( \"Dumping headers: %s \" , response . headers ) self . logger . debug ( \"Dumping response: %s \" , json . dumps ( jsondata , default = str )) delay = DEFAULT_BACKOFF_DELAY if \"Please try again in \" in str ( jsondata . get ( \"errors\" )): fallback_value = [ f \"default { DEFAULT_BACKOFF_DELAY } seconds\" ] delay = ( jsondata . get ( \"errors\" , {}) . get ( \"username\" , fallback_value )[ 0 ] . split ()[ - 2 ] ) # give it some extra time to cool off delay = int ( delay ) + 5 if 0 < delay < 1000 : self . logger . debug ( \"Found required rate limit delay: %s \" , delay ) delay = int ( delay ) else : self . logger . debug ( \"Couldn't parse rate limit delay, using default: %s \" , delay ) else : delay = DEFAULT_BACKOFF_DELAY self . logger . debug ( \"Couldn't parse delay, using default: %s \" , delay ) if wait_on_rate_limit : self . logger . debug ( \"Rate limit on Aussie API calls raised, sleeping for %s seconds.\" , delay , ) await asyncio . sleep ( delay ) raise RateLimitException ( jsondata ) response . raise_for_status () async def do_login_check ( self , skip_login_check : bool ) -> None : \"\"\"checks if we're skipping the login check and logs in if necessary\"\"\" if not skip_login_check : self . logger . debug ( \"skip_login_check false\" ) if self . _has_token_expired (): self . logger . debug ( \"token has expired, logging in...\" ) await self . login () async def request_get ( self , url : str , skip_login_check : bool = False , depth : int = 0 , ** kwargs : Dict [ str , Any ], ) -> ClientResponse : \"\"\"Performs a GET request and logs in first if needed.\"\"\" if depth > 2 : raise RecursiveDepth ( f \"depth: { depth } \" ) if self . session is None : self . session = aiohttp . ClientSession () await self . do_login_check ( skip_login_check ) if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } response = await self . session . get ( url = url , ** kwargs ) # type: ignore # async with self.session.get(url=url, **kwargs) as response: try : await self . handle_response_fail ( response ) await response . read () except RateLimitException : response = await self . request_get ( url = url , skip_login_check = skip_login_check , depth = depth , ** kwargs ) return response async def request_get_json ( self , skip_login_check : bool = False , ** kwargs ) -> Any : \"\"\"Performs a GET request and logs in first if needed. Returns a dict of the JSON response. \"\"\" depth = kwargs . get ( \"depth\" , 0 ) if depth > 2 : raise RecursiveDepth ( f \"depth: { depth } \" ) if self . session is None : self . session = aiohttp . ClientSession () await self . do_login_check ( skip_login_check ) if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } async with self . session . get ( ** kwargs ) as response : try : await self . handle_response_fail ( response ) jsondata = await response . json () except RateLimitException : jsondata = await self . request_get_json ( skip_login_check , ** kwargs ) return jsondata async def request_post_json ( self , url = str , depth : int = 0 , skip_login_check : bool = False , ** kwargs : Dict [ str , Any ], ) -> Dict [ str , Any ]: \"\"\"Performs a POST request and logs in first if needed. Returns a dict of the response data. \"\"\" if depth > 2 : raise RecursiveDepth ( f \"depth: { depth } \" ) if self . session is None : self . session = aiohttp . ClientSession () await self . do_login_check ( skip_login_check ) cookies = kwargs . get ( \"cookies\" , { \"myaussie_cookie\" : self . myaussie_cookie }) headers = kwargs . get ( \"headers\" , default_headers ()) async with self . session . post ( url = url , cookies = cookies , headers = headers ) as response : try : await self . handle_response_fail ( response ) jsondata : Dict [ str , Any ] = await response . json () except RateLimitException : jsondata = await self . request_post_json ( url = url , depth = depth + 1 , skip_login_check = skip_login_check , ** kwargs , ) return jsondata async def get_customer_details ( self ) -> Dict [ str , Any ]: \"\"\"Grabs the customer details. Returns a dict\"\"\" url = self . get_url ( \"get_customer_details\" ) params = { \"v\" : \"2\" } result : Dict [ str , Any ] = await self . request_get_json ( url = url , params = params , ) return result @property async def referral_code ( self ): \"\"\"returns the referral code, which is just the customer number\"\"\" response = await self . get_customer_details () if \"customer_number\" not in response : raise ValueError ( \"Couldn't get customer_number from customer_details call.\" ) return int ( response [ \"customer_number\" ]) async def _check_reload_cached_services ( self ) -> bool : \"\"\"If the age of the service data caching is too old, clear it and re-poll. Returns bool - if it reloaded the cache. \"\"\" if not self . services : await self . get_services ( use_cached = False ) return True cache_expiry = self . services_last_update + self . services_cache_time if time () >= cache_expiry : await self . get_services ( use_cached = False ) return True return False async def get_services ( self , page : int = 1 , servicetypes : Optional [ List [ str ]] = None , use_cached : bool = False , ): \"\"\"Returns a `list` of `dicts` of services associated with the account. If you want a specific kind of service, or services, provide a list of matching strings in servicetypes. If you want to use cached data, call it with `use_cached=True` \"\"\" if use_cached : self . logger . debug ( \"Using cached data for get_services.\" ) await self . _check_reload_cached_services () else : url = self . get_url ( \"get_services\" ) services_list : List [ Dict [ str , Any ]] = [] while True : params = { \"page\" : page } responsedata = await self . request_get_json ( url = url , params = params ) servicedata = GetServicesResponse . parse_obj ( responsedata ) for link in servicedata . data : services_list . append ( link ) if servicedata . links . next is None : break url = servicedata . links . next page = servicedata . meta [ \"current_page\" ] self . services = services_list self . services_last_update = int ( time ()) # TODO: validate the expected fields in the service (type, name, plan, description, service_id at a minimum) # only filter if we need to if servicetypes is not None : self . logger . debug ( \"Filtering services based on provided list: %s \" , servicetypes ) filtered_responsedata : List [ Any ] = [] if self . services is not None : for service in self . services : if \"type\" not in service : raise ValueError ( f \"No type field in service info: { service } \" ) if service [ \"type\" ] in servicetypes : filtered_responsedata . append ( service ) else : self . logger . debug ( \"Skipping as type== %s - %s \" , service [ \"type\" ], service ) return filtered_responsedata return self . services async def account_transactions ( self ) -> Dict [ str , AccountTransaction ]: \"\"\"Pulls the data for transactions on your account. Returns a dict where the key is the month and year of the transaction. Keys: `['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds']` Example output: ``` json \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], ``` \"\"\" url = self . get_url ( \"account_transactions\" ) responsedata : Dict [ str , AccountTransaction ] = await self . request_get_json ( url = url ) return responsedata async def billing_invoice ( self , invoice_id : int ): \"\"\"Downloads an invoice This returns the bare response object, parsing the result is an exercise for the consumer. It's a PDF file. \"\"\" url = self . get_url ( \"billing_invoice\" , { \"invoice_id\" : invoice_id }) responsedata = await self . request_get_json ( url = url ) return responsedata async def account_paymentplans ( self ): \"\"\"Returns a dict of payment plans for an account\"\"\" url = self . get_url ( \"account_paymentplans\" ) responsedata = await self . request_get_json ( url = url ) return responsedata async def get_usage ( self , service_id : int , use_cached : bool = True ): \"\"\" Returns a dict of usage for a service. If it's a telephony service (`type in aussiebb.const.PHONE_TYPES`) it'll pull from the telephony endpoint. \"\"\" services = await self . get_services ( use_cached = use_cached ) for service in services : if service_id == service [ \"service_id\" ]: # throw an error if we're trying to parse something we can't self . validate_service_type ( service ) if service [ \"type\" ] in PHONE_TYPES : return await self . telephony_usage ( service_id ) url = self . get_url ( \"get_usage\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) return responsedata async def get_service_tests ( self , service_id : int ) -> List [ ServiceTest ]: \"\"\"Gets the available tests for a given service ID Returns list of dicts Example data: ``` [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] ``` This has a habit of throwing 400 errors if you query a VOIP service... \"\"\" if self . debug : print ( f \"Getting service tests for { service_id } \" , file = sys . stderr ) url = self . get_url ( \"get_service_tests\" , { \"service_id\" : service_id }) responsedata : List [ ServiceTest ] = await self . request_get_json ( url = url ) return responsedata async def get_test_history ( self , service_id : int ): \"\"\"Gets the available tests for a given service ID Returns a list of dicts with tests which have been run \"\"\" url = self . get_url ( \"get_test_history\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) return responsedata async def test_line_state ( self , service_id : int ): \"\"\"Tests the line state for a given service ID\"\"\" # TODO: check if this is valid for the service id url = self . get_url ( \"test_line_state\" , { \"service_id\" : service_id }) if self . debug : print ( \"Testing line state, can take a few seconds...\" ) response = await self . request_post_json ( url = url ) if self . debug : print ( f \"Response: { response } \" , file = sys . stderr ) return response async def run_test ( self , service_id : int , test_name : str , test_method : str = \"post\" ): \"\"\"Run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis - 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' - 'status' of 'Completed' means you've got the full response \"\"\" service_tests = await self . get_service_tests ( service_id ) test_links = [ test for test in service_tests if test . get ( \"link\" , \"\" ) . endswith ( f \"/ { test_name } \" ) ] # pylint: disable=line-too-long if not test_links : return False if len ( test_links ) != 1 : if self . debug : print ( f \"Too many tests? { test_links } \" , file = sys . stderr ) test_name = test_links [ 0 ][ \"name\" ] if self . debug : print ( f \"Running { test_name } \" , file = sys . stderr ) if test_method == \"get\" : result = await self . request_get_json ( url = test_links [ 0 ] . get ( \"link\" )) else : result = await self . request_post_json ( url = test_links [ 0 ] . get ( \"link\" )) return result async def service_plans ( self , service_id : int ): \"\"\"Pulls the plan data for a given service. Keys: `['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds']` \"\"\" url = self . get_url ( \"service_plans\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata async def service_outages ( self , service_id : int ): \"\"\"Pulls outages associated with a service. Keys: `['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages']` Example data: ``` { \"networkEvents\": [], \"aussieOutages\": [], \"currentNbnOutages\": [], \"scheduledNbnOutages\": [], \"resolvedScheduledNbnOutages\": [ { \"start_date\": \"2021-08-17T14:00:00Z\", \"end_date\": \"2021-08-17T20:00:00Z\", \"duration\": \"6.0\" } ], \"resolvedNbnOutages\": [] } ``` \"\"\" url = self . get_url ( \"service_outages\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata async def service_boltons ( self , service_id : int ): \"\"\"Pulls addons associated with the service. Keys: `['id', 'name', 'description', 'costCents', 'additionalNote', 'active']` Example data: ``` [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] ``` \"\"\" url = self . get_url ( \"service_boltons\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata async def service_datablocks ( self , service_id : int ): \"\"\"Pulls datablocks associated with the service. Keys: `['current', 'available']` Example data: ``` { \"current\": [], \"available\": [] } ``` \"\"\" url = self . get_url ( \"service_datablocks\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata async def telephony_usage ( self , service_id : int ): \"\"\"Pulls the telephony usage associated with the service. Keys: `['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical']` Example data: ``` {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} ``` \"\"\" url = self . get_url ( \"telephony_usage\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata async def support_tickets ( self ): \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"support_tickets\" ) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata async def get_appointment ( self , ticketid : int ): \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"get_appointment\" , { \"ticketid\" : ticketid }) return await self . request_get_json ( url = url ) async def account_contacts ( self ) -> List [ AccountContact ]: \"\"\"Pulls the contacts with the account, returns a list of dicts Dict keys: `['id', 'first_name', 'last_name', 'email', 'dob', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact']` \"\"\" url = self . get_url ( \"account_contacts\" ) response = await self . request_get_json ( url = url ) return [ AccountContact . parse_obj ( contact ) for contact in response ] async def get_orders ( self ) -> Dict [ str , Any ]: \"\"\"pulls the outstanding orders for an account\"\"\" url = self . get_url ( \"get_orders\" ) responsedata = await self . request_get_json ( url = url ) result = OrderDetailResponseModel ( ** responsedata ) return result . dict () async def get_order ( self , order_id : int ) -> Dict [ str , Any ]: \"\"\"gets a specific order\"\"\" url = self . get_url ( \"get_order\" , { \"order_id\" : order_id }) responsedata = await self . request_get_json ( url = url ) result = OrderDetailResponseModel ( ** responsedata ) return result . dict () async def get_voip_devices ( self , service_id : int ) -> List [ VOIPDevice ]: \"\"\"gets the devices associatd with a VOIP service\"\"\" url = self . get_url ( \"voip_devices\" , { \"service_id\" : service_id }) service_list : List [ VOIPDevice ] = [] data = await self . request_get_json ( url = url ) for service in data : service_list . append ( VOIPDevice . parse_obj ( service )) return service_list async def get_voip_service ( self , service_id : int ) -> VOIPService : \"\"\"gets the details of a VOIP service\"\"\" url = self . get_url ( \"voip_service\" , { \"service_id\" : service_id }) data = await self . request_get_json ( url = url ) return VOIPService . parse_obj ( data )","title":"AussieBB"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.referral_code","text":"returns the referral code, which is just the customer number","title":"referral_code"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.__init__","text":"Setup function @param username: str - username for Aussie Broadband account @param password: str - password for Aussie Broadband account @param debug: bool - debug mode @param services_cache_time: int - seconds between caching get_services() - defaults to 8 hours Source code in aussiebb/asyncio/__init__.py def __init__ ( self , username : str , password : str , session : Optional [ aiohttp . client . ClientSession ] = None , debug : bool = False , services_cache_time : int = 28800 , ): \"\"\"Setup function ``` @param username: str - username for Aussie Broadband account @param password: str - password for Aussie Broadband account @param debug: bool - debug mode @param services_cache_time: int - seconds between caching get_services() - defaults to 8 hours ``` \"\"\" super () . __init__ ( username , password , debug , services_cache_time ) if not session : self . session = aiohttp . ClientSession () else : self . session = session","title":"__init__()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.account_contacts","text":"Pulls the contacts with the account, returns a list of dicts Dict keys: ['id', 'first_name', 'last_name', 'email', 'dob', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact'] Source code in aussiebb/asyncio/__init__.py async def account_contacts ( self ) -> List [ AccountContact ]: \"\"\"Pulls the contacts with the account, returns a list of dicts Dict keys: `['id', 'first_name', 'last_name', 'email', 'dob', 'home_phone', 'work_phone', 'mobile_phone', 'work_mobile', 'primary_contact']` \"\"\" url = self . get_url ( \"account_contacts\" ) response = await self . request_get_json ( url = url ) return [ AccountContact . parse_obj ( contact ) for contact in response ]","title":"account_contacts()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.account_paymentplans","text":"Returns a dict of payment plans for an account Source code in aussiebb/asyncio/__init__.py async def account_paymentplans ( self ): \"\"\"Returns a dict of payment plans for an account\"\"\" url = self . get_url ( \"account_paymentplans\" ) responsedata = await self . request_get_json ( url = url ) return responsedata","title":"account_paymentplans()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.account_transactions","text":"Pulls the data for transactions on your account. Returns a dict where the key is the month and year of the transaction. Keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] Example output: \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], Source code in aussiebb/asyncio/__init__.py async def account_transactions ( self ) -> Dict [ str , AccountTransaction ]: \"\"\"Pulls the data for transactions on your account. Returns a dict where the key is the month and year of the transaction. Keys: `['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds']` Example output: ``` json \"August 2021\": [ { \"id\": 12345, \"type\": \"receipt\", \"time\": \"2021-08-06\", \"description\": \"Payment #12345\", \"amountCents\": -8400, \"runningBalanceCents\": 0 } ], ``` \"\"\" url = self . get_url ( \"account_transactions\" ) responsedata : Dict [ str , AccountTransaction ] = await self . request_get_json ( url = url ) return responsedata","title":"account_transactions()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.billing_invoice","text":"Downloads an invoice This returns the bare response object, parsing the result is an exercise for the consumer. It's a PDF file. Source code in aussiebb/asyncio/__init__.py async def billing_invoice ( self , invoice_id : int ): \"\"\"Downloads an invoice This returns the bare response object, parsing the result is an exercise for the consumer. It's a PDF file. \"\"\" url = self . get_url ( \"billing_invoice\" , { \"invoice_id\" : invoice_id }) responsedata = await self . request_get_json ( url = url ) return responsedata","title":"billing_invoice()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.do_login_check","text":"checks if we're skipping the login check and logs in if necessary Source code in aussiebb/asyncio/__init__.py async def do_login_check ( self , skip_login_check : bool ) -> None : \"\"\"checks if we're skipping the login check and logs in if necessary\"\"\" if not skip_login_check : self . logger . debug ( \"skip_login_check false\" ) if self . _has_token_expired (): self . logger . debug ( \"token has expired, logging in...\" ) await self . login ()","title":"do_login_check()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.get_appointment","text":"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] Source code in aussiebb/asyncio/__init__.py async def get_appointment ( self , ticketid : int ): \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"get_appointment\" , { \"ticketid\" : ticketid }) return await self . request_get_json ( url = url )","title":"get_appointment()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.get_customer_details","text":"Grabs the customer details. Returns a dict Source code in aussiebb/asyncio/__init__.py async def get_customer_details ( self ) -> Dict [ str , Any ]: \"\"\"Grabs the customer details. Returns a dict\"\"\" url = self . get_url ( \"get_customer_details\" ) params = { \"v\" : \"2\" } result : Dict [ str , Any ] = await self . request_get_json ( url = url , params = params , ) return result","title":"get_customer_details()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.get_order","text":"gets a specific order Source code in aussiebb/asyncio/__init__.py async def get_order ( self , order_id : int ) -> Dict [ str , Any ]: \"\"\"gets a specific order\"\"\" url = self . get_url ( \"get_order\" , { \"order_id\" : order_id }) responsedata = await self . request_get_json ( url = url ) result = OrderDetailResponseModel ( ** responsedata ) return result . dict ()","title":"get_order()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.get_orders","text":"pulls the outstanding orders for an account Source code in aussiebb/asyncio/__init__.py async def get_orders ( self ) -> Dict [ str , Any ]: \"\"\"pulls the outstanding orders for an account\"\"\" url = self . get_url ( \"get_orders\" ) responsedata = await self . request_get_json ( url = url ) result = OrderDetailResponseModel ( ** responsedata ) return result . dict ()","title":"get_orders()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.get_service_tests","text":"Gets the available tests for a given service ID Returns list of dicts Example data: [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] This has a habit of throwing 400 errors if you query a VOIP service... Source code in aussiebb/asyncio/__init__.py async def get_service_tests ( self , service_id : int ) -> List [ ServiceTest ]: \"\"\"Gets the available tests for a given service ID Returns list of dicts Example data: ``` [{ 'name' : str(), 'description' : str', 'link' : str(a url to the test) },] ``` This has a habit of throwing 400 errors if you query a VOIP service... \"\"\" if self . debug : print ( f \"Getting service tests for { service_id } \" , file = sys . stderr ) url = self . get_url ( \"get_service_tests\" , { \"service_id\" : service_id }) responsedata : List [ ServiceTest ] = await self . request_get_json ( url = url ) return responsedata","title":"get_service_tests()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.get_services","text":"Returns a list of dicts of services associated with the account. If you want a specific kind of service, or services, provide a list of matching strings in servicetypes. If you want to use cached data, call it with use_cached=True Source code in aussiebb/asyncio/__init__.py async def get_services ( self , page : int = 1 , servicetypes : Optional [ List [ str ]] = None , use_cached : bool = False , ): \"\"\"Returns a `list` of `dicts` of services associated with the account. If you want a specific kind of service, or services, provide a list of matching strings in servicetypes. If you want to use cached data, call it with `use_cached=True` \"\"\" if use_cached : self . logger . debug ( \"Using cached data for get_services.\" ) await self . _check_reload_cached_services () else : url = self . get_url ( \"get_services\" ) services_list : List [ Dict [ str , Any ]] = [] while True : params = { \"page\" : page } responsedata = await self . request_get_json ( url = url , params = params ) servicedata = GetServicesResponse . parse_obj ( responsedata ) for link in servicedata . data : services_list . append ( link ) if servicedata . links . next is None : break url = servicedata . links . next page = servicedata . meta [ \"current_page\" ] self . services = services_list self . services_last_update = int ( time ()) # TODO: validate the expected fields in the service (type, name, plan, description, service_id at a minimum) # only filter if we need to if servicetypes is not None : self . logger . debug ( \"Filtering services based on provided list: %s \" , servicetypes ) filtered_responsedata : List [ Any ] = [] if self . services is not None : for service in self . services : if \"type\" not in service : raise ValueError ( f \"No type field in service info: { service } \" ) if service [ \"type\" ] in servicetypes : filtered_responsedata . append ( service ) else : self . logger . debug ( \"Skipping as type== %s - %s \" , service [ \"type\" ], service ) return filtered_responsedata return self . services","title":"get_services()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.get_test_history","text":"Gets the available tests for a given service ID Returns a list of dicts with tests which have been run Source code in aussiebb/asyncio/__init__.py async def get_test_history ( self , service_id : int ): \"\"\"Gets the available tests for a given service ID Returns a list of dicts with tests which have been run \"\"\" url = self . get_url ( \"get_test_history\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) return responsedata","title":"get_test_history()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.get_usage","text":"Returns a dict of usage for a service. If it's a telephony service ( type in aussiebb.const.PHONE_TYPES ) it'll pull from the telephony endpoint. Source code in aussiebb/asyncio/__init__.py async def get_usage ( self , service_id : int , use_cached : bool = True ): \"\"\" Returns a dict of usage for a service. If it's a telephony service (`type in aussiebb.const.PHONE_TYPES`) it'll pull from the telephony endpoint. \"\"\" services = await self . get_services ( use_cached = use_cached ) for service in services : if service_id == service [ \"service_id\" ]: # throw an error if we're trying to parse something we can't self . validate_service_type ( service ) if service [ \"type\" ] in PHONE_TYPES : return await self . telephony_usage ( service_id ) url = self . get_url ( \"get_usage\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) return responsedata","title":"get_usage()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.get_voip_devices","text":"gets the devices associatd with a VOIP service Source code in aussiebb/asyncio/__init__.py async def get_voip_devices ( self , service_id : int ) -> List [ VOIPDevice ]: \"\"\"gets the devices associatd with a VOIP service\"\"\" url = self . get_url ( \"voip_devices\" , { \"service_id\" : service_id }) service_list : List [ VOIPDevice ] = [] data = await self . request_get_json ( url = url ) for service in data : service_list . append ( VOIPDevice . parse_obj ( service )) return service_list","title":"get_voip_devices()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.get_voip_service","text":"gets the details of a VOIP service Source code in aussiebb/asyncio/__init__.py async def get_voip_service ( self , service_id : int ) -> VOIPService : \"\"\"gets the details of a VOIP service\"\"\" url = self . get_url ( \"voip_service\" , { \"service_id\" : service_id }) data = await self . request_get_json ( url = url ) return VOIPService . parse_obj ( data )","title":"get_voip_service()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.handle_response_fail","text":"Handles response status codes. Tries to gracefully handle the rate limiting. @param response - aiohttp.Response - the full response object @param wait_on_rate_limit - bool - if hitting a rate limit, async wait on the time limit Source code in aussiebb/asyncio/__init__.py async def handle_response_fail ( self , response : ClientResponse , wait_on_rate_limit : bool = True , ) -> None : \"\"\"Handles response status codes. Tries to gracefully handle the rate limiting. ``` @param response - aiohttp.Response - the full response object @param wait_on_rate_limit - bool - if hitting a rate limit, async wait on the time limit ``` \"\"\" ratelimit_remaining = int ( response . headers . get ( \"x-ratelimit-remaining\" , - 1 )) self . logger . debug ( \"Rate limit header: %s \" , response . headers . get ( \"x-ratelimit-remaining\" , - 1 ) ) if ratelimit_remaining < 5 and wait_on_rate_limit : print ( \"Rate limit below 5, sleeping for 1 second.\" , file = sys . stderr ) await asyncio . sleep ( 1 ) if response . status == 422 : raise AuthenticationException ( await response . json ()) if response . status == 429 : jsondata = await response . json () self . logger . debug ( \"Dumping headers: %s \" , response . headers ) self . logger . debug ( \"Dumping response: %s \" , json . dumps ( jsondata , default = str )) delay = DEFAULT_BACKOFF_DELAY if \"Please try again in \" in str ( jsondata . get ( \"errors\" )): fallback_value = [ f \"default { DEFAULT_BACKOFF_DELAY } seconds\" ] delay = ( jsondata . get ( \"errors\" , {}) . get ( \"username\" , fallback_value )[ 0 ] . split ()[ - 2 ] ) # give it some extra time to cool off delay = int ( delay ) + 5 if 0 < delay < 1000 : self . logger . debug ( \"Found required rate limit delay: %s \" , delay ) delay = int ( delay ) else : self . logger . debug ( \"Couldn't parse rate limit delay, using default: %s \" , delay ) else : delay = DEFAULT_BACKOFF_DELAY self . logger . debug ( \"Couldn't parse delay, using default: %s \" , delay ) if wait_on_rate_limit : self . logger . debug ( \"Rate limit on Aussie API calls raised, sleeping for %s seconds.\" , delay , ) await asyncio . sleep ( delay ) raise RateLimitException ( jsondata ) response . raise_for_status ()","title":"handle_response_fail()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.login","text":"Logs into the account and caches the cookie. Source code in aussiebb/asyncio/__init__.py async def login ( self , depth : int = 0 ) -> bool : \"\"\"Logs into the account and caches the cookie.\"\"\" if depth > 2 : raise RecursiveDepth ( \"Login recursion depth > 2\" ) self . logger . debug ( \"Logging in...\" ) url = BASEURL [ \"login\" ] if not self . _has_token_expired (): return True payload = { \"username\" : self . username , \"password\" : self . password , } headers = default_headers () async with self . session . post ( url = url , headers = headers , json = payload , ) as response : try : await self . handle_response_fail ( response ) jsondata = await response . json () except RateLimitException : return await self . login ( depth + 1 ) self . logger . debug ( \"Login response status: %s \" , response . status ) self . logger . debug ( \"Dumping login response: %s \" , json . dumps ( jsondata )) return self . _handle_login_response ( response . status , jsondata , response . cookies )","title":"login()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.request_get","text":"Performs a GET request and logs in first if needed. Source code in aussiebb/asyncio/__init__.py async def request_get ( self , url : str , skip_login_check : bool = False , depth : int = 0 , ** kwargs : Dict [ str , Any ], ) -> ClientResponse : \"\"\"Performs a GET request and logs in first if needed.\"\"\" if depth > 2 : raise RecursiveDepth ( f \"depth: { depth } \" ) if self . session is None : self . session = aiohttp . ClientSession () await self . do_login_check ( skip_login_check ) if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } response = await self . session . get ( url = url , ** kwargs ) # type: ignore # async with self.session.get(url=url, **kwargs) as response: try : await self . handle_response_fail ( response ) await response . read () except RateLimitException : response = await self . request_get ( url = url , skip_login_check = skip_login_check , depth = depth , ** kwargs ) return response","title":"request_get()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.request_get_json","text":"Performs a GET request and logs in first if needed. Returns a dict of the JSON response. Source code in aussiebb/asyncio/__init__.py async def request_get_json ( self , skip_login_check : bool = False , ** kwargs ) -> Any : \"\"\"Performs a GET request and logs in first if needed. Returns a dict of the JSON response. \"\"\" depth = kwargs . get ( \"depth\" , 0 ) if depth > 2 : raise RecursiveDepth ( f \"depth: { depth } \" ) if self . session is None : self . session = aiohttp . ClientSession () await self . do_login_check ( skip_login_check ) if \"cookies\" not in kwargs : kwargs [ \"cookies\" ] = { \"myaussie_cookie\" : self . myaussie_cookie } async with self . session . get ( ** kwargs ) as response : try : await self . handle_response_fail ( response ) jsondata = await response . json () except RateLimitException : jsondata = await self . request_get_json ( skip_login_check , ** kwargs ) return jsondata","title":"request_get_json()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.request_post_json","text":"Performs a POST request and logs in first if needed. Returns a dict of the response data. Source code in aussiebb/asyncio/__init__.py async def request_post_json ( self , url = str , depth : int = 0 , skip_login_check : bool = False , ** kwargs : Dict [ str , Any ], ) -> Dict [ str , Any ]: \"\"\"Performs a POST request and logs in first if needed. Returns a dict of the response data. \"\"\" if depth > 2 : raise RecursiveDepth ( f \"depth: { depth } \" ) if self . session is None : self . session = aiohttp . ClientSession () await self . do_login_check ( skip_login_check ) cookies = kwargs . get ( \"cookies\" , { \"myaussie_cookie\" : self . myaussie_cookie }) headers = kwargs . get ( \"headers\" , default_headers ()) async with self . session . post ( url = url , cookies = cookies , headers = headers ) as response : try : await self . handle_response_fail ( response ) jsondata : Dict [ str , Any ] = await response . json () except RateLimitException : jsondata = await self . request_post_json ( url = url , depth = depth + 1 , skip_login_check = skip_login_check , ** kwargs , ) return jsondata","title":"request_post_json()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.run_test","text":"Run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' 'status' of 'Completed' means you've got the full response Source code in aussiebb/asyncio/__init__.py async def run_test ( self , service_id : int , test_name : str , test_method : str = \"post\" ): \"\"\"Run a test, but it checks it's valid first There doesn't seem to be a valid way to identify what method you're supposed to use on each test. See the README for more analysis - 'status' of 'InProgress' use 'AussieBB.get_test_history()' and look for the 'id' - 'status' of 'Completed' means you've got the full response \"\"\" service_tests = await self . get_service_tests ( service_id ) test_links = [ test for test in service_tests if test . get ( \"link\" , \"\" ) . endswith ( f \"/ { test_name } \" ) ] # pylint: disable=line-too-long if not test_links : return False if len ( test_links ) != 1 : if self . debug : print ( f \"Too many tests? { test_links } \" , file = sys . stderr ) test_name = test_links [ 0 ][ \"name\" ] if self . debug : print ( f \"Running { test_name } \" , file = sys . stderr ) if test_method == \"get\" : result = await self . request_get_json ( url = test_links [ 0 ] . get ( \"link\" )) else : result = await self . request_post_json ( url = test_links [ 0 ] . get ( \"link\" )) return result","title":"run_test()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.service_boltons","text":"Pulls addons associated with the service. Keys: ['id', 'name', 'description', 'costCents', 'additionalNote', 'active'] Example data: [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] Source code in aussiebb/asyncio/__init__.py async def service_boltons ( self , service_id : int ): \"\"\"Pulls addons associated with the service. Keys: `['id', 'name', 'description', 'costCents', 'additionalNote', 'active']` Example data: ``` [{ \"id\": 4, \"name\": \"Small Change Big Change Donation\", \"description\": \"Charitable donation to the Small Change Big Change program, part of the Telco Together Foundation, which helps build resilient young Australians\", \"costCents\": 100, \"additionalNote\": null, \"active\": false }] ``` \"\"\" url = self . get_url ( \"service_boltons\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata","title":"service_boltons()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.service_datablocks","text":"Pulls datablocks associated with the service. Keys: ['current', 'available'] Example data: { \"current\": [], \"available\": [] } Source code in aussiebb/asyncio/__init__.py async def service_datablocks ( self , service_id : int ): \"\"\"Pulls datablocks associated with the service. Keys: `['current', 'available']` Example data: ``` { \"current\": [], \"available\": [] } ``` \"\"\" url = self . get_url ( \"service_datablocks\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata","title":"service_datablocks()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.service_outages","text":"Pulls outages associated with a service. Keys: ['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages'] Example data: { \"networkEvents\": [], \"aussieOutages\": [], \"currentNbnOutages\": [], \"scheduledNbnOutages\": [], \"resolvedScheduledNbnOutages\": [ { \"start_date\": \"2021-08-17T14:00:00Z\", \"end_date\": \"2021-08-17T20:00:00Z\", \"duration\": \"6.0\" } ], \"resolvedNbnOutages\": [] } Source code in aussiebb/asyncio/__init__.py async def service_outages ( self , service_id : int ): \"\"\"Pulls outages associated with a service. Keys: `['networkEvents', 'aussieOutages', 'currentNbnOutages', 'scheduledNbnOutages', 'resolvedScheduledNbnOutages', 'resolvedNbnOutages']` Example data: ``` { \"networkEvents\": [], \"aussieOutages\": [], \"currentNbnOutages\": [], \"scheduledNbnOutages\": [], \"resolvedScheduledNbnOutages\": [ { \"start_date\": \"2021-08-17T14:00:00Z\", \"end_date\": \"2021-08-17T20:00:00Z\", \"duration\": \"6.0\" } ], \"resolvedNbnOutages\": [] } ``` \"\"\" url = self . get_url ( \"service_outages\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata","title":"service_outages()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.service_plans","text":"Pulls the plan data for a given service. Keys: ['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds'] Source code in aussiebb/asyncio/__init__.py async def service_plans ( self , service_id : int ): \"\"\"Pulls the plan data for a given service. Keys: `['current', 'pending', 'available', 'filters', 'typicalEveningSpeeds']` \"\"\" url = self . get_url ( \"service_plans\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata","title":"service_plans()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.support_tickets","text":"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: ['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes'] Source code in aussiebb/asyncio/__init__.py async def support_tickets ( self ): \"\"\"Pulls the support tickets associated with the account, returns a list of dicts. Dict keys: `['ref', 'create', 'updated', 'service_id', 'type', 'subject', 'status', 'closed', 'awaiting_customer_reply', 'expected_response_minutes']` \"\"\" url = self . get_url ( \"support_tickets\" ) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata","title":"support_tickets()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.telephony_usage","text":"Pulls the telephony usage associated with the service. Keys: ['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical'] Example data: {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} Source code in aussiebb/asyncio/__init__.py async def telephony_usage ( self , service_id : int ): \"\"\"Pulls the telephony usage associated with the service. Keys: `['national', 'mobile', 'international', 'sms', 'internet', 'voicemail', 'other', 'daysTotal', 'daysRemaining', 'historical']` Example data: ``` {\"national\":{\"calls\":0,\"cost\":0},\"mobile\":{\"calls\":0,\"cost\":0},\"international\":{\"calls\":0,\"cost\":0},\"sms\":{\"calls\":0,\"cost\":0},\"internet\":{\"kbytes\":0,\"cost\":0},\"voicemail\":{\"calls\":0,\"cost\":0},\"other\":{\"calls\":0,\"cost\":0},\"daysTotal\":31,\"daysRemaining\":2,\"historical\":[]} ``` \"\"\" url = self . get_url ( \"telephony_usage\" , { \"service_id\" : service_id }) responsedata = await self . request_get_json ( url = url ) if self . debug : print ( responsedata , file = sys . stderr ) return responsedata","title":"telephony_usage()"},{"location":"aussiebb/#aussiebb.asyncio.AussieBB.test_line_state","text":"Tests the line state for a given service ID Source code in aussiebb/asyncio/__init__.py async def test_line_state ( self , service_id : int ): \"\"\"Tests the line state for a given service ID\"\"\" # TODO: check if this is valid for the service id url = self . get_url ( \"test_line_state\" , { \"service_id\" : service_id }) if self . debug : print ( \"Testing line state, can take a few seconds...\" ) response = await self . request_post_json ( url = url ) if self . debug : print ( f \"Response: { response } \" , file = sys . stderr ) return response","title":"test_line_state()"},{"location":"aussiebb/#aussiebb.baseclass","text":"base class def","title":"baseclass"},{"location":"aussiebb/#aussiebb.baseclass.BaseClass","text":"Base class for aussiebb API clients Source code in aussiebb/baseclass.py class BaseClass : \"\"\"Base class for aussiebb API clients\"\"\" API_ENDPOINTS = API_ENDPOINTS BASEURL = BASEURL def __init__ ( self , username : str , password : str , debug : bool = False , services_cache_time : int = 28800 , logger : logging . Logger = logging . getLogger (), ): if not ( username and password ): raise AuthenticationException ( \"You need to supply both username and password\" ) self . myaussie_cookie : Optional [ Union [ Morsel [ Any ], SimpleCookie [ Any ]]] = None self . token_expires = - 1 self . services_cache_time = services_cache_time # defaults to 8 hours self . services_last_update = - 1 self . services : List [ Dict [ str , Any ]] = [] self . username = username self . password = password self . logger = logger self . debug = debug def __str__ ( self ) -> str : \"\"\"string repr of account - returns username\"\"\" return self . username def get_url ( self , function_name : str , data : Optional [ Dict [ str , Any ]] = None ) -> str : \"\"\"gets the URL based on the data/function\"\"\" if function_name not in self . API_ENDPOINTS : raise ValueError ( f \"Function name { function_name } not found, cannot find URL\" ) if data : api_endpoint = self . API_ENDPOINTS [ function_name ] . format ( ** data ) else : api_endpoint = self . API_ENDPOINTS [ function_name ] return f \" { self . BASEURL . get ( 'api' ) }{ api_endpoint } \" def _has_token_expired ( self ) -> bool : \"\"\"Returns bool of if the token has expired\"\"\" if time () > self . token_expires : return True return False def _handle_login_response ( self , status_code : int , jsondata : Dict [ str , Any ], cookies : Union [ RequestsCookieJar , SimpleCookie [ Any ]], ) -> bool : \"\"\"Handles the login response. We expire the session a little early just to be safe, and if we don't get an expiry, we just bail.\"\"\" # just reset it in case self . token_expires = - 1 self . myaussie_cookie = None if status_code == 422 : raise AuthenticationException ( jsondata ) if status_code == 429 : raise RateLimitException ( jsondata ) # expected response from the API looks like # data: { \"expiresIn\" : 500 } # cookies: { \"myaussie_cookie\" : \"somerandomcookiethings\" } if \"expiresIn\" not in jsondata : return False if ( \"myaussie_cookie\" not in cookies or str ( cookies [ \"myaussie_cookie\" ]) . strip () == \"\" ): return False self . token_expires = time () + jsondata . get ( \"expiresIn\" , 0 ) - 50 self . myaussie_cookie = cookies [ \"myaussie_cookie\" ] self . logger . debug ( \"Login Cookie: %s \" , self . myaussie_cookie ) return True @classmethod def validate_service_type ( cls , service : Dict [ str , Any ]) -> None : \"\"\"Check the service types against known types\"\"\" if \"type\" not in service : raise ValueError ( \"Field 'type' not found in service data\" ) if service [ \"type\" ] not in NBN_TYPES + PHONE_TYPES : raise UnrecognisedServiceType ( f \"Service type ' { service [ 'type' ] } ' not recognised - please raise an issue about this - https://github.com/yaleman/aussiebb/issues/new\" )","title":"BaseClass"},{"location":"aussiebb/#aussiebb.baseclass.BaseClass.__str__","text":"string repr of account - returns username Source code in aussiebb/baseclass.py def __str__ ( self ) -> str : \"\"\"string repr of account - returns username\"\"\" return self . username","title":"__str__()"},{"location":"aussiebb/#aussiebb.baseclass.BaseClass.get_url","text":"gets the URL based on the data/function Source code in aussiebb/baseclass.py def get_url ( self , function_name : str , data : Optional [ Dict [ str , Any ]] = None ) -> str : \"\"\"gets the URL based on the data/function\"\"\" if function_name not in self . API_ENDPOINTS : raise ValueError ( f \"Function name { function_name } not found, cannot find URL\" ) if data : api_endpoint = self . API_ENDPOINTS [ function_name ] . format ( ** data ) else : api_endpoint = self . API_ENDPOINTS [ function_name ] return f \" { self . BASEURL . get ( 'api' ) }{ api_endpoint } \"","title":"get_url()"},{"location":"aussiebb/#aussiebb.baseclass.BaseClass.validate_service_type","text":"Check the service types against known types Source code in aussiebb/baseclass.py @classmethod def validate_service_type ( cls , service : Dict [ str , Any ]) -> None : \"\"\"Check the service types against known types\"\"\" if \"type\" not in service : raise ValueError ( \"Field 'type' not found in service data\" ) if service [ \"type\" ] not in NBN_TYPES + PHONE_TYPES : raise UnrecognisedServiceType ( f \"Service type ' { service [ 'type' ] } ' not recognised - please raise an issue about this - https://github.com/yaleman/aussiebb/issues/new\" )","title":"validate_service_type()"},{"location":"aussiebb/#aussiebb.const","text":"constants and utilities","title":"const"},{"location":"aussiebb/#aussiebb.const.default_headers","text":"returns a default set of headers Source code in aussiebb/const.py def default_headers () -> DefaultHeaders : \"\"\"returns a default set of headers\"\"\" return { \"Accept\" : \"application/json\" , \"Content-Type\" : \"application/json\" , \"Origin\" : \"https://my.aussiebroadband.com.au\" , \"Referer\" : \"https://my.aussiebroadband.com.au/\" , \"Cache-Control\" : \"no-cache\" , }","title":"default_headers()"},{"location":"aussiebb/#aussiebb.exceptions","text":"exceptions for the AussieBB module","title":"exceptions"},{"location":"aussiebb/#aussiebb.exceptions.AuthenticationException","text":"authentication error for AussieBB Source code in aussiebb/exceptions.py class AuthenticationException ( BaseException ): \"\"\"authentication error for AussieBB\"\"\"","title":"AuthenticationException"},{"location":"aussiebb/#aussiebb.exceptions.InvalidTestForService","text":"user specified an invalid test Source code in aussiebb/exceptions.py class InvalidTestForService ( BaseException ): \"\"\"user specified an invalid test\"\"\"","title":"InvalidTestForService"},{"location":"aussiebb/#aussiebb.exceptions.RateLimitException","text":"rate limit error for AussieBB Source code in aussiebb/exceptions.py class RateLimitException ( BaseException ): \"\"\"rate limit error for AussieBB\"\"\"","title":"RateLimitException"},{"location":"aussiebb/#aussiebb.exceptions.RecursiveDepth","text":"you've gone too far down the rabbit hole Source code in aussiebb/exceptions.py class RecursiveDepth ( BaseException ): \"\"\"you've gone too far down the rabbit hole\"\"\"","title":"RecursiveDepth"},{"location":"aussiebb/#aussiebb.exceptions.UnrecognisedServiceType","text":"You've got a service type we haven't seen before Source code in aussiebb/exceptions.py class UnrecognisedServiceType ( BaseException ): \"\"\"You've got a service type we haven't seen before\"\"\"","title":"UnrecognisedServiceType"},{"location":"aussiebb/#aussiebb.types","text":"types","title":"types"},{"location":"aussiebb/#aussiebb.types.APIResponseLinks","text":"the links field from an API response Source code in aussiebb/types.py class APIResponseLinks ( BaseModel ): \"\"\"the links field from an API response\"\"\" first : str last : str prev : Optional [ str ] next : Optional [ str ]","title":"APIResponseLinks"},{"location":"aussiebb/#aussiebb.types.AccountContact","text":"account contact data Source code in aussiebb/types.py class AccountContact ( BaseModel ): \"\"\"account contact data\"\"\" contact_id : int = Field ( ... , alias = \"id\" ) first_name : str last_name : str email : List [ str ] dob : str home_phone : Optional [ str ] work_phone : Optional [ str ] mobile_phone : Optional [ str ] work_mobile : Optional [ str ] primary_contact : bool username : Optional [ str ] preferred_name : Optional [ str ] middle_name : Optional [ str ]","title":"AccountContact"},{"location":"aussiebb/#aussiebb.types.AccountTransaction","text":"Transaction data typing, returns from account_transactions Source code in aussiebb/types.py class AccountTransaction ( TypedDict ): \"\"\"Transaction data typing, returns from account_transactions\"\"\" id : int type : str time : str description : str amountCents : int runningBalanceCents : int","title":"AccountTransaction"},{"location":"aussiebb/#aussiebb.types.AussieBBConfigFile","text":"config file definition Source code in aussiebb/types.py class AussieBBConfigFile ( BaseModel ): \"\"\"config file definition\"\"\" users : List [ ConfigUser ] username : Optional [ str ] password : Optional [ SecretStr ] class Config : \"\"\"metadata\"\"\" arbitrary_types_allowed = True","title":"AussieBBConfigFile"},{"location":"aussiebb/#aussiebb.types.AussieBBConfigFile.Config","text":"metadata Source code in aussiebb/types.py class Config : \"\"\"metadata\"\"\" arbitrary_types_allowed = True","title":"Config"},{"location":"aussiebb/#aussiebb.types.AussieBBOutage","text":"outage class Source code in aussiebb/types.py class AussieBBOutage ( BaseModel ): \"\"\"outage class\"\"\" networkEvents : List [ OutageRecord ] aussieOutages : Dict [ str , List [ OutageRecord ]] currentNbnOutages : List [ Any ] # TODO: define currentNbnOutages scheduledNbnOutages : List [ ScheduledOutageRecord ] # TODO: define scheduledNbnOutages resolvedScheduledNbnOutages : List [ ScheduledOutageRecord ] # TODO: define resolvedScheduledNbnOutages resolvedNbnOutages : List [ Any ] # TODO: define resolvedNbnOutages class Config : \"\"\"config\"\"\" arbitrary_types_allowed = True","title":"AussieBBOutage"},{"location":"aussiebb/#aussiebb.types.AussieBBOutage.Config","text":"config Source code in aussiebb/types.py class Config : \"\"\"config\"\"\" arbitrary_types_allowed = True","title":"Config"},{"location":"aussiebb/#aussiebb.types.ConfigUser","text":"just a username and password field Source code in aussiebb/types.py class ConfigUser ( BaseModel ): \"\"\"just a username and password field\"\"\" username : str password : str","title":"ConfigUser"},{"location":"aussiebb/#aussiebb.types.GetServicesResponse","text":"the format for a response from the get_services call Source code in aussiebb/types.py class GetServicesResponse ( BaseModel ): \"\"\"the format for a response from the get_services call\"\"\" data : List [ Dict [ str , Any ]] links : APIResponseLinks meta : APIResponseMeta class Config : \"\"\"metadata\"\"\" arbitrary_types_allowed = True","title":"GetServicesResponse"},{"location":"aussiebb/#aussiebb.types.GetServicesResponse.Config","text":"metadata Source code in aussiebb/types.py class Config : \"\"\"metadata\"\"\" arbitrary_types_allowed = True","title":"Config"},{"location":"aussiebb/#aussiebb.types.OrderData","text":"order element for OrderResponse get_orders Source code in aussiebb/types.py class OrderData ( TypedDict ): \"\"\"order element for OrderResponse get_orders\"\"\" id : int status : str type : str description : str","title":"OrderData"},{"location":"aussiebb/#aussiebb.types.OrderDetailResponseModel","text":"order Response for get_order(int) Source code in aussiebb/types.py class OrderDetailResponseModel ( BaseModel ): \"\"\"order Response for get_order(int)\"\"\" id : int status : str plan : str address : str appointment : str appointment_reschedule_code : int = Field ( ... , alias = \"appointmentRescheduleCode\" ) statuses : List [ str ]","title":"OrderDetailResponseModel"},{"location":"aussiebb/#aussiebb.types.OrderResponse","text":"response from get_orders Source code in aussiebb/types.py class OrderResponse ( BaseModel ): \"\"\"response from get_orders\"\"\" data : List [ OrderData ] links : APIResponseLinks meta : APIResponseMeta class Config : \"\"\"config\"\"\" arbitrary_types_allowed = True","title":"OrderResponse"},{"location":"aussiebb/#aussiebb.types.OrderResponse.Config","text":"config Source code in aussiebb/types.py class Config : \"\"\"config\"\"\" arbitrary_types_allowed = True","title":"Config"},{"location":"aussiebb/#aussiebb.types.OutageRecord","text":"outage def Source code in aussiebb/types.py class OutageRecord ( BaseModel ): \"\"\"outage def\"\"\" reference : int title : str summary : str start_time : datetime end_time : datetime restored_at : Optional [ datetime ] last_updated : Optional [ datetime ]","title":"OutageRecord"},{"location":"aussiebb/#aussiebb.types.ScheduledOutageRecord","text":"scheduled outage record Source code in aussiebb/types.py class ScheduledOutageRecord : \"\"\"scheduled outage record\"\"\" start_date : datetime end_date : datetime duration : float","title":"ScheduledOutageRecord"},{"location":"aussiebb/#aussiebb.types.ServiceTest","text":"A service test object Source code in aussiebb/types.py class ServiceTest ( TypedDict ): \"\"\"A service test object\"\"\" name : str description : str link : str","title":"ServiceTest"},{"location":"aussiebb/#aussiebb.types.VOIPDevice","text":"an individual service device Source code in aussiebb/types.py class VOIPDevice ( BaseModel ): \"\"\"an individual service device\"\"\" username : str password : str registered : bool # is it online?","title":"VOIPDevice"},{"location":"aussiebb/#aussiebb.types.VOIPService","text":"individual VOIP service Source code in aussiebb/types.py class VOIPService ( BaseModel ): \"\"\"individual VOIP service\"\"\" phoneNumber : str barInternational : bool divertNumber : Optional [ str ] supportsNumberDiversion : bool","title":"VOIPService"},{"location":"aussiebb/#aussiebb.utils","text":"shared utility functions","title":"utils"},{"location":"release/","text":"Doing a release Commit things Ensure the version's bumped in pyproject.toml Do the tag: git tag -a v0.0.10 -m 'Lint all the things' Check the tag showed up: git tag Check the tag: git show v0.0.10 Push the tag: git push origin v0.0.10 Draft a release on Github Publish to pypi: poetry publish","title":"Releasing"},{"location":"release/#doing-a-release","text":"Commit things Ensure the version's bumped in pyproject.toml Do the tag: git tag -a v0.0.10 -m 'Lint all the things' Check the tag showed up: git tag Check the tag: git show v0.0.10 Push the tag: git push origin v0.0.10 Draft a release on Github Publish to pypi: poetry publish","title":"Doing a release"}]}